
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Bytes - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package. ">
  <meta name="keywords" content="package, bytes, -, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/go/bytes/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _go">
				
				
<h1> Package bytes  </h1>     <ul id="short-nav">
<li><code>import "bytes"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2>Overview </h2> <p> Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package. </p>      <h2>Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#Compare">func Compare(a, b []byte) int</a></li>
<li><a href="#Contains">func Contains(b, subslice []byte) bool</a></li>
<li><a href="#ContainsAny">func ContainsAny(b []byte, chars string) bool</a></li>
<li><a href="#ContainsRune">func ContainsRune(b []byte, r rune) bool</a></li>
<li><a href="#Count">func Count(s, sep []byte) int</a></li>
<li><a href="#Equal">func Equal(a, b []byte) bool</a></li>
<li><a href="#EqualFold">func EqualFold(s, t []byte) bool</a></li>
<li><a href="#Fields">func Fields(s []byte) [][]byte</a></li>
<li><a href="#FieldsFunc">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</a></li>
<li><a href="#HasPrefix">func HasPrefix(s, prefix []byte) bool</a></li>
<li><a href="#HasSuffix">func HasSuffix(s, suffix []byte) bool</a></li>
<li><a href="#Index">func Index(s, sep []byte) int</a></li>
<li><a href="#IndexAny">func IndexAny(s []byte, chars string) int</a></li>
<li><a href="#IndexByte">func IndexByte(b []byte, c byte) int</a></li>
<li><a href="#IndexFunc">func IndexFunc(s []byte, f func(r rune) bool) int</a></li>
<li><a href="#IndexRune">func IndexRune(s []byte, r rune) int</a></li>
<li><a href="#Join">func Join(s [][]byte, sep []byte) []byte</a></li>
<li><a href="#LastIndex">func LastIndex(s, sep []byte) int</a></li>
<li><a href="#LastIndexAny">func LastIndexAny(s []byte, chars string) int</a></li>
<li><a href="#LastIndexByte">func LastIndexByte(s []byte, c byte) int</a></li>
<li><a href="#LastIndexFunc">func LastIndexFunc(s []byte, f func(r rune) bool) int</a></li>
<li><a href="#Map">func Map(mapping func(r rune) rune, s []byte) []byte</a></li>
<li><a href="#Repeat">func Repeat(b []byte, count int) []byte</a></li>
<li><a href="#Replace">func Replace(s, old, new []byte, n int) []byte</a></li>
<li><a href="#Runes">func Runes(s []byte) []rune</a></li>
<li><a href="#Split">func Split(s, sep []byte) [][]byte</a></li>
<li><a href="#SplitAfter">func SplitAfter(s, sep []byte) [][]byte</a></li>
<li><a href="#SplitAfterN">func SplitAfterN(s, sep []byte, n int) [][]byte</a></li>
<li><a href="#SplitN">func SplitN(s, sep []byte, n int) [][]byte</a></li>
<li><a href="#Title">func Title(s []byte) []byte</a></li>
<li><a href="#ToLower">func ToLower(s []byte) []byte</a></li>
<li><a href="#ToLowerSpecial">func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte</a></li>
<li><a href="#ToTitle">func ToTitle(s []byte) []byte</a></li>
<li><a href="#ToTitleSpecial">func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte</a></li>
<li><a href="#ToUpper">func ToUpper(s []byte) []byte</a></li>
<li><a href="#ToUpperSpecial">func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte</a></li>
<li><a href="#Trim">func Trim(s []byte, cutset string) []byte</a></li>
<li><a href="#TrimFunc">func TrimFunc(s []byte, f func(r rune) bool) []byte</a></li>
<li><a href="#TrimLeft">func TrimLeft(s []byte, cutset string) []byte</a></li>
<li><a href="#TrimLeftFunc">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</a></li>
<li><a href="#TrimPrefix">func TrimPrefix(s, prefix []byte) []byte</a></li>
<li><a href="#TrimRight">func TrimRight(s []byte, cutset string) []byte</a></li>
<li><a href="#TrimRightFunc">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</a></li>
<li><a href="#TrimSpace">func TrimSpace(s []byte) []byte</a></li>
<li><a href="#TrimSuffix">func TrimSuffix(s, suffix []byte) []byte</a></li>
<li><a href="#Buffer">type Buffer</a></li>
<li> <a href="#NewBuffer">func NewBuffer(buf []byte) *Buffer</a>
</li>
<li> <a href="#NewBufferString">func NewBufferString(s string) *Buffer</a>
</li>
<li> <a href="#Buffer.Bytes">func (b *Buffer) Bytes() []byte</a>
</li>
<li> <a href="#Buffer.Cap">func (b *Buffer) Cap() int</a>
</li>
<li> <a href="#Buffer.Grow">func (b *Buffer) Grow(n int)</a>
</li>
<li> <a href="#Buffer.Len">func (b *Buffer) Len() int</a>
</li>
<li> <a href="#Buffer.Next">func (b *Buffer) Next(n int) []byte</a>
</li>
<li> <a href="#Buffer.Read">func (b *Buffer) Read(p []byte) (n int, err error)</a>
</li>
<li> <a href="#Buffer.ReadByte">func (b *Buffer) ReadByte() (byte, error)</a>
</li>
<li> <a href="#Buffer.ReadBytes">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</a>
</li>
<li> <a href="#Buffer.ReadFrom">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</a>
</li>
<li> <a href="#Buffer.ReadRune">func (b *Buffer) ReadRune() (r rune, size int, err error)</a>
</li>
<li> <a href="#Buffer.ReadString">func (b *Buffer) ReadString(delim byte) (line string, err error)</a>
</li>
<li> <a href="#Buffer.Reset">func (b *Buffer) Reset()</a>
</li>
<li> <a href="#Buffer.String">func (b *Buffer) String() string</a>
</li>
<li> <a href="#Buffer.Truncate">func (b *Buffer) Truncate(n int)</a>
</li>
<li> <a href="#Buffer.UnreadByte">func (b *Buffer) UnreadByte() error</a>
</li>
<li> <a href="#Buffer.UnreadRune">func (b *Buffer) UnreadRune() error</a>
</li>
<li> <a href="#Buffer.Write">func (b *Buffer) Write(p []byte) (n int, err error)</a>
</li>
<li> <a href="#Buffer.WriteByte">func (b *Buffer) WriteByte(c byte) error</a>
</li>
<li> <a href="#Buffer.WriteRune">func (b *Buffer) WriteRune(r rune) (n int, err error)</a>
</li>
<li> <a href="#Buffer.WriteString">func (b *Buffer) WriteString(s string) (n int, err error)</a>
</li>
<li> <a href="#Buffer.WriteTo">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</a>
</li>
<li><a href="#Reader">type Reader</a></li>
<li> <a href="#NewReader">func NewReader(b []byte) *Reader</a>
</li>
<li> <a href="#Reader.Len">func (r *Reader) Len() int</a>
</li>
<li> <a href="#Reader.Read">func (r *Reader) Read(b []byte) (n int, err error)</a>
</li>
<li> <a href="#Reader.ReadAt">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</a>
</li>
<li> <a href="#Reader.ReadByte">func (r *Reader) ReadByte() (byte, error)</a>
</li>
<li> <a href="#Reader.ReadRune">func (r *Reader) ReadRune() (ch rune, size int, err error)</a>
</li>
<li> <a href="#Reader.Reset">func (r *Reader) Reset(b []byte)</a>
</li>
<li> <a href="#Reader.Seek">func (r *Reader) Seek(offset int64, whence int) (int64, error)</a>
</li>
<li> <a href="#Reader.Size">func (r *Reader) Size() int64</a>
</li>
<li> <a href="#Reader.UnreadByte">func (r *Reader) UnreadByte() error</a>
</li>
<li> <a href="#Reader.UnreadRune">func (r *Reader) UnreadRune() error</a>
</li>
<li> <a href="#Reader.WriteTo">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</a>
</li>
<li><a href="#pkg-note-BUG">Bugs</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Buffer">Buffer</a></dd> <dd><a class="exampleLink" href="#example_Buffer_Grow">Buffer.Grow</a></dd> <dd><a class="exampleLink" href="#example_Buffer_reader">Buffer (Reader)</a></dd> <dd><a class="exampleLink" href="#example_Compare">Compare</a></dd> <dd><a class="exampleLink" href="#example_Compare_search">Compare (Search)</a></dd> <dd><a class="exampleLink" href="#example_Contains">Contains</a></dd> <dd><a class="exampleLink" href="#example_ContainsAny">ContainsAny</a></dd> <dd><a class="exampleLink" href="#example_ContainsRune">ContainsRune</a></dd> <dd><a class="exampleLink" href="#example_Count">Count</a></dd> <dd><a class="exampleLink" href="#example_Equal">Equal</a></dd> <dd><a class="exampleLink" href="#example_EqualFold">EqualFold</a></dd> <dd><a class="exampleLink" href="#example_Fields">Fields</a></dd> <dd><a class="exampleLink" href="#example_FieldsFunc">FieldsFunc</a></dd> <dd><a class="exampleLink" href="#example_HasPrefix">HasPrefix</a></dd> <dd><a class="exampleLink" href="#example_HasSuffix">HasSuffix</a></dd> <dd><a class="exampleLink" href="#example_Index">Index</a></dd> <dd><a class="exampleLink" href="#example_IndexAny">IndexAny</a></dd> <dd><a class="exampleLink" href="#example_IndexByte">IndexByte</a></dd> <dd><a class="exampleLink" href="#example_IndexFunc">IndexFunc</a></dd> <dd><a class="exampleLink" href="#example_IndexRune">IndexRune</a></dd> <dd><a class="exampleLink" href="#example_Join">Join</a></dd> <dd><a class="exampleLink" href="#example_LastIndex">LastIndex</a></dd> <dd><a class="exampleLink" href="#example_LastIndexAny">LastIndexAny</a></dd> <dd><a class="exampleLink" href="#example_LastIndexByte">LastIndexByte</a></dd> <dd><a class="exampleLink" href="#example_LastIndexFunc">LastIndexFunc</a></dd> <dd><a class="exampleLink" href="#example_Map">Map</a></dd> <dd><a class="exampleLink" href="#example_Reader_Len">Reader.Len</a></dd> <dd><a class="exampleLink" href="#example_Repeat">Repeat</a></dd> <dd><a class="exampleLink" href="#example_Replace">Replace</a></dd> <dd><a class="exampleLink" href="#example_Runes">Runes</a></dd> <dd><a class="exampleLink" href="#example_Split">Split</a></dd> <dd><a class="exampleLink" href="#example_SplitAfter">SplitAfter</a></dd> <dd><a class="exampleLink" href="#example_SplitAfterN">SplitAfterN</a></dd> <dd><a class="exampleLink" href="#example_SplitN">SplitN</a></dd> <dd><a class="exampleLink" href="#example_Title">Title</a></dd> <dd><a class="exampleLink" href="#example_ToLower">ToLower</a></dd> <dd><a class="exampleLink" href="#example_ToTitle">ToTitle</a></dd> <dd><a class="exampleLink" href="#example_ToUpper">ToUpper</a></dd> <dd><a class="exampleLink" href="#example_Trim">Trim</a></dd> <dd><a class="exampleLink" href="#example_TrimFunc">TrimFunc</a></dd> <dd><a class="exampleLink" href="#example_TrimLeft">TrimLeft</a></dd> <dd><a class="exampleLink" href="#example_TrimLeftFunc">TrimLeftFunc</a></dd> <dd><a class="exampleLink" href="#example_TrimPrefix">TrimPrefix</a></dd> <dd><a class="exampleLink" href="#example_TrimRight">TrimRight</a></dd> <dd><a class="exampleLink" href="#example_TrimRightFunc">TrimRightFunc</a></dd> <dd><a class="exampleLink" href="#example_TrimSpace">TrimSpace</a></dd> <dd><a class="exampleLink" href="#example_TrimSuffix">TrimSuffix</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/bytes/buffer.go" target="_blank">buffer.go</a> <a href="https://golang.org/src/bytes/bytes.go" target="_blank">bytes.go</a> <a href="https://golang.org/src/bytes/bytes_decl.go" target="_blank">bytes_decl.go</a> <a href="https://golang.org/src/bytes/reader.go" target="_blank">reader.go</a>  </p>   <h2 id="pkg-constants">Constants</h2> <p> MinRead is the minimum slice size passed to a Read call by Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond what is required to hold the contents of r, ReadFrom will not grow the underlying buffer. </p> <pre data-language="go">const MinRead = 512</pre> <h2 id="pkg-variables">Variables</h2> <p> ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer. </p> <pre data-language="go">var ErrTooLarge = errors.New("bytes.Buffer: too large")</pre> <h2 id="Compare">func Compare<a href="https://golang.org/src/bytes/bytes_decl.go?s=774:803#L14" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Compare(a, b []byte) int</pre> <p> Compare returns an integer comparing two byte slices lexicographically. The result will be 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b. A nil argument is equivalent to an empty slice. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
)

func main() {
	// Interpret Compare's result by comparing it to zero.
	var a, b []byte
	if bytes.Compare(a, b) &lt; 0 {
		// a less b
	}
	if bytes.Compare(a, b) &lt;= 0 {
		// a less or equal b
	}
	if bytes.Compare(a, b) &gt; 0 {
		// a greater b
	}
	if bytes.Compare(a, b) &gt;= 0 {
		// a greater or equal b
	}

	// Prefer Equal to Compare for equality comparisons.
	if bytes.Equal(a, b) {
		// a equal b
	}
	if !bytes.Equal(a, b) {
		// a not equal b
	}
}
</pre>      <h4> <span class="text">Example (Search)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"sort"
)

func main() {
	// Binary search to find a matching byte slice.
	var needle []byte
	var haystack [][]byte // Assume sorted
	i := sort.Search(len(haystack), func(i int) bool {
		// Return haystack[i] &gt;= needle.
		return bytes.Compare(haystack[i], needle) &gt;= 0
	})
	if i &lt; len(haystack) &amp;&amp; bytes.Equal(haystack[i], needle) {
		// Found it!
	}
}
</pre>   <h2 id="Contains">func Contains<a href="https://golang.org/src/bytes/bytes.go?s=1488:1526#L62" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Contains(b, subslice []byte) bool</pre> <p> Contains reports whether subslice is within b. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.Contains([]byte("seafood"), []byte("foo")))
	fmt.Println(bytes.Contains([]byte("seafood"), []byte("bar")))
	fmt.Println(bytes.Contains([]byte("seafood"), []byte("")))
	fmt.Println(bytes.Contains([]byte(""), []byte("")))
}
</pre>   <h2 id="ContainsAny">func ContainsAny<a href="https://golang.org/src/bytes/bytes.go?s=1656:1701#L67" class="source" target="_blank">Source</a>  <span title="Added in Go 1.7">1.7</span> </h2> <pre data-language="go">func ContainsAny(b []byte, chars string) bool</pre> <p> ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.ContainsAny([]byte("I like seafood."), "fÄo!"))
	fmt.Println(bytes.ContainsAny([]byte("I like seafood."), "去是伟大的."))
	fmt.Println(bytes.ContainsAny([]byte("I like seafood."), ""))
	fmt.Println(bytes.ContainsAny([]byte(""), ""))
}
</pre>   <h2 id="ContainsRune">func ContainsRune<a href="https://golang.org/src/bytes/bytes.go?s=1828:1868#L72" class="source" target="_blank">Source</a>  <span title="Added in Go 1.7">1.7</span> </h2> <pre data-language="go">func ContainsRune(b []byte, r rune) bool</pre> <p> ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.ContainsRune([]byte("I like seafood."), 'f'))
	fmt.Println(bytes.ContainsRune([]byte("I like seafood."), 'ö'))
	fmt.Println(bytes.ContainsRune([]byte("去是伟大的!"), '大'))
	fmt.Println(bytes.ContainsRune([]byte("去是伟大的!"), '!'))
	fmt.Println(bytes.ContainsRune([]byte(""), '@'))
}
</pre>   <h2 id="Count">func Count<a href="https://golang.org/src/bytes/bytes.go?s=1178:1207#L42" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Count(s, sep []byte) int</pre> <p> Count counts the number of non-overlapping instances of sep in s. If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.Count([]byte("cheese"), []byte("e")))
	fmt.Println(bytes.Count([]byte("five"), []byte(""))) // before &amp; after each rune
}
</pre>   <h2 id="Equal">func Equal<a href="https://golang.org/src/bytes/bytes_decl.go?s=517:545#L7" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Equal(a, b []byte) bool</pre> <p> Equal returns a boolean reporting whether a and b are the same length and contain the same bytes. A nil argument is equivalent to an empty slice. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.Equal([]byte("Go"), []byte("Go")))
	fmt.Println(bytes.Equal([]byte("Go"), []byte("C++")))
}
</pre>   <h2 id="EqualFold">func EqualFold<a href="https://golang.org/src/bytes/bytes.go?s=21120:21152#L769" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func EqualFold(s, t []byte) bool</pre> <p> EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under Unicode case-folding. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.EqualFold([]byte("Go"), []byte("go")))
}
</pre>   <h2 id="Fields">func Fields<a href="https://golang.org/src/bytes/bytes.go?s=7156:7186#L273" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Fields(s []byte) [][]byte</pre> <p> Fields interprets s as a sequence of UTF-8-encoded code points. It splits the slice s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning a slice of subslices of s or an empty slice if s contains only white space. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("Fields are: %q", bytes.Fields([]byte("  foo bar  baz   ")))
}
</pre>   <h2 id="FieldsFunc">func FieldsFunc<a href="https://golang.org/src/bytes/bytes.go?s=8616:8669#L329" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</pre> <p> FieldsFunc interprets s as a sequence of UTF-8-encoded code points. It splits the slice s at each run of code points c satisfying f(c) and returns a slice of subslices of s. If all code points in s satisfy f(c), or len(s) == 0, an empty slice is returned. FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
	"unicode"
)

func main() {
	f := func(c rune) bool {
		return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)
	}
	fmt.Printf("Fields are: %q", bytes.FieldsFunc([]byte("  foo1;bar2,baz3..."), f))
}
</pre>   <h2 id="HasPrefix">func HasPrefix<a href="https://golang.org/src/bytes/bytes.go?s=10136:10173#L400" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func HasPrefix(s, prefix []byte) bool</pre> <p> HasPrefix tests whether the byte slice s begins with prefix. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.HasPrefix([]byte("Gopher"), []byte("Go")))
	fmt.Println(bytes.HasPrefix([]byte("Gopher"), []byte("C")))
	fmt.Println(bytes.HasPrefix([]byte("Gopher"), []byte("")))
}
</pre>   <h2 id="HasSuffix">func HasSuffix<a href="https://golang.org/src/bytes/bytes.go?s=10306:10343#L405" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func HasSuffix(s, suffix []byte) bool</pre> <p> HasSuffix tests whether the byte slice s ends with suffix. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("go")))
	fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("O")))
	fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("Ami")))
	fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("")))
}
</pre>   <h2 id="Index">func Index<a href="https://golang.org/src/bytes/bytes.go?s=22285:22314#L823" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Index(s, sep []byte) int</pre> <p> Index returns the index of the first instance of sep in s, or -1 if sep is not present in s. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.Index([]byte("chicken"), []byte("ken")))
	fmt.Println(bytes.Index([]byte("chicken"), []byte("dmr")))
}
</pre>   <h2 id="IndexAny">func IndexAny<a href="https://golang.org/src/bytes/bytes.go?s=3526:3567#L141" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IndexAny(s []byte, chars string) int</pre> <p> IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.IndexAny([]byte("chicken"), "aeiouy"))
	fmt.Println(bytes.IndexAny([]byte("crwth"), "aeiouy"))
}
</pre>   <h2 id="IndexByte">func IndexByte<a href="https://golang.org/src/bytes/bytes_decl.go?s=286:322#L1" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IndexByte(b []byte, c byte) int</pre> <p> IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.IndexByte([]byte("chicken"), byte('k')))
	fmt.Println(bytes.IndexByte([]byte("chicken"), byte('g')))
}
</pre>   <h2 id="IndexFunc">func IndexFunc<a href="https://golang.org/src/bytes/bytes.go?s=16395:16444#L593" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IndexFunc(s []byte, f func(r rune) bool) int</pre> <p> IndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
	"unicode"
)

func main() {
	f := func(c rune) bool {
		return unicode.Is(unicode.Han, c)
	}
	fmt.Println(bytes.IndexFunc([]byte("Hello, 世界"), f))
	fmt.Println(bytes.IndexFunc([]byte("Hello, world"), f))
}
</pre>   <h2 id="IndexRune">func IndexRune<a href="https://golang.org/src/bytes/bytes.go?s=2854:2890#L115" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IndexRune(s []byte, r rune) int</pre> <p> IndexRune interprets s as a sequence of UTF-8-encoded code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.IndexRune([]byte("chicken"), 'k'))
	fmt.Println(bytes.IndexRune([]byte("chicken"), 'd'))
}
</pre>   <h2 id="Join">func Join<a href="https://golang.org/src/bytes/bytes.go?s=9699:9739#L377" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Join(s [][]byte, sep []byte) []byte</pre> <p> Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	s := [][]byte{[]byte("foo"), []byte("bar"), []byte("baz")}
	fmt.Printf("%s", bytes.Join(s, []byte(", ")))
}
</pre>   <h2 id="LastIndex">func LastIndex<a href="https://golang.org/src/bytes/bytes.go?s=2119:2152#L86" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LastIndex(s, sep []byte) int</pre> <p> LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.Index([]byte("go gopher"), []byte("go")))
	fmt.Println(bytes.LastIndex([]byte("go gopher"), []byte("go")))
	fmt.Println(bytes.LastIndex([]byte("go gopher"), []byte("rodent")))
}
</pre>   <h2 id="LastIndexAny">func LastIndexAny<a href="https://golang.org/src/bytes/bytes.go?s=4300:4345#L177" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LastIndexAny(s []byte, chars string) int</pre> <p> LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.LastIndexAny([]byte("go gopher"), "MüQp"))
	fmt.Println(bytes.LastIndexAny([]byte("go 地鼠"), "地大"))
	fmt.Println(bytes.LastIndexAny([]byte("go gopher"), "z,!."))
}
</pre>   <h2 id="LastIndexByte">func LastIndexByte<a href="https://golang.org/src/bytes/bytes.go?s=2436:2476#L101" class="source" target="_blank">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func LastIndexByte(s []byte, c byte) int</pre> <p> LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.LastIndexByte([]byte("go gopher"), byte('g')))
	fmt.Println(bytes.LastIndexByte([]byte("go gopher"), byte('r')))
	fmt.Println(bytes.LastIndexByte([]byte("go gopher"), byte('z')))
}
</pre>   <h2 id="LastIndexFunc">func LastIndexFunc<a href="https://golang.org/src/bytes/bytes.go?s=16657:16710#L600" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LastIndexFunc(s []byte, f func(r rune) bool) int</pre> <p> LastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
	"unicode"
)

func main() {
	fmt.Println(bytes.LastIndexFunc([]byte("go gopher!"), unicode.IsLetter))
	fmt.Println(bytes.LastIndexFunc([]byte("go gopher!"), unicode.IsPunct))
	fmt.Println(bytes.LastIndexFunc([]byte("go gopher!"), unicode.IsNumber))
}
</pre>   <h2 id="Map">func Map<a href="https://golang.org/src/bytes/bytes.go?s=10723:10775#L413" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Map(mapping func(r rune) rune, s []byte) []byte</pre> <p> Map returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the byte slice with no replacement. The characters in s and the output are interpreted as UTF-8-encoded code points. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	rot13 := func(r rune) rune {
		switch {
		case r &gt;= 'A' &amp;&amp; r &lt;= 'Z':
			return 'A' + (r-'A'+13)%26
		case r &gt;= 'a' &amp;&amp; r &lt;= 'z':
			return 'a' + (r-'a'+13)%26
		}
		return r
	}
	fmt.Printf("%s", bytes.Map(rot13, []byte("'Twas brillig and the slithy gopher...")))
}
</pre>   <h2 id="Repeat">func Repeat<a href="https://golang.org/src/bytes/bytes.go?s=11734:11773#L450" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Repeat(b []byte, count int) []byte</pre> <p> Repeat returns a new byte slice consisting of count copies of b. </p> <p> It panics if count is negative or if the result of (len(b) * count) overflows. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("ba%s", bytes.Repeat([]byte("na"), 2))
}
</pre>   <h2 id="Replace">func Replace<a href="https://golang.org/src/bytes/bytes.go?s=20363:20409#L731" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Replace(s, old, new []byte, n int) []byte</pre> <p> Replace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. If n &lt; 0, there is no limit on the number of replacements. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("%s\n", bytes.Replace([]byte("oink oink oink"), []byte("k"), []byte("ky"), 2))
	fmt.Printf("%s\n", bytes.Replace([]byte("oink oink oink"), []byte("oink"), []byte("moo"), -1))
}
</pre>   <h2 id="Runes">func Runes<a href="https://golang.org/src/bytes/bytes.go?s=19872:19899#L713" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Runes(s []byte) []rune</pre> <p> Runes interprets s as a sequence of UTF-8-encoded code points. It returns a slice of runes (Unicode code points) equivalent to s. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	rs := bytes.Runes([]byte("go gopher"))
	for _, r := range rs {
		fmt.Printf("%#U\n", r)
	}
}
</pre>   <h2 id="Split">func Split<a href="https://golang.org/src/bytes/bytes.go?s=6400:6434#L257" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Split(s, sep []byte) [][]byte</pre> <p> Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("%q\n", bytes.Split([]byte("a,b,c"), []byte(",")))
	fmt.Printf("%q\n", bytes.Split([]byte("a man a plan a canal panama"), []byte("a ")))
	fmt.Printf("%q\n", bytes.Split([]byte(" xyz "), []byte("")))
	fmt.Printf("%q\n", bytes.Split([]byte(""), []byte("Bernardo O'Higgins")))
}
</pre>   <h2 id="SplitAfter">func SplitAfter<a href="https://golang.org/src/bytes/bytes.go?s=6703:6742#L263" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SplitAfter(s, sep []byte) [][]byte</pre> <p> SplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("%q\n", bytes.SplitAfter([]byte("a,b,c"), []byte(",")))
}
</pre>   <h2 id="SplitAfterN">func SplitAfterN<a href="https://golang.org/src/bytes/bytes.go?s=6079:6126#L249" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SplitAfterN(s, sep []byte, n int) [][]byte</pre> <p> SplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return: </p> <pre data-language="go">n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder.
n == 0: the result is nil (zero subslices)
n &lt; 0: all subslices
</pre>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("%q\n", bytes.SplitAfterN([]byte("a,b,c"), []byte(","), 2))
}
</pre>   <h2 id="SplitN">func SplitN<a href="https://golang.org/src/bytes/bytes.go?s=5611:5653#L240" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SplitN(s, sep []byte, n int) [][]byte</pre> <p> SplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return: </p> <pre data-language="go">n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder.
n == 0: the result is nil (zero subslices)
n &lt; 0: all subslices
</pre>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("%q\n", bytes.SplitN([]byte("a,b,c"), []byte(","), 2))
	z := bytes.SplitN([]byte("a,b,c"), []byte(","), 0)
	fmt.Printf("%q (nil = %v)\n", z, z == nil)
}
</pre>   <h2 id="Title">func Title<a href="https://golang.org/src/bytes/bytes.go?s=14556:14583#L526" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Title(s []byte) []byte</pre> <p> Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case. </p> <p> BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("%s", bytes.Title([]byte("her royal highness")))
}
</pre>   <h2 id="ToLower">func ToLower<a href="https://golang.org/src/bytes/bytes.go?s=12529:12558#L474" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToLower(s []byte) []byte</pre> <p> ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("%s", bytes.ToLower([]byte("Gopher")))
}
</pre>   <h2 id="ToLowerSpecial">func ToLowerSpecial<a href="https://golang.org/src/bytes/bytes.go?s=13251:13310#L487" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte</pre> <p> ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules. </p> <h2 id="ToTitle">func ToTitle<a href="https://golang.org/src/bytes/bytes.go?s=12714:12743#L477" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToTitle(s []byte) []byte</pre> <p> ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("%s\n", bytes.ToTitle([]byte("loud noises")))
	fmt.Printf("%s\n", bytes.ToTitle([]byte("хлеб")))
}
</pre>   <h2 id="ToTitleSpecial">func ToTitleSpecial<a href="https://golang.org/src/bytes/bytes.go?s=13548:13607#L493" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte</pre> <p> ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules. </p> <h2 id="ToUpper">func ToUpper<a href="https://golang.org/src/bytes/bytes.go?s=12344:12373#L471" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToUpper(s []byte) []byte</pre> <p> ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("%s", bytes.ToUpper([]byte("Gopher")))
}
</pre>   <h2 id="ToUpperSpecial">func ToUpperSpecial<a href="https://golang.org/src/bytes/bytes.go?s=12954:13013#L481" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte</pre> <p> ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules. </p> <h2 id="Trim">func Trim<a href="https://golang.org/src/bytes/bytes.go?s=19018:19059#L689" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Trim(s []byte, cutset string) []byte</pre> <p> Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("[%q]", bytes.Trim([]byte(" !!! Achtung! Achtung! !!! "), "! "))
}
</pre>   <h2 id="TrimFunc">func TrimFunc<a href="https://golang.org/src/bytes/bytes.go?s=15635:15686#L568" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimFunc(s []byte, f func(r rune) bool) []byte</pre> <p> TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c). </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
	"unicode"
)

func main() {
	fmt.Println(string(bytes.TrimFunc([]byte("go-gopher!"), unicode.IsLetter)))
	fmt.Println(string(bytes.TrimFunc([]byte("\"go-gopher!\""), unicode.IsLetter)))
	fmt.Println(string(bytes.TrimFunc([]byte("go-gopher!"), unicode.IsPunct)))
	fmt.Println(string(bytes.TrimFunc([]byte("1234go-gopher!567"), unicode.IsNumber)))
}
</pre>   <h2 id="TrimLeft">func TrimLeft<a href="https://golang.org/src/bytes/bytes.go?s=19222:19267#L695" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimLeft(s []byte, cutset string) []byte</pre> <p> TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Print(string(bytes.TrimLeft([]byte("453gopher8257"), "0123456789")))
}
</pre>   <h2 id="TrimLeftFunc">func TrimLeftFunc<a href="https://golang.org/src/bytes/bytes.go?s=15043:15098#L545" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</pre> <p> TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c). </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
	"unicode"
)

func main() {
	fmt.Println(string(bytes.TrimLeftFunc([]byte("go-gopher"), unicode.IsLetter)))
	fmt.Println(string(bytes.TrimLeftFunc([]byte("go-gopher!"), unicode.IsPunct)))
	fmt.Println(string(bytes.TrimLeftFunc([]byte("1234go-gopher!567"), unicode.IsNumber)))
}
</pre>   <h2 id="TrimPrefix">func TrimPrefix<a href="https://golang.org/src/bytes/bytes.go?s=15865:15905#L574" class="source" target="_blank">Source</a>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func TrimPrefix(s, prefix []byte) []byte</pre> <p> TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	var b = []byte("Goodbye,, world!")
	b = bytes.TrimPrefix(b, []byte("Goodbye,"))
	b = bytes.TrimPrefix(b, []byte("See ya,"))
	fmt.Printf("Hello%s", b)
}
</pre>   <h2 id="TrimRight">func TrimRight<a href="https://golang.org/src/bytes/bytes.go?s=19445:19491#L701" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimRight(s []byte, cutset string) []byte</pre> <p> TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Print(string(bytes.TrimRight([]byte("453gopher8257"), "0123456789")))
}
</pre>   <h2 id="TrimRightFunc">func TrimRightFunc<a href="https://golang.org/src/bytes/bytes.go?s=15296:15352#L555" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</pre> <p> TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c). </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
	"unicode"
)

func main() {
	fmt.Println(string(bytes.TrimRightFunc([]byte("go-gopher"), unicode.IsLetter)))
	fmt.Println(string(bytes.TrimRightFunc([]byte("go-gopher!"), unicode.IsPunct)))
	fmt.Println(string(bytes.TrimRightFunc([]byte("1234go-gopher!567"), unicode.IsNumber)))
}
</pre>   <h2 id="TrimSpace">func TrimSpace<a href="https://golang.org/src/bytes/bytes.go?s=19662:19693#L707" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TrimSpace(s []byte) []byte</pre> <p> TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Printf("%s", bytes.TrimSpace([]byte(" \t\n a lone gopher \n\t\r\n")))
}
</pre>   <h2 id="TrimSuffix">func TrimSuffix<a href="https://golang.org/src/bytes/bytes.go?s=16103:16143#L583" class="source" target="_blank">Source</a>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func TrimSuffix(s, suffix []byte) []byte</pre> <p> TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"os"
)

func main() {
	var b = []byte("Hello, goodbye, etc!")
	b = bytes.TrimSuffix(b, []byte("goodbye, etc!"))
	b = bytes.TrimSuffix(b, []byte("gopher"))
	b = append(b, bytes.TrimSuffix([]byte("world!"), []byte("x!"))...)
	os.Stdout.Write(b)
}
</pre>   <h2 id="Buffer">type Buffer<a href="https://golang.org/src/bytes/buffer.go?s=402:817#L7" class="source" target="_blank">Source</a>  </h2> <p> A Buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use. </p> <pre data-language="go">type Buffer struct {
        // contains filtered or unexported fields
}
</pre>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
	"os"
)

func main() {
	var b bytes.Buffer // A Buffer needs no initialization.
	b.Write([]byte("Hello "))
	fmt.Fprintf(&amp;b, "world!")
	b.WriteTo(os.Stdout)
}
</pre>      <h4> <span class="text">Example (Reader)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"encoding/base64"
	"io"
	"os"
)

func main() {
	// A Buffer can turn a string or a []byte into an io.Reader.
	buf := bytes.NewBufferString("R29waGVycyBydWxlIQ==")
	dec := base64.NewDecoder(base64.StdEncoding, buf)
	io.Copy(os.Stdout, dec)
}
</pre>   <h3 id="NewBuffer">func NewBuffer<a href="https://golang.org/src/bytes/buffer.go?s=14358:14392#L440" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func NewBuffer(buf []byte) *Buffer</pre> <p> NewBuffer creates and initializes a new Buffer using buf as its initial contents. The new Buffer takes ownership of buf, and the caller should not use buf after this call. NewBuffer is intended to prepare a Buffer to read existing data. It can also be used to size the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero. </p> <p> In most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer. </p> <h3 id="NewBufferString">func NewBufferString<a href="https://golang.org/src/bytes/buffer.go?s=14700:14738#L448" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func NewBufferString(s string) *Buffer</pre> <p> NewBufferString creates and initializes a new Buffer using string s as its initial contents. It is intended to prepare a buffer to read an existing string. </p> <p> In most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer. </p> <h3 id="Buffer.Bytes">func (*Buffer) Bytes<a href="https://golang.org/src/bytes/buffer.go?s=2218:2249#L45" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) Bytes() []byte</pre> <p> Bytes returns a slice of length b.Len() holding the unread portion of the buffer. The slice is valid for use only until the next buffer modification (that is, only until the next call to a method like Read, Write, Reset, or Truncate). The slice aliases the buffer content at least until the next buffer modification, so immediate changes to the slice will affect the result of future reads. </p> <h3 id="Buffer.Cap">func (*Buffer) Cap<a href="https://golang.org/src/bytes/buffer.go?s=3043:3069#L68" class="source" target="_blank">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (b *Buffer) Cap() int</pre> <p> Cap returns the capacity of the buffer's underlying byte slice, that is, the total space allocated for the buffer's data. </p> <h3 id="Buffer.Grow">func (*Buffer) Grow<a href="https://golang.org/src/bytes/buffer.go?s=5434:5462#L149" class="source" target="_blank">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (b *Buffer) Grow(n int)</pre> <p> Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with ErrTooLarge. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	var b bytes.Buffer
	b.Grow(64)
	bb := b.Bytes()
	b.Write([]byte("64 bytes or fewer"))
	fmt.Printf("%q", bb[:b.Len()])
}
</pre>   <h3 id="Buffer.Len">func (*Buffer) Len<a href="https://golang.org/src/bytes/buffer.go?s=2857:2883#L64" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) Len() int</pre> <p> Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()). </p> <h3 id="Buffer.Next">func (*Buffer) Next<a href="https://golang.org/src/bytes/buffer.go?s=10184:10219#L310" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) Next(n int) []byte</pre> <p> Next returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by Read. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method. </p> <h3 id="Buffer.Read">func (*Buffer) Read<a href="https://golang.org/src/bytes/buffer.go?s=9584:9634#L288" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) Read(p []byte) (n int, err error)</pre> <p> Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is io.EOF (unless len(p) is zero); otherwise it is nil. </p> <h3 id="Buffer.ReadByte">func (*Buffer) ReadByte<a href="https://golang.org/src/bytes/buffer.go?s=10494:10535#L326" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) ReadByte() (byte, error)</pre> <p> ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error io.EOF. </p> <h3 id="Buffer.ReadBytes">func (*Buffer) ReadBytes<a href="https://golang.org/src/bytes/buffer.go?s=12761:12824#L398" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</pre> <p> ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. </p> <h3 id="Buffer.ReadFrom">func (*Buffer) ReadFrom<a href="https://golang.org/src/bytes/buffer.go?s=6926:6985#L191" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</pre> <p> ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with ErrTooLarge. </p> <h3 id="Buffer.ReadRune">func (*Buffer) ReadRune<a href="https://golang.org/src/bytes/buffer.go?s=10949:11006#L343" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) ReadRune() (r rune, size int, err error)</pre> <p> ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1. </p> <h3 id="Buffer.ReadString">func (*Buffer) ReadString<a href="https://golang.org/src/bytes/buffer.go?s=13728:13792#L426" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) ReadString(delim byte) (line string, err error)</pre> <p> ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. </p> <h3 id="Buffer.Reset">func (*Buffer) Reset<a href="https://golang.org/src/bytes/buffer.go?s=3634:3658#L88" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) Reset()</pre> <p> Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as Truncate(0). </p> <h3 id="Buffer.String">func (*Buffer) String<a href="https://golang.org/src/bytes/buffer.go?s=2482:2514#L51" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) String() string</pre> <p> String returns the contents of the unread portion of the buffer as a string. If the Buffer is a nil pointer, it returns "&lt;nil&gt;". </p> <p> To build strings more efficiently, see the strings.Builder type. </p> <h3 id="Buffer.Truncate">func (*Buffer) Truncate<a href="https://golang.org/src/bytes/buffer.go?s=3287:3319#L73" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) Truncate(n int)</pre> <p> Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer. </p> <h3 id="Buffer.UnreadByte">func (*Buffer) UnreadByte<a href="https://golang.org/src/bytes/buffer.go?s=12146:12181#L381" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) UnreadByte() error</pre> <p> UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error. </p> <h3 id="Buffer.UnreadRune">func (*Buffer) UnreadRune<a href="https://golang.org/src/bytes/buffer.go?s=11607:11642#L366" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) UnreadRune() error</pre> <p> UnreadRune unreads the last rune returned by ReadRune. If the most recent read or write operation on the buffer was not a successful ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.) </p> <h3 id="Buffer.Write">func (*Buffer) Write<a href="https://golang.org/src/bytes/buffer.go?s=5775:5826#L160" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) Write(p []byte) (n int, err error)</pre> <p> Write appends the contents of p to the buffer, growing the buffer as needed. The return value n is the length of p; err is always nil. If the buffer becomes too large, Write will panic with ErrTooLarge. </p> <h3 id="Buffer.WriteByte">func (*Buffer) WriteByte<a href="https://golang.org/src/bytes/buffer.go?s=8586:8626#L255" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) WriteByte(c byte) error</pre> <p> WriteByte appends the byte c to the buffer, growing the buffer as needed. The returned error is always nil, but is included to match bufio.Writer's WriteByte. If the buffer becomes too large, WriteByte will panic with ErrTooLarge. </p> <h3 id="Buffer.WriteRune">func (*Buffer) WriteRune<a href="https://golang.org/src/bytes/buffer.go?s=9032:9085#L269" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) WriteRune(r rune) (n int, err error)</pre> <p> WriteRune appends the UTF-8 encoding of Unicode code point r to the buffer, returning its length and an error, which is always nil but is included to match bufio.Writer's WriteRune. The buffer is grown as needed; if it becomes too large, WriteRune will panic with ErrTooLarge. </p> <h3 id="Buffer.WriteString">func (*Buffer) WriteString<a href="https://golang.org/src/bytes/buffer.go?s=6183:6240#L172" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) WriteString(s string) (n int, err error)</pre> <p> WriteString appends the contents of s to the buffer, growing the buffer as needed. The return value n is the length of s; err is always nil. If the buffer becomes too large, WriteString will panic with ErrTooLarge. </p> <h3 id="Buffer.WriteTo">func (*Buffer) WriteTo<a href="https://golang.org/src/bytes/buffer.go?s=7844:7902#L228" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</pre> <p> WriteTo writes data to w until the buffer is drained or an error occurs. The return value n is the number of bytes written; it always fits into an int, but it is int64 to match the io.WriterTo interface. Any error encountered during the write is also returned. </p> <h2 id="Reader">type Reader<a href="https://golang.org/src/bytes/reader.go?s=440:570#L7" class="source" target="_blank">Source</a>  </h2> <p> A Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker, io.ByteScanner, and io.RuneScanner interfaces by reading from a byte slice. Unlike a Buffer, a Reader is read-only and supports seeking. </p> <pre data-language="go">type Reader struct {
        // contains filtered or unexported fields
}
</pre> <h3 id="NewReader">func NewReader<a href="https://golang.org/src/bytes/reader.go?s=3718:3750#L146" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func NewReader(b []byte) *Reader</pre> <p> NewReader returns a new Reader reading from b. </p> <h3 id="Reader.Len">func (*Reader) Len<a href="https://golang.org/src/bytes/reader.go?s=646:672#L15" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) Len() int</pre> <p> Len returns the number of bytes of the unread portion of the slice. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
)

func main() {
	fmt.Println(bytes.NewReader([]byte("Hi!")).Len())
	fmt.Println(bytes.NewReader([]byte("こんにちは!")).Len())
}
</pre>   <h3 id="Reader.Read">func (*Reader) Read<a href="https://golang.org/src/bytes/reader.go?s=1083:1133#L29" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) Read(b []byte) (n int, err error)</pre> <p> Read implements the io.Reader interface. </p> <h3 id="Reader.ReadAt">func (*Reader) ReadAt<a href="https://golang.org/src/bytes/reader.go?s=1304:1367#L40" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</pre> <p> ReadAt implements the io.ReaderAt interface. </p> <h3 id="Reader.ReadByte">func (*Reader) ReadByte<a href="https://golang.org/src/bytes/reader.go?s=1665:1706#L56" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) ReadByte() (byte, error)</pre> <p> ReadByte implements the io.ByteReader interface. </p> <h3 id="Reader.ReadRune">func (*Reader) ReadRune<a href="https://golang.org/src/bytes/reader.go?s=2115:2173#L77" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) ReadRune() (ch rune, size int, err error)</pre> <p> ReadRune implements the io.RuneReader interface. </p> <h3 id="Reader.Reset">func (*Reader) Reset<a href="https://golang.org/src/bytes/reader.go?s=3608:3640#L143" class="source" target="_blank">Source</a>  <span title="Added in Go 1.7">1.7</span> </h3> <pre data-language="go">func (r *Reader) Reset(b []byte)</pre> <p> Reset resets the Reader to be reading from b. </p> <h3 id="Reader.Seek">func (*Reader) Seek<a href="https://golang.org/src/bytes/reader.go?s=2744:2806#L103" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) Seek(offset int64, whence int) (int64, error)</pre> <p> Seek implements the io.Seeker interface. </p> <h3 id="Reader.Size">func (*Reader) Size<a href="https://golang.org/src/bytes/reader.go?s=981:1010#L26" class="source" target="_blank">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (r *Reader) Size() int64</pre> <p> Size returns the original length of the underlying byte slice. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method. </p> <h3 id="Reader.UnreadByte">func (*Reader) UnreadByte<a href="https://golang.org/src/bytes/reader.go?s=1898:1933#L67" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) UnreadByte() error</pre> <p> UnreadByte complements ReadByte in implementing the io.ByteScanner interface. </p> <h3 id="Reader.UnreadRune">func (*Reader) UnreadRune<a href="https://golang.org/src/bytes/reader.go?s=2497:2532#L93" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Reader) UnreadRune() error</pre> <p> UnreadRune complements ReadRune in implementing the io.RuneScanner interface. </p> <h3 id="Reader.WriteTo">func (*Reader) WriteTo<a href="https://golang.org/src/bytes/reader.go?s=3220:3278#L124" class="source" target="_blank">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</pre> <p> WriteTo implements the io.WriterTo interface. </p> <h2 id="pkg-note-BUG">Bugs</h2> <ul> <li>
<a href="https://golang.org/src/bytes/bytes.go?s=14457:14555#L525" style="float: left;" target="_blank">☞</a> <p> The rule Title uses for word boundaries does not handle Unicode punctuation properly. </p> </li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/bytes/" class="_attribution-link" target="_blank">https://golang.org/pkg/bytes/</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
