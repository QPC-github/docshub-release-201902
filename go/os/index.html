
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Os - Go - W3cubDocs</title>
  
  <meta name="description" content="Package os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go- &hellip;">
  <meta name="keywords" content="package, os, -, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/go/os/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _go">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1> Package os  </h1>     <ul id="short-nav">
<li><code>import "os"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
<li><a href="#pkg-subdirectories">Subdirectories</a></li>
</ul>     <h2>Overview </h2> <p> Package os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go-like; failing calls return values of type error rather than error numbers. Often, more information is available within the error. For example, if a call that takes a file name fails, such as Open or Stat, the error will include the failing file name when printed and will be of type *PathError, which may be unpacked for more information. </p> <p> The os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall. </p> <p> Here is a simple example, opening a file and reading some of it. </p> <pre data-language="go">file, err := os.Open("file.go") // For read access.
if err != nil {
	log.Fatal(err)
}
</pre> <p> If the open fails, the error string will be self-explanatory, like </p> <pre data-language="go">open file.go: no such file or directory
</pre> <p> The file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice. </p> <pre data-language="go">data := make([]byte, 100)
count, err := file.Read(data)
if err != nil {
	log.Fatal(err)
}
fmt.Printf("read %d bytes: %q\n", count, data[:count])
</pre>      <h2>Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#Chdir">func Chdir(dir string) error</a></li>
<li><a href="#Chmod">func Chmod(name string, mode FileMode) error</a></li>
<li><a href="#Chown">func Chown(name string, uid, gid int) error</a></li>
<li><a href="#Chtimes">func Chtimes(name string, atime time.Time, mtime time.Time) error</a></li>
<li><a href="#Clearenv">func Clearenv()</a></li>
<li><a href="#Environ">func Environ() []string</a></li>
<li><a href="#Executable">func Executable() (string, error)</a></li>
<li><a href="#Exit">func Exit(code int)</a></li>
<li><a href="#Expand">func Expand(s string, mapping func(string) string) string</a></li>
<li><a href="#ExpandEnv">func ExpandEnv(s string) string</a></li>
<li><a href="#Getegid">func Getegid() int</a></li>
<li><a href="#Getenv">func Getenv(key string) string</a></li>
<li><a href="#Geteuid">func Geteuid() int</a></li>
<li><a href="#Getgid">func Getgid() int</a></li>
<li><a href="#Getgroups">func Getgroups() ([]int, error)</a></li>
<li><a href="#Getpagesize">func Getpagesize() int</a></li>
<li><a href="#Getpid">func Getpid() int</a></li>
<li><a href="#Getppid">func Getppid() int</a></li>
<li><a href="#Getuid">func Getuid() int</a></li>
<li><a href="#Getwd">func Getwd() (dir string, err error)</a></li>
<li><a href="#Hostname">func Hostname() (name string, err error)</a></li>
<li><a href="#IsExist">func IsExist(err error) bool</a></li>
<li><a href="#IsNotExist">func IsNotExist(err error) bool</a></li>
<li><a href="#IsPathSeparator">func IsPathSeparator(c uint8) bool</a></li>
<li><a href="#IsPermission">func IsPermission(err error) bool</a></li>
<li><a href="#IsTimeout">func IsTimeout(err error) bool</a></li>
<li><a href="#Lchown">func Lchown(name string, uid, gid int) error</a></li>
<li><a href="#Link">func Link(oldname, newname string) error</a></li>
<li><a href="#LookupEnv">func LookupEnv(key string) (string, bool)</a></li>
<li><a href="#Mkdir">func Mkdir(name string, perm FileMode) error</a></li>
<li><a href="#MkdirAll">func MkdirAll(path string, perm FileMode) error</a></li>
<li><a href="#NewSyscallError">func NewSyscallError(syscall string, err error) error</a></li>
<li><a href="#Pipe">func Pipe() (r *File, w *File, err error)</a></li>
<li><a href="#Readlink">func Readlink(name string) (string, error)</a></li>
<li><a href="#Remove">func Remove(name string) error</a></li>
<li><a href="#RemoveAll">func RemoveAll(path string) error</a></li>
<li><a href="#Rename">func Rename(oldpath, newpath string) error</a></li>
<li><a href="#SameFile">func SameFile(fi1, fi2 FileInfo) bool</a></li>
<li><a href="#Setenv">func Setenv(key, value string) error</a></li>
<li><a href="#Symlink">func Symlink(oldname, newname string) error</a></li>
<li><a href="#TempDir">func TempDir() string</a></li>
<li><a href="#Truncate">func Truncate(name string, size int64) error</a></li>
<li><a href="#Unsetenv">func Unsetenv(key string) error</a></li>
<li><a href="#UserCacheDir">func UserCacheDir() (string, error)</a></li>
<li><a href="#File">type File</a></li>
<li> <a href="#Create">func Create(name string) (*File, error)</a>
</li>
<li> <a href="#NewFile">func NewFile(fd uintptr, name string) *File</a>
</li>
<li> <a href="#Open">func Open(name string) (*File, error)</a>
</li>
<li> <a href="#OpenFile">func OpenFile(name string, flag int, perm FileMode) (*File, error)</a>
</li>
<li> <a href="#File.Chdir">func (f *File) Chdir() error</a>
</li>
<li> <a href="#File.Chmod">func (f *File) Chmod(mode FileMode) error</a>
</li>
<li> <a href="#File.Chown">func (f *File) Chown(uid, gid int) error</a>
</li>
<li> <a href="#File.Close">func (f *File) Close() error</a>
</li>
<li> <a href="#File.Fd">func (f *File) Fd() uintptr</a>
</li>
<li> <a href="#File.Name">func (f *File) Name() string</a>
</li>
<li> <a href="#File.Read">func (f *File) Read(b []byte) (n int, err error)</a>
</li>
<li> <a href="#File.ReadAt">func (f *File) ReadAt(b []byte, off int64) (n int, err error)</a>
</li>
<li> <a href="#File.Readdir">func (f *File) Readdir(n int) ([]FileInfo, error)</a>
</li>
<li> <a href="#File.Readdirnames">func (f *File) Readdirnames(n int) (names []string, err error)</a>
</li>
<li> <a href="#File.Seek">func (f *File) Seek(offset int64, whence int) (ret int64, err error)</a>
</li>
<li> <a href="#File.SetDeadline">func (f *File) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#File.SetReadDeadline">func (f *File) SetReadDeadline(t time.Time) error</a>
</li>
<li> <a href="#File.SetWriteDeadline">func (f *File) SetWriteDeadline(t time.Time) error</a>
</li>
<li> <a href="#File.Stat">func (f *File) Stat() (FileInfo, error)</a>
</li>
<li> <a href="#File.Sync">func (f *File) Sync() error</a>
</li>
<li> <a href="#File.Truncate">func (f *File) Truncate(size int64) error</a>
</li>
<li> <a href="#File.Write">func (f *File) Write(b []byte) (n int, err error)</a>
</li>
<li> <a href="#File.WriteAt">func (f *File) WriteAt(b []byte, off int64) (n int, err error)</a>
</li>
<li> <a href="#File.WriteString">func (f *File) WriteString(s string) (n int, err error)</a>
</li>
<li><a href="#FileInfo">type FileInfo</a></li>
<li> <a href="#Lstat">func Lstat(name string) (FileInfo, error)</a>
</li>
<li> <a href="#Stat">func Stat(name string) (FileInfo, error)</a>
</li>
<li><a href="#FileMode">type FileMode</a></li>
<li> <a href="#FileMode.IsDir">func (m FileMode) IsDir() bool</a>
</li>
<li> <a href="#FileMode.IsRegular">func (m FileMode) IsRegular() bool</a>
</li>
<li> <a href="#FileMode.Perm">func (m FileMode) Perm() FileMode</a>
</li>
<li> <a href="#FileMode.String">func (m FileMode) String() string</a>
</li>
<li><a href="#LinkError">type LinkError</a></li>
<li> <a href="#LinkError.Error">func (e *LinkError) Error() string</a>
</li>
<li><a href="#PathError">type PathError</a></li>
<li> <a href="#PathError.Error">func (e *PathError) Error() string</a>
</li>
<li> <a href="#PathError.Timeout">func (e *PathError) Timeout() bool</a>
</li>
<li><a href="#ProcAttr">type ProcAttr</a></li>
<li><a href="#Process">type Process</a></li>
<li> <a href="#FindProcess">func FindProcess(pid int) (*Process, error)</a>
</li>
<li> <a href="#StartProcess">func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</a>
</li>
<li> <a href="#Process.Kill">func (p *Process) Kill() error</a>
</li>
<li> <a href="#Process.Release">func (p *Process) Release() error</a>
</li>
<li> <a href="#Process.Signal">func (p *Process) Signal(sig Signal) error</a>
</li>
<li> <a href="#Process.Wait">func (p *Process) Wait() (*ProcessState, error)</a>
</li>
<li><a href="#ProcessState">type ProcessState</a></li>
<li> <a href="#ProcessState.Exited">func (p *ProcessState) Exited() bool</a>
</li>
<li> <a href="#ProcessState.Pid">func (p *ProcessState) Pid() int</a>
</li>
<li> <a href="#ProcessState.String">func (p *ProcessState) String() string</a>
</li>
<li> <a href="#ProcessState.Success">func (p *ProcessState) Success() bool</a>
</li>
<li> <a href="#ProcessState.Sys">func (p *ProcessState) Sys() interface{}</a>
</li>
<li> <a href="#ProcessState.SysUsage">func (p *ProcessState) SysUsage() interface{}</a>
</li>
<li> <a href="#ProcessState.SystemTime">func (p *ProcessState) SystemTime() time.Duration</a>
</li>
<li> <a href="#ProcessState.UserTime">func (p *ProcessState) UserTime() time.Duration</a>
</li>
<li><a href="#Signal">type Signal</a></li>
<li><a href="#SyscallError">type SyscallError</a></li>
<li> <a href="#SyscallError.Error">func (e *SyscallError) Error() string</a>
</li>
<li> <a href="#SyscallError.Timeout">func (e *SyscallError) Timeout() bool</a>
</li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Chmod">Chmod</a></dd> <dd><a class="exampleLink" href="#example_Chtimes">Chtimes</a></dd> <dd><a class="exampleLink" href="#example_Expand">Expand</a></dd> <dd><a class="exampleLink" href="#example_ExpandEnv">ExpandEnv</a></dd> <dd><a class="exampleLink" href="#example_FileMode">FileMode</a></dd> <dd><a class="exampleLink" href="#example_Getenv">Getenv</a></dd> <dd><a class="exampleLink" href="#example_IsNotExist">IsNotExist</a></dd> <dd><a class="exampleLink" href="#example_LookupEnv">LookupEnv</a></dd> <dd><a class="exampleLink" href="#example_OpenFile">OpenFile</a></dd> <dd><a class="exampleLink" href="#example_OpenFile_append">OpenFile (Append)</a></dd> <dd><a class="exampleLink" href="#example_Unsetenv">Unsetenv</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/os/dir.go" target="_blank">dir.go</a> <a href="https://golang.org/src/os/dir_unix.go" target="_blank">dir_unix.go</a> <a href="https://golang.org/src/os/env.go" target="_blank">env.go</a> <a href="https://golang.org/src/os/error.go" target="_blank">error.go</a> <a href="https://golang.org/src/os/error_posix.go" target="_blank">error_posix.go</a> <a href="https://golang.org/src/os/error_unix.go" target="_blank">error_unix.go</a> <a href="https://golang.org/src/os/exec.go" target="_blank">exec.go</a> <a href="https://golang.org/src/os/exec_posix.go" target="_blank">exec_posix.go</a> <a href="https://golang.org/src/os/exec_unix.go" target="_blank">exec_unix.go</a> <a href="https://golang.org/src/os/executable.go" target="_blank">executable.go</a> <a href="https://golang.org/src/os/executable_procfs.go" target="_blank">executable_procfs.go</a> <a href="https://golang.org/src/os/file.go" target="_blank">file.go</a> <a href="https://golang.org/src/os/file_posix.go" target="_blank">file_posix.go</a> <a href="https://golang.org/src/os/file_unix.go" target="_blank">file_unix.go</a> <a href="https://golang.org/src/os/getwd.go" target="_blank">getwd.go</a> <a href="https://golang.org/src/os/path.go" target="_blank">path.go</a> <a href="https://golang.org/src/os/path_unix.go" target="_blank">path_unix.go</a> <a href="https://golang.org/src/os/pipe_linux.go" target="_blank">pipe_linux.go</a> <a href="https://golang.org/src/os/proc.go" target="_blank">proc.go</a> <a href="https://golang.org/src/os/stat.go" target="_blank">stat.go</a> <a href="https://golang.org/src/os/stat_linux.go" target="_blank">stat_linux.go</a> <a href="https://golang.org/src/os/stat_unix.go" target="_blank">stat_unix.go</a> <a href="https://golang.org/src/os/sticky_notbsd.go" target="_blank">sticky_notbsd.go</a> <a href="https://golang.org/src/os/str.go" target="_blank">str.go</a> <a href="https://golang.org/src/os/sys.go" target="_blank">sys.go</a> <a href="https://golang.org/src/os/sys_linux.go" target="_blank">sys_linux.go</a> <a href="https://golang.org/src/os/sys_unix.go" target="_blank">sys_unix.go</a> <a href="https://golang.org/src/os/types.go" target="_blank">types.go</a> <a href="https://golang.org/src/os/types_unix.go" target="_blank">types_unix.go</a> <a href="https://golang.org/src/os/wait_waitid.go" target="_blank">wait_waitid.go</a>  </p>   <h2 id="pkg-constants">Constants</h2> <p> Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. </p> <pre data-language="go">const (
        // Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.
        O_RDONLY int = syscall.O_RDONLY // open the file read-only.
        O_WRONLY int = syscall.O_WRONLY // open the file write-only.
        O_RDWR   int = syscall.O_RDWR   // open the file read-write.
        // The remaining values may be or'ed in to control behavior.
        O_APPEND int = syscall.O_APPEND // append data to the file when writing.
        O_CREATE int = syscall.O_CREAT  // create a new file if none exists.
        O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.
        O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.
        O_TRUNC  int = syscall.O_TRUNC  // if possible, truncate file when opened.
)</pre> <p> Seek whence values. </p> <p> Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd. </p> <pre data-language="go">const (
        SEEK_SET int = 0 // seek relative to the origin of the file
        SEEK_CUR int = 1 // seek relative to the current offset
        SEEK_END int = 2 // seek relative to the end
)</pre> <pre data-language="go">const (
        PathSeparator     = '/' // OS-specific path separator
        PathListSeparator = ':' // OS-specific path list separator
)</pre> <p> DevNull is the name of the operating system's “null device.” On Unix-like systems, it is "/dev/null"; on Windows, "NUL". </p> <pre data-language="go">const DevNull = "/dev/null"</pre> <h2 id="pkg-variables">Variables</h2> <p> Portable analogs of some common system call errors. </p> <pre data-language="go">var (
        ErrInvalid    = errors.New("invalid argument") // methods on File will return this error when the receiver is nil
        ErrPermission = errors.New("permission denied")
        ErrExist      = errors.New("file already exists")
        ErrNotExist   = errors.New("file does not exist")
        ErrClosed     = errors.New("file already closed")
        ErrNoDeadline = poll.ErrNoDeadline
)</pre> <p> Stdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors. </p> <p> Note that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later. </p> <pre data-language="go">var (
        Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
        Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
        Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
)</pre> <p> Args hold the command-line arguments, starting with the program name. </p> <pre data-language="go">var Args []string</pre> <h2 id="Chdir">func Chdir<a href="https://golang.org/src/os/file.go?s=7167:7195#L236" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Chdir(dir string) error</pre> <p> Chdir changes the current working directory to the named directory. If there is an error, it will be of type *PathError. </p> <h2 id="Chmod">func Chmod<a href="https://golang.org/src/os/file.go?s=12159:12203#L392" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Chmod(name string, mode FileMode) error</pre> <p> Chmod changes the mode of the named file to mode. If the file is a symbolic link, it changes the mode of the link's target. If there is an error, it will be of type *PathError. </p> <p> A different subset of the mode bits are used, depending on the operating system. </p> <p> On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and ModeSticky are used. </p> <p> On Windows, the mode must be non-zero but otherwise only the 0200 bit (owner writable) of mode is used; it controls whether the file's read-only attribute is set or cleared. attribute. The other bits are currently unused. Use mode 0400 for a read-only file and 0600 for a readable+writable file. </p> <p> On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive, and ModeTemporary are used. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"log"
	"os"
)

func main() {
	if err := os.Chmod("some-filename", 0644); err != nil {
		log.Fatal(err)
	}
}
</pre>   <h2 id="Chown">func Chown<a href="https://golang.org/src/os/file_posix.go?s=1921:1964#L63" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Chown(name string, uid, gid int) error</pre> <p> Chown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link's target. A uid or gid of -1 means to not change that value. If there is an error, it will be of type *PathError. </p> <p> On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or EPLAN9 error, wrapped in *PathError. </p> <h2 id="Chtimes">func Chtimes<a href="https://golang.org/src/os/file_posix.go?s=3891:3956#L130" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Chtimes(name string, atime time.Time, mtime time.Time) error</pre> <p> Chtimes changes the access and modification times of the named file, similar to the Unix utime() or utimes() functions. </p> <p> The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"log"
	"os"
	"time"
)

func main() {
	mtime := time.Date(2006, time.February, 1, 3, 4, 5, 0, time.UTC)
	atime := time.Date(2007, time.March, 2, 4, 5, 6, 0, time.UTC)
	if err := os.Chtimes("some-filename", atime, mtime); err != nil {
		log.Fatal(err)
	}
}
</pre>   <h2 id="Clearenv">func Clearenv<a href="https://golang.org/src/os/env.go?s=3747:3762#L123" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Clearenv()</pre> <p> Clearenv deletes all environment variables. </p> <h2 id="Environ">func Environ<a href="https://golang.org/src/os/env.go?s=3883:3906#L129" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Environ() []string</pre> <p> Environ returns a copy of strings representing the environment, in the form "key=value". </p> <h2 id="Executable">func Executable<a href="https://golang.org/src/os/executable.go?s=758:791#L10" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h2> <pre data-language="go">func Executable() (string, error)</pre> <p> Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, path/filepath.EvalSymlinks might help. </p> <p> Executable returns an absolute path unless an error occurred. </p> <p> The main use case is finding resources located relative to an executable. </p> <p> Executable is not supported on nacl. </p> <h2 id="Exit">func Exit<a href="https://golang.org/src/os/proc.go?s=1559:1578#L49" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Exit(code int)</pre> <p> Exit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run. </p> <h2 id="Expand">func Expand<a href="https://golang.org/src/os/env.go?s=403:460#L6" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Expand(s string, mapping func(string) string) string</pre> <p> Expand replaces ${var} or $var in the string based on the mapping function. For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv). </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"os"
)

func main() {
	mapper := func(placeholderName string) string {
		switch placeholderName {
		case "DAY_PART":
			return "morning"
		case "USER":
			return "Gopher"
		}

		return ""
	}

	fmt.Println(os.Expand("Good ${DAY_PART}, $USER!", mapper))

}
</pre>   <h2 id="ExpandEnv">func ExpandEnv<a href="https://golang.org/src/os/env.go?s=1321:1352#L40" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ExpandEnv(s string) string</pre> <p> ExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"os"
)

func main() {
	fmt.Println(os.ExpandEnv("$USER lives in ${HOME}."))

}
</pre>   <h2 id="Getegid">func Getegid<a href="https://golang.org/src/os/proc.go?s=999:1017#L35" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Getegid() int</pre> <p> Getegid returns the numeric effective group id of the caller. </p> <p> On Windows, it returns -1. </p> <h2 id="Getenv">func Getenv<a href="https://golang.org/src/os/env.go?s=2860:2890#L91" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Getenv(key string) string</pre> <p> Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use LookupEnv. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"os"
)

func main() {
	fmt.Printf("%s lives in %s.\n", os.Getenv("USER"), os.Getenv("HOME"))

}
</pre>   <h2 id="Geteuid">func Geteuid<a href="https://golang.org/src/os/proc.go?s=718:736#L25" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Geteuid() int</pre> <p> Geteuid returns the numeric effective user id of the caller. </p> <p> On Windows, it returns -1. </p> <h2 id="Getgid">func Getgid<a href="https://golang.org/src/os/proc.go?s=854:871#L30" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Getgid() int</pre> <p> Getgid returns the numeric group id of the caller. </p> <p> On Windows, it returns -1. </p> <h2 id="Getgroups">func Getgroups<a href="https://golang.org/src/os/proc.go?s=1235:1266#L41" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Getgroups() ([]int, error)</pre> <p> Getgroups returns a list of the numeric ids of groups that the caller belongs to. </p> <p> On Windows, it returns syscall.EWINDOWS. See the os/user package for a possible alternative. </p> <h2 id="Getpagesize">func Getpagesize<a href="https://golang.org/src/os/types.go?s=268:290#L3" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Getpagesize() int</pre> <p> Getpagesize returns the underlying system's memory page size. </p> <h2 id="Getpid">func Getpid<a href="https://golang.org/src/os/exec.go?s=2156:2173#L61" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Getpid() int</pre> <p> Getpid returns the process id of the caller. </p> <h2 id="Getppid">func Getppid<a href="https://golang.org/src/os/exec.go?s=2261:2279#L64" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Getppid() int</pre> <p> Getppid returns the process id of the caller's parent. </p> <h2 id="Getuid">func Getuid<a href="https://golang.org/src/os/proc.go?s=574:591#L20" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Getuid() int</pre> <p> Getuid returns the numeric user id of the caller. </p> <p> On Windows, it returns -1. </p> <h2 id="Getwd">func Getwd<a href="https://golang.org/src/os/getwd.go?s=620:656#L16" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Getwd() (dir string, err error)</pre> <p> Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them. </p> <h2 id="Hostname">func Hostname<a href="https://golang.org/src/os/sys.go?s=230:270#L1" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Hostname() (name string, err error)</pre> <p> Hostname returns the host name reported by the kernel. </p> <h2 id="IsExist">func IsExist<a href="https://golang.org/src/os/error.go?s=1909:1937#L58" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IsExist(err error) bool</pre> <p> IsExist returns a boolean indicating whether the error is known to report that a file or directory already exists. It is satisfied by ErrExist as well as some syscall errors. </p> <h2 id="IsNotExist">func IsNotExist<a href="https://golang.org/src/os/error.go?s=2154:2185#L65" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IsNotExist(err error) bool</pre> <p> IsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"os"
)

func main() {
	filename := "a-nonexistent-file"
	if _, err := os.Stat(filename); os.IsNotExist(err) {
		fmt.Printf("file does not exist")
	}
}
</pre>   <h2 id="IsPathSeparator">func IsPathSeparator<a href="https://golang.org/src/os/path_unix.go?s=449:483#L5" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IsPathSeparator(c uint8) bool</pre> <p> IsPathSeparator reports whether c is a directory separator character. </p> <h2 id="IsPermission">func IsPermission<a href="https://golang.org/src/os/error.go?s=2395:2428#L72" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IsPermission(err error) bool</pre> <p> IsPermission returns a boolean indicating whether the error is known to report that permission is denied. It is satisfied by ErrPermission as well as some syscall errors. </p> <h2 id="IsTimeout">func IsTimeout<a href="https://golang.org/src/os/error.go?s=2567:2597#L78" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h2> <pre data-language="go">func IsTimeout(err error) bool</pre> <p> IsTimeout returns a boolean indicating whether the error is known to report that a timeout occurred. </p> <h2 id="Lchown">func Lchown<a href="https://golang.org/src/os/file_posix.go?s=2363:2407#L76" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Lchown(name string, uid, gid int) error</pre> <p> Lchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type *PathError. </p> <p> On Windows, it always returns the syscall.EWINDOWS error, wrapped in *PathError. </p> <h2 id="Link">func Link<a href="https://golang.org/src/os/file_unix.go?s=10167:10207#L334" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Link(oldname, newname string) error</pre> <p> Link creates newname as a hard link to the oldname file. If there is an error, it will be of type *LinkError. </p> <h2 id="LookupEnv">func LookupEnv<a href="https://golang.org/src/os/env.go?s=3235:3276#L102" class="source" target="_blank">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func LookupEnv(key string) (string, bool)</pre> <p> LookupEnv retrieves the value of the environment variable named by the key. If the variable is present in the environment the value (which may be empty) is returned and the boolean is true. Otherwise the returned value will be empty and the boolean will be false. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"os"
)

func main() {
	show := func(key string) {
		val, ok := os.LookupEnv(key)
		if !ok {
			fmt.Printf("%s not set\n", key)
		} else {
			fmt.Printf("%s=%s\n", key, val)
		}
	}

	show("USER")
	show("GOPATH")

}
</pre>   <h2 id="Mkdir">func Mkdir<a href="https://golang.org/src/os/file.go?s=6442:6486#L205" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Mkdir(name string, perm FileMode) error</pre> <p> Mkdir creates a new directory with the specified name and permission bits (before umask). If there is an error, it will be of type *PathError. </p> <h2 id="MkdirAll">func MkdirAll<a href="https://golang.org/src/os/path.go?s=503:550#L9" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func MkdirAll(path string, perm FileMode) error</pre> <p> MkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm (before umask) are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil. </p> <h2 id="NewSyscallError">func NewSyscallError<a href="https://golang.org/src/os/error.go?s=1597:1650#L48" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func NewSyscallError(syscall string, err error) error</pre> <p> NewSyscallError returns, as an error, a new SyscallError with the given system call name and error details. As a convenience, if err is nil, NewSyscallError returns nil. </p> <h2 id="Pipe">func Pipe<a href="https://golang.org/src/os/pipe_linux.go?s=319:360#L1" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Pipe() (r *File, w *File, err error)</pre> <p> Pipe returns a connected pair of Files; reads from r return bytes written to w. It returns the files and an error, if any. </p> <h2 id="Readlink">func Readlink<a href="https://golang.org/src/os/file_posix.go?s=459:501#L8" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Readlink(name string) (string, error)</pre> <p> Readlink returns the destination of the named symbolic link. If there is an error, it will be of type *PathError. </p> <h2 id="Remove">func Remove<a href="https://golang.org/src/os/file_unix.go?s=9042:9072#L291" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Remove(name string) error</pre> <p> Remove removes the named file or (empty) directory. If there is an error, it will be of type *PathError. </p> <h2 id="RemoveAll">func RemoveAll<a href="https://golang.org/src/os/path.go?s=1667:1700#L56" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func RemoveAll(path string) error</pre> <p> RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error). </p> <h2 id="Rename">func Rename<a href="https://golang.org/src/os/file.go?s=8906:8948#L284" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Rename(oldpath, newpath string) error</pre> <p> Rename renames (moves) oldpath to newpath. If newpath already exists and is not a directory, Rename replaces it. OS-specific restrictions may apply when oldpath and newpath are in different directories. If there is an error, it will be of type *LinkError. </p> <h2 id="SameFile">func SameFile<a href="https://golang.org/src/os/types.go?s=4096:4133#L107" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SameFile(fi1, fi2 FileInfo) bool</pre> <p> SameFile reports whether fi1 and fi2 describe the same file. For example, on Unix this means that the device and inode fields of the two underlying structures are identical; on other systems the decision may be based on the path names. SameFile only applies to results returned by this package's Stat. It returns false in other cases. </p> <h2 id="Setenv">func Setenv<a href="https://golang.org/src/os/env.go?s=3434:3470#L109" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Setenv(key, value string) error</pre> <p> Setenv sets the value of the environment variable named by the key. It returns an error, if any. </p> <h2 id="Symlink">func Symlink<a href="https://golang.org/src/os/file_unix.go?s=10443:10486#L344" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Symlink(oldname, newname string) error</pre> <p> Symlink creates newname as a symbolic link to oldname. If there is an error, it will be of type *LinkError. </p> <h2 id="TempDir">func TempDir<a href="https://golang.org/src/os/file.go?s=10004:10025#L319" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func TempDir() string</pre> <p> TempDir returns the default directory to use for temporary files. </p> <p> On Unix systems, it returns $TMPDIR if non-empty, else /tmp. On Windows, it uses GetTempPath, returning the first non-empty value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory. On Plan 9, it returns /tmp. </p> <p> The directory is neither guaranteed to exist nor have accessible permissions. </p> <h2 id="Truncate">func Truncate<a href="https://golang.org/src/os/file_unix.go?s=8775:8819#L282" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Truncate(name string, size int64) error</pre> <p> Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError. </p> <h2 id="Unsetenv">func Unsetenv<a href="https://golang.org/src/os/env.go?s=3633:3664#L118" class="source" target="_blank">Source</a>  <span title="Added in Go 1.4">1.4</span> </h2> <pre data-language="go">func Unsetenv(key string) error</pre> <p> Unsetenv unsets a single environment variable. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"os"
)

func main() {
	os.Setenv("TMPDIR", "/my/tmp")
	defer os.Unsetenv("TMPDIR")
}
</pre>   <h2 id="UserCacheDir">func UserCacheDir<a href="https://golang.org/src/os/file.go?s=10659:10694#L336" class="source" target="_blank">Source</a>  <span title="Added in Go 1.11">1.11</span> </h2> <pre data-language="go">func UserCacheDir() (string, error)</pre> <p> UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that. </p> <p> On Unix systems, it returns $XDG_CACHE_HOME as specified by <a href="https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html" target="_blank">https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html</a> if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches. On Windows, it returns %LocalAppData%. On Plan 9, it returns $home/lib/cache. </p> <p> If the location cannot be determined (for example, $HOME is not defined), then it will return an error. </p> <h2 id="File">type File<a href="https://golang.org/src/os/types.go?s=369:411#L6" class="source" target="_blank">Source</a>  </h2> <p> File represents an open file descriptor. </p> <pre data-language="go">type File struct {
        // contains filtered or unexported fields
}
</pre> <h3 id="Create">func Create<a href="https://golang.org/src/os/file.go?s=8039:8078#L263" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Create(name string) (*File, error)</pre> <p> Create creates the named file with mode 0666 (before umask), truncating it if it already exists. If successful, methods on the returned File can be used for I/O; the associated file descriptor has mode O_RDWR. If there is an error, it will be of type *PathError. </p> <h3 id="NewFile">func NewFile<a href="https://golang.org/src/os/file_unix.go?s=2621:2664#L71" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func NewFile(fd uintptr, name string) *File</pre> <p> NewFile returns a new File with the given file descriptor and name. The returned value will be nil if fd is not a valid file descriptor. On Unix systems, if the file descriptor is in non-blocking mode, NewFile will attempt to return a pollable File (one for which the SetDeadline methods work). </p> <h3 id="Open">func Open<a href="https://golang.org/src/os/file.go?s=7682:7719#L254" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Open(name string) (*File, error)</pre> <p> Open opens the named file for reading. If successful, methods on the returned file can be used for reading; the associated file descriptor has mode O_RDONLY. If there is an error, it will be of type *PathError. </p> <h3 id="OpenFile">func OpenFile<a href="https://golang.org/src/os/file.go?s=8454:8520#L272" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func OpenFile(name string, flag int, perm FileMode) (*File, error)</pre> <p> OpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag (O_RDONLY etc.) and perm (before umask), if applicable. If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type *PathError. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"log"
	"os"
)

func main() {
	f, err := os.OpenFile("notes.txt", os.O_RDWR|os.O_CREATE, 0755)
	if err != nil {
		log.Fatal(err)
	}
	if err := f.Close(); err != nil {
		log.Fatal(err)
	}
}
</pre>      <h4> <span class="text">Example (Append)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"log"
	"os"
)

func main() {
	// If the file doesn't exist, create it, or append to the file
	f, err := os.OpenFile("access.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := f.Write([]byte("appended some data\n")); err != nil {
		log.Fatal(err)
	}
	if err := f.Close(); err != nil {
		log.Fatal(err)
	}
}
</pre>   <h3 id="File.Chdir">func (*File) Chdir<a href="https://golang.org/src/os/file_posix.go?s=4374:4402#L143" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Chdir() error</pre> <p> Chdir changes the current working directory to the file, which must be a directory. If there is an error, it will be of type *PathError. </p> <h3 id="File.Chmod">func (*File) Chmod<a href="https://golang.org/src/os/file.go?s=12337:12378#L396" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Chmod(mode FileMode) error</pre> <p> Chmod changes the mode of the file to mode. If there is an error, it will be of type *PathError. </p> <h3 id="File.Chown">func (*File) Chown<a href="https://golang.org/src/os/file_posix.go?s=2725:2765#L88" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Chown(uid, gid int) error</pre> <p> Chown changes the numeric uid and gid of the named file. If there is an error, it will be of type *PathError. </p> <p> On Windows, it always returns the syscall.EWINDOWS error, wrapped in *PathError. </p> <h3 id="File.Close">func (*File) Close<a href="https://golang.org/src/os/file_unix.go?s=6716:6744#L212" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Close() error</pre> <p> Close closes the File, rendering it unusable for I/O. On files that support SetDeadline, any pending I/O operations will be canceled and return immediately with an error. </p> <h3 id="File.Fd">func (*File) Fd<a href="https://golang.org/src/os/file_unix.go?s=1877:1904#L49" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Fd() uintptr</pre> <p> Fd returns the integer Unix file descriptor referencing the open file. The file descriptor is valid only until f.Close is called or f is garbage collected. On Unix systems this will cause the SetDeadline methods to stop working. </p> <h3 id="File.Name">func (*File) Name<a href="https://golang.org/src/os/file.go?s=1597:1625#L40" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Name() string</pre> <p> Name returns the name of the file as presented to Open. </p> <h3 id="File.Read">func (*File) Read<a href="https://golang.org/src/os/file.go?s=3647:3695#L94" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Read(b []byte) (n int, err error)</pre> <p> Read reads up to len(b) bytes from the File. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF. </p> <h3 id="File.ReadAt">func (*File) ReadAt<a href="https://golang.org/src/os/file.go?s=4050:4111#L106" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) ReadAt(b []byte, off int64) (n int, err error)</pre> <p> ReadAt reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n &lt; len(b). At end of file, that error is io.EOF. </p> <h3 id="File.Readdir">func (*File) Readdir<a href="https://golang.org/src/os/dir.go?s=980:1029#L12" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Readdir(n int) ([]FileInfo, error)</pre> <p> Readdir reads the contents of the directory associated with file and returns a slice of up to n FileInfo values, as would be returned by Lstat, in directory order. Subsequent calls on the same file will yield further FileInfos. </p> <p> If n &gt; 0, Readdir returns at most n FileInfo structures. In this case, if Readdir returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF. </p> <p> If n &lt;= 0, Readdir returns all the FileInfo from the directory in a single slice. In this case, if Readdir succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdir returns the FileInfo read until that point and a non-nil error. </p> <h3 id="File.Readdirnames">func (*File) Readdirnames<a href="https://golang.org/src/os/dir.go?s=1745:1807#L31" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Readdirnames(n int) (names []string, err error)</pre> <p> Readdirnames reads and returns a slice of names from the directory f. </p> <p> If n &gt; 0, Readdirnames returns at most n names. In this case, if Readdirnames returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF. </p> <p> If n &lt;= 0, Readdirnames returns all the names from the directory in a single slice. In this case, if Readdirnames succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdirnames returns the names read until that point and a non-nil error. </p> <h3 id="File.Seek">func (*File) Seek<a href="https://golang.org/src/os/file.go?s=5797:5865#L182" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Seek(offset int64, whence int) (ret int64, err error)</pre> <p> Seek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with O_APPEND is not specified. </p> <h3 id="File.SetDeadline">func (*File) SetDeadline<a href="https://golang.org/src/os/file.go?s=13558:13603#L420" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (f *File) SetDeadline(t time.Time) error</pre> <p> SetDeadline sets the read and write deadlines for a File. It is equivalent to calling both SetReadDeadline and SetWriteDeadline. </p> <p> Only some kinds of files support setting a deadline. Calls to SetDeadline for files that do not support deadlines will return ErrNoDeadline. On most systems ordinary files do not support deadlines, but pipes do. </p> <p> A deadline is an absolute time after which I/O operations fail with an error instead of blocking. The deadline applies to all future and pending I/O, not just the immediately following call to Read or Write. After a deadline has been exceeded, the connection can be refreshed by setting a deadline in the future. </p> <p> An error returned after a timeout fails will implement the Timeout method, and calling the Timeout method will return true. The PathError and SyscallError types implement the Timeout method. In general, call IsTimeout to test whether an error indicates a timeout. </p> <p> An idle timeout can be implemented by repeatedly extending the deadline after successful Read or Write calls. </p> <p> A zero value for t means I/O operations will not time out. </p> <h3 id="File.SetReadDeadline">func (*File) SetReadDeadline<a href="https://golang.org/src/os/file.go?s=13846:13895#L428" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (f *File) SetReadDeadline(t time.Time) error</pre> <p> SetReadDeadline sets the deadline for future Read calls and any currently-blocked Read call. A zero value for t means Read will not time out. Not all files support setting deadlines; see SetDeadline. </p> <h3 id="File.SetWriteDeadline">func (*File) SetWriteDeadline<a href="https://golang.org/src/os/file.go?s=14261:14311#L438" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (f *File) SetWriteDeadline(t time.Time) error</pre> <p> SetWriteDeadline sets the deadline for any future Write calls and any currently-blocked Write call. Even if Write times out, it may return n &gt; 0, indicating that some of the data was successfully written. A zero value for t means Write will not time out. Not all files support setting deadlines; see SetDeadline. </p> <h3 id="File.Stat">func (*File) Stat<a href="https://golang.org/src/os/stat_unix.go?s=385:424#L5" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Stat() (FileInfo, error)</pre> <p> Stat returns the FileInfo structure describing file. If there is an error, it will be of type *PathError. </p> <h3 id="File.Sync">func (*File) Sync<a href="https://golang.org/src/os/file_posix.go?s=3437:3464#L114" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Sync() error</pre> <p> Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk. </p> <h3 id="File.Truncate">func (*File) Truncate<a href="https://golang.org/src/os/file_posix.go?s=3060:3101#L101" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Truncate(size int64) error</pre> <p> Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError. </p> <h3 id="File.Write">func (*File) Write<a href="https://golang.org/src/os/file.go?s=4583:4632#L131" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Write(b []byte) (n int, err error)</pre> <p> Write writes len(b) bytes to the File. It returns the number of bytes written and an error, if any. Write returns a non-nil error when n != len(b). </p> <h3 id="File.WriteAt">func (*File) WriteAt<a href="https://golang.org/src/os/file.go?s=5066:5128#L155" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) WriteAt(b []byte, off int64) (n int, err error)</pre> <p> WriteAt writes len(b) bytes to the File starting at byte offset off. It returns the number of bytes written and an error, if any. WriteAt returns a non-nil error when n != len(b). </p> <h3 id="File.WriteString">func (*File) WriteString<a href="https://golang.org/src/os/file.go?s=6202:6257#L198" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) WriteString(s string) (n int, err error)</pre> <p> WriteString is like Write, but writes the contents of string s rather than a slice of bytes. </p> <h2 id="FileInfo">type FileInfo<a href="https://golang.org/src/os/types.go?s=479:840#L11" class="source" target="_blank">Source</a>  </h2> <p> A FileInfo describes a file and is returned by Stat and Lstat. </p> <pre data-language="go">type FileInfo interface {
        Name() string       // base name of the file
        Size() int64        // length in bytes for regular files; system-dependent for others
        Mode() FileMode     // file mode bits
        ModTime() time.Time // modification time
        IsDir() bool        // abbreviation for Mode().IsDir()
        Sys() interface{}   // underlying data source (can return nil)
}</pre> <h3 id="Lstat">func Lstat<a href="https://golang.org/src/os/stat.go?s=642:683#L10" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Lstat(name string) (FileInfo, error)</pre> <p> Lstat returns a FileInfo describing the named file. If the file is a symbolic link, the returned FileInfo describes the symbolic link. Lstat makes no attempt to follow the link. If there is an error, it will be of type *PathError. </p> <h3 id="Stat">func Stat<a href="https://golang.org/src/os/stat.go?s=309:349#L1" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Stat(name string) (FileInfo, error)</pre> <p> Stat returns a FileInfo describing the named file. If there is an error, it will be of type *PathError. </p> <h2 id="FileMode">type FileMode<a href="https://golang.org/src/os/types.go?s=1131:1151#L25" class="source" target="_blank">Source</a>  </h2> <p> A FileMode represents a file's mode and permission bits. The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is ModeDir for directories. </p> <pre data-language="go">type FileMode uint32</pre> <p> The defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. </p> <pre data-language="go">const (
        // The single letters are the abbreviations
        // used by the String method's formatting.
        ModeDir        FileMode = 1 &lt;&lt; (32 - 1 - iota) // d: is a directory
        ModeAppend                                     // a: append-only
        ModeExclusive                                  // l: exclusive use
        ModeTemporary                                  // T: temporary file; Plan 9 only
        ModeSymlink                                    // L: symbolic link
        ModeDevice                                     // D: device file
        ModeNamedPipe                                  // p: named pipe (FIFO)
        ModeSocket                                     // S: Unix domain socket
        ModeSetuid                                     // u: setuid
        ModeSetgid                                     // g: setgid
        ModeCharDevice                                 // c: Unix character device, when ModeDevice is set
        ModeSticky                                     // t: sticky
        ModeIrregular                                  // ?: non-regular file; nothing else is known about this file

        // Mask for the type bits. For regular files, none will be set.
        ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice | ModeIrregular

        ModePerm FileMode = 0777 // Unix permission bits
)</pre>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"log"
	"os"
)

func main() {
	fi, err := os.Lstat("some-filename")
	if err != nil {
		log.Fatal(err)
	}

	switch mode := fi.Mode(); {
	case mode.IsRegular():
		fmt.Println("regular file")
	case mode.IsDir():
		fmt.Println("directory")
	case mode&amp;os.ModeSymlink != 0:
		fmt.Println("symbolic link")
	case mode&amp;os.ModeNamedPipe != 0:
		fmt.Println("named pipe")
	}
}
</pre>   <h3 id="FileMode.IsDir">func (FileMode) IsDir<a href="https://golang.org/src/os/types.go?s=3286:3316#L83" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (m FileMode) IsDir() bool</pre> <p> IsDir reports whether m describes a directory. That is, it tests for the ModeDir bit being set in m. </p> <h3 id="FileMode.IsRegular">func (FileMode) IsRegular<a href="https://golang.org/src/os/types.go?s=3455:3489#L89" class="source" target="_blank">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (m FileMode) IsRegular() bool</pre> <p> IsRegular reports whether m describes a regular file. That is, it tests that no mode type bits are set. </p> <h3 id="FileMode.Perm">func (FileMode) Perm<a href="https://golang.org/src/os/types.go?s=3566:3599#L94" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (m FileMode) Perm() FileMode</pre> <p> Perm returns the Unix permission bits in m. </p> <h3 id="FileMode.String">func (FileMode) String<a href="https://golang.org/src/os/types.go?s=2773:2806#L55" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (m FileMode) String() string</pre> <h2 id="LinkError">type LinkError<a href="https://golang.org/src/os/file.go?s=3312:3384#L80" class="source" target="_blank">Source</a>  </h2> <p> LinkError records an error during a link or symlink or rename system call and the paths that caused it. </p> <pre data-language="go">type LinkError struct {
        Op  string
        Old string
        New string
        Err error
}
</pre> <h3 id="LinkError.Error">func (*LinkError) Error<a href="https://golang.org/src/os/file.go?s=3386:3420#L87" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *LinkError) Error() string</pre> <h2 id="PathError">type PathError<a href="https://golang.org/src/os/error.go?s=750:813#L17" class="source" target="_blank">Source</a>  </h2> <p> PathError records an error and the operation and file path that caused it. </p> <pre data-language="go">type PathError struct {
        Op   string
        Path string
        Err  error
}
</pre> <h3 id="PathError.Error">func (*PathError) Error<a href="https://golang.org/src/os/error.go?s=815:849#L23" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *PathError) Error() string</pre> <h3 id="PathError.Timeout">func (*PathError) Timeout<a href="https://golang.org/src/os/error.go?s=965:999#L26" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (e *PathError) Timeout() bool</pre> <p> Timeout reports whether this error represents a timeout. </p> <h2 id="ProcAttr">type ProcAttr<a href="https://golang.org/src/os/exec.go?s=968:1859#L30" class="source" target="_blank">Source</a>  </h2> <p> ProcAttr holds the attributes that will be applied to a new process started by StartProcess. </p> <pre data-language="go">type ProcAttr struct {
        // If Dir is non-empty, the child changes into the directory before
        // creating the process.
        Dir string
        // If Env is non-nil, it gives the environment variables for the
        // new process in the form returned by Environ.
        // If it is nil, the result of Environ will be used.
        Env []string
        // Files specifies the open files inherited by the new process. The
        // first three entries correspond to standard input, standard output, and
        // standard error. An implementation may support additional entries,
        // depending on the underlying operating system. A nil entry corresponds
        // to that file being closed when the process starts.
        Files []*File

        // Operating system-specific process creation attributes.
        // Note that setting this field means that your program
        // may not execute properly or even compile on some
        // operating systems.
        Sys *syscall.SysProcAttr
}
</pre> <h2 id="Process">type Process<a href="https://golang.org/src/os/exec.go?s=332:573#L7" class="source" target="_blank">Source</a>  </h2> <p> Process stores the information about a process created by StartProcess. </p> <pre data-language="go">type Process struct {
        Pid int
        // contains filtered or unexported fields
}
</pre> <h3 id="FindProcess">func FindProcess<a href="https://golang.org/src/os/exec.go?s=2615:2658#L73" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func FindProcess(pid int) (*Process, error)</pre> <p> FindProcess looks for a running process by its pid. </p> <p> The Process it returns can be used to obtain information about the underlying operating system process. </p> <p> On Unix systems, FindProcess always succeeds and returns a Process for the given pid, regardless of whether the process exists. </p> <h3 id="StartProcess">func StartProcess<a href="https://golang.org/src/os/exec.go?s=3326:3405#L90" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</pre> <p> StartProcess starts a new process with the program, arguments and attributes specified by name, argv and attr. The argv slice will become os.Args in the new process, so it normally starts with the program name. </p> <p> If the calling goroutine has locked the operating system thread with runtime.LockOSThread and modified any inheritable OS-level thread state (for example, Linux or Plan 9 name spaces), the new process will inherit the caller's thread state. </p> <p> StartProcess is a low-level interface. The os/exec package provides higher-level interfaces. </p> <p> If there is an error, it will be of type *PathError. </p> <h3 id="Process.Kill">func (*Process) Kill<a href="https://golang.org/src/os/exec.go?s=3878:3908#L105" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *Process) Kill() error</pre> <p> Kill causes the Process to exit immediately. Kill does not wait until the Process has actually exited. This only kills the Process itself, not any other processes it may have started. </p> <h3 id="Process.Release">func (*Process) Release<a href="https://golang.org/src/os/exec.go?s=3626:3659#L98" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *Process) Release() error</pre> <p> Release releases any resources associated with the Process p, rendering it unusable in the future. Release only needs to be called if Wait is not. </p> <h3 id="Process.Signal">func (*Process) Signal<a href="https://golang.org/src/os/exec.go?s=4386:4428#L120" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *Process) Signal(sig Signal) error</pre> <p> Signal sends a signal to the Process. Sending Interrupt on Windows is not implemented. </p> <h3 id="Process.Wait">func (*Process) Wait<a href="https://golang.org/src/os/exec.go?s=4223:4270#L114" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *Process) Wait() (*ProcessState, error)</pre> <p> Wait waits for the Process to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned. </p> <h2 id="ProcessState">type ProcessState<a href="https://golang.org/src/os/exec_posix.go?s=1580:1740#L48" class="source" target="_blank">Source</a>  </h2> <p> ProcessState stores information about a process, as reported by Wait. </p> <pre data-language="go">type ProcessState struct {
        // contains filtered or unexported fields
}
</pre> <h3 id="ProcessState.Exited">func (*ProcessState) Exited<a href="https://golang.org/src/os/exec.go?s=4818:4854#L135" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *ProcessState) Exited() bool</pre> <p> Exited reports whether the program has exited. </p> <h3 id="ProcessState.Pid">func (*ProcessState) Pid<a href="https://golang.org/src/os/exec_posix.go?s=1795:1827#L55" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *ProcessState) Pid() int</pre> <p> Pid returns the process id of the exited process. </p> <h3 id="ProcessState.String">func (*ProcessState) String<a href="https://golang.org/src/os/exec_posix.go?s=2124:2162#L75" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *ProcessState) String() string</pre> <h3 id="ProcessState.Success">func (*ProcessState) Success<a href="https://golang.org/src/os/exec.go?s=4978:5015#L141" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *ProcessState) Success() bool</pre> <p> Success reports whether the program exited successfully, such as with exit status 0 on Unix. </p> <h3 id="ProcessState.Sys">func (*ProcessState) Sys<a href="https://golang.org/src/os/exec.go?s=5222:5262#L148" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *ProcessState) Sys() interface{}</pre> <p> Sys returns system-dependent exit information about the process. Convert it to the appropriate underlying type, such as syscall.WaitStatus on Unix, to access its contents. </p> <h3 id="ProcessState.SysUsage">func (*ProcessState) SysUsage<a href="https://golang.org/src/os/exec.go?s=5583:5628#L157" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *ProcessState) SysUsage() interface{}</pre> <p> SysUsage returns system-dependent resource usage information about the exited process. Convert it to the appropriate underlying type, such as *syscall.Rusage on Unix, to access its contents. (On Unix, *syscall.Rusage matches struct rusage as defined in the getrusage(2) manual page.) </p> <h3 id="ProcessState.SystemTime">func (*ProcessState) SystemTime<a href="https://golang.org/src/os/exec.go?s=4690:4739#L130" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *ProcessState) SystemTime() time.Duration</pre> <p> SystemTime returns the system CPU time of the exited process and its children. </p> <h3 id="ProcessState.UserTime">func (*ProcessState) UserTime<a href="https://golang.org/src/os/exec.go?s=4534:4581#L125" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (p *ProcessState) UserTime() time.Duration</pre> <p> UserTime returns the user CPU time of the exited process and its children. </p> <h2 id="Signal">type Signal<a href="https://golang.org/src/os/exec.go?s=2015:2106#L55" class="source" target="_blank">Source</a>  </h2> <p> A Signal represents an operating system signal. The usual underlying implementation is operating system-dependent: on Unix it is syscall.Signal. </p> <pre data-language="go">type Signal interface {
        String() string
        Signal() // to distinguish from other Stringers
}</pre> <p> The only signal values guaranteed to be present in the os package on all systems are Interrupt (send the process an interrupt) and Kill (force the process to exit). Interrupt is not implemented on Windows; using it with os.Process.Signal will return an error. </p> <pre data-language="go">var (
        Interrupt Signal = syscall.SIGINT
        Kill      Signal = syscall.SIGKILL
)</pre> <h2 id="SyscallError">type SyscallError<a href="https://golang.org/src/os/error.go?s=1119:1178#L32" class="source" target="_blank">Source</a>  </h2> <p> SyscallError records an error from a specific system call. </p> <pre data-language="go">type SyscallError struct {
        Syscall string
        Err     error
}
</pre> <h3 id="SyscallError.Error">func (*SyscallError) Error<a href="https://golang.org/src/os/error.go?s=1180:1217#L37" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *SyscallError) Error() string</pre> <h3 id="SyscallError.Timeout">func (*SyscallError) Timeout<a href="https://golang.org/src/os/error.go?s=1323:1360#L40" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (e *SyscallError) Timeout() bool</pre> <p> Timeout reports whether this error represents a timeout. </p> <h2 id="pkg-subdirectories">Subdirectories</h2> <div class="pkg-dir"> <table> <tr> <th class="pkg-name">Name</th> <th class="pkg-synopsis">Synopsis</th> </tr> <tr> <td colspan="2"><a href="../">..</a></td> </tr> <tr> <td class="pkg-name"> <a href="exec/">exec</a> </td> <td class="pkg-synopsis"> Package exec runs external commands. </td> </tr> <tr> <td class="pkg-name"> <a href="signal/">signal</a> </td> <td class="pkg-synopsis"> Package signal implements access to incoming signals. </td> </tr> <tr> <td class="pkg-name"> <a href="user/">user</a> </td> <td class="pkg-synopsis"> Package user allows user account lookups by name or id. </td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/os/" class="_attribution-link" target="_blank">https://golang.org/pkg/os/</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
