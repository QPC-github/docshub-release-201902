
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Database&#47;sql - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package sql provides a generic interface around SQL (or SQL-like) databases. ">
  <meta name="keywords" content="package, sql, database, -, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/go/database/sql/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _go">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1> Package sql  </h1>     <ul id="short-nav">
<li><code>import "database/sql"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
<li><a href="#pkg-subdirectories">Subdirectories</a></li>
</ul>     <h2>Overview </h2> <p> Package sql provides a generic interface around SQL (or SQL-like) databases. </p> <p> The sql package must be used in conjunction with a database driver. See <a href="https://golang.org/s/sqldrivers" target="_blank">https://golang.org/s/sqldrivers</a> for a list of drivers. </p> <p> Drivers that do not support context cancelation will not return until after the query is completed. </p> <p> For usage examples, see the wiki page at <a href="https://golang.org/s/sqlwiki" target="_blank">https://golang.org/s/sqlwiki</a>. </p>      <h2>Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#Drivers">func Drivers() []string</a></li>
<li><a href="#Register">func Register(name string, driver driver.Driver)</a></li>
<li><a href="#ColumnType">type ColumnType</a></li>
<li> <a href="#ColumnType.DatabaseTypeName">func (ci *ColumnType) DatabaseTypeName() string</a>
</li>
<li> <a href="#ColumnType.DecimalSize">func (ci *ColumnType) DecimalSize() (precision, scale int64, ok bool)</a>
</li>
<li> <a href="#ColumnType.Length">func (ci *ColumnType) Length() (length int64, ok bool)</a>
</li>
<li> <a href="#ColumnType.Name">func (ci *ColumnType) Name() string</a>
</li>
<li> <a href="#ColumnType.Nullable">func (ci *ColumnType) Nullable() (nullable, ok bool)</a>
</li>
<li> <a href="#ColumnType.ScanType">func (ci *ColumnType) ScanType() reflect.Type</a>
</li>
<li><a href="#Conn">type Conn</a></li>
<li> <a href="#Conn.BeginTx">func (c *Conn) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)</a>
</li>
<li> <a href="#Conn.Close">func (c *Conn) Close() error</a>
</li>
<li> <a href="#Conn.ExecContext">func (c *Conn) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)</a>
</li>
<li> <a href="#Conn.PingContext">func (c *Conn) PingContext(ctx context.Context) error</a>
</li>
<li> <a href="#Conn.PrepareContext">func (c *Conn) PrepareContext(ctx context.Context, query string) (*Stmt, error)</a>
</li>
<li> <a href="#Conn.QueryContext">func (c *Conn) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)</a>
</li>
<li> <a href="#Conn.QueryRowContext">func (c *Conn) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row</a>
</li>
<li><a href="#DB">type DB</a></li>
<li> <a href="#Open">func Open(driverName, dataSourceName string) (*DB, error)</a>
</li>
<li> <a href="#OpenDB">func OpenDB(c driver.Connector) *DB</a>
</li>
<li> <a href="#DB.Begin">func (db *DB) Begin() (*Tx, error)</a>
</li>
<li> <a href="#DB.BeginTx">func (db *DB) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)</a>
</li>
<li> <a href="#DB.Close">func (db *DB) Close() error</a>
</li>
<li> <a href="#DB.Conn">func (db *DB) Conn(ctx context.Context) (*Conn, error)</a>
</li>
<li> <a href="#DB.Driver">func (db *DB) Driver() driver.Driver</a>
</li>
<li> <a href="#DB.Exec">func (db *DB) Exec(query string, args ...interface{}) (Result, error)</a>
</li>
<li> <a href="#DB.ExecContext">func (db *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)</a>
</li>
<li> <a href="#DB.Ping">func (db *DB) Ping() error</a>
</li>
<li> <a href="#DB.PingContext">func (db *DB) PingContext(ctx context.Context) error</a>
</li>
<li> <a href="#DB.Prepare">func (db *DB) Prepare(query string) (*Stmt, error)</a>
</li>
<li> <a href="#DB.PrepareContext">func (db *DB) PrepareContext(ctx context.Context, query string) (*Stmt, error)</a>
</li>
<li> <a href="#DB.Query">func (db *DB) Query(query string, args ...interface{}) (*Rows, error)</a>
</li>
<li> <a href="#DB.QueryContext">func (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)</a>
</li>
<li> <a href="#DB.QueryRow">func (db *DB) QueryRow(query string, args ...interface{}) *Row</a>
</li>
<li> <a href="#DB.QueryRowContext">func (db *DB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row</a>
</li>
<li> <a href="#DB.SetConnMaxLifetime">func (db *DB) SetConnMaxLifetime(d time.Duration)</a>
</li>
<li> <a href="#DB.SetMaxIdleConns">func (db *DB) SetMaxIdleConns(n int)</a>
</li>
<li> <a href="#DB.SetMaxOpenConns">func (db *DB) SetMaxOpenConns(n int)</a>
</li>
<li> <a href="#DB.Stats">func (db *DB) Stats() DBStats</a>
</li>
<li><a href="#DBStats">type DBStats</a></li>
<li><a href="#IsolationLevel">type IsolationLevel</a></li>
<li> <a href="#IsolationLevel.String">func (i IsolationLevel) String() string</a>
</li>
<li><a href="#NamedArg">type NamedArg</a></li>
<li> <a href="#Named">func Named(name string, value interface{}) NamedArg</a>
</li>
<li><a href="#NullBool">type NullBool</a></li>
<li> <a href="#NullBool.Scan">func (n *NullBool) Scan(value interface{}) error</a>
</li>
<li> <a href="#NullBool.Value">func (n NullBool) Value() (driver.Value, error)</a>
</li>
<li><a href="#NullFloat64">type NullFloat64</a></li>
<li> <a href="#NullFloat64.Scan">func (n *NullFloat64) Scan(value interface{}) error</a>
</li>
<li> <a href="#NullFloat64.Value">func (n NullFloat64) Value() (driver.Value, error)</a>
</li>
<li><a href="#NullInt64">type NullInt64</a></li>
<li> <a href="#NullInt64.Scan">func (n *NullInt64) Scan(value interface{}) error</a>
</li>
<li> <a href="#NullInt64.Value">func (n NullInt64) Value() (driver.Value, error)</a>
</li>
<li><a href="#NullString">type NullString</a></li>
<li> <a href="#NullString.Scan">func (ns *NullString) Scan(value interface{}) error</a>
</li>
<li> <a href="#NullString.Value">func (ns NullString) Value() (driver.Value, error)</a>
</li>
<li><a href="#Out">type Out</a></li>
<li><a href="#RawBytes">type RawBytes</a></li>
<li><a href="#Result">type Result</a></li>
<li><a href="#Row">type Row</a></li>
<li> <a href="#Row.Scan">func (r *Row) Scan(dest ...interface{}) error</a>
</li>
<li><a href="#Rows">type Rows</a></li>
<li> <a href="#Rows.Close">func (rs *Rows) Close() error</a>
</li>
<li> <a href="#Rows.ColumnTypes">func (rs *Rows) ColumnTypes() ([]*ColumnType, error)</a>
</li>
<li> <a href="#Rows.Columns">func (rs *Rows) Columns() ([]string, error)</a>
</li>
<li> <a href="#Rows.Err">func (rs *Rows) Err() error</a>
</li>
<li> <a href="#Rows.Next">func (rs *Rows) Next() bool</a>
</li>
<li> <a href="#Rows.NextResultSet">func (rs *Rows) NextResultSet() bool</a>
</li>
<li> <a href="#Rows.Scan">func (rs *Rows) Scan(dest ...interface{}) error</a>
</li>
<li><a href="#Scanner">type Scanner</a></li>
<li><a href="#Stmt">type Stmt</a></li>
<li> <a href="#Stmt.Close">func (s *Stmt) Close() error</a>
</li>
<li> <a href="#Stmt.Exec">func (s *Stmt) Exec(args ...interface{}) (Result, error)</a>
</li>
<li> <a href="#Stmt.ExecContext">func (s *Stmt) ExecContext(ctx context.Context, args ...interface{}) (Result, error)</a>
</li>
<li> <a href="#Stmt.Query">func (s *Stmt) Query(args ...interface{}) (*Rows, error)</a>
</li>
<li> <a href="#Stmt.QueryContext">func (s *Stmt) QueryContext(ctx context.Context, args ...interface{}) (*Rows, error)</a>
</li>
<li> <a href="#Stmt.QueryRow">func (s *Stmt) QueryRow(args ...interface{}) *Row</a>
</li>
<li> <a href="#Stmt.QueryRowContext">func (s *Stmt) QueryRowContext(ctx context.Context, args ...interface{}) *Row</a>
</li>
<li><a href="#Tx">type Tx</a></li>
<li> <a href="#Tx.Commit">func (tx *Tx) Commit() error</a>
</li>
<li> <a href="#Tx.Exec">func (tx *Tx) Exec(query string, args ...interface{}) (Result, error)</a>
</li>
<li> <a href="#Tx.ExecContext">func (tx *Tx) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)</a>
</li>
<li> <a href="#Tx.Prepare">func (tx *Tx) Prepare(query string) (*Stmt, error)</a>
</li>
<li> <a href="#Tx.PrepareContext">func (tx *Tx) PrepareContext(ctx context.Context, query string) (*Stmt, error)</a>
</li>
<li> <a href="#Tx.Query">func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error)</a>
</li>
<li> <a href="#Tx.QueryContext">func (tx *Tx) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)</a>
</li>
<li> <a href="#Tx.QueryRow">func (tx *Tx) QueryRow(query string, args ...interface{}) *Row</a>
</li>
<li> <a href="#Tx.QueryRowContext">func (tx *Tx) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row</a>
</li>
<li> <a href="#Tx.Rollback">func (tx *Tx) Rollback() error</a>
</li>
<li> <a href="#Tx.Stmt">func (tx *Tx) Stmt(stmt *Stmt) *Stmt</a>
</li>
<li> <a href="#Tx.StmtContext">func (tx *Tx) StmtContext(ctx context.Context, stmt *Stmt) *Stmt</a>
</li>
<li><a href="#TxOptions">type TxOptions</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Conn_BeginTx">Conn.BeginTx</a></dd> <dd><a class="exampleLink" href="#example_Conn_ExecContext">Conn.ExecContext</a></dd> <dd><a class="exampleLink" href="#example_DB_ExecContext">DB.ExecContext</a></dd> <dd><a class="exampleLink" href="#example_DB_PingContext">DB.PingContext</a></dd> <dd><a class="exampleLink" href="#example_DB_QueryContext">DB.QueryContext</a></dd> <dd><a class="exampleLink" href="#example_DB_QueryRowContext">DB.QueryRowContext</a></dd> <dd><a class="exampleLink" href="#example_DB_Query_multipleResultSets">DB.Query (MultipleResultSets)</a></dd> <dd><a class="exampleLink" href="#example_Rows">Rows</a></dd> <dd><a class="exampleLink" href="#example_Stmt">Stmt</a></dd> <dd><a class="exampleLink" href="#example_Stmt_QueryRowContext">Stmt.QueryRowContext</a></dd> <dd><a class="exampleLink" href="#example_Tx_ExecContext">Tx.ExecContext</a></dd> <dd><a class="exampleLink" href="#example_Tx_Rollback">Tx.Rollback</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/database/sql/convert.go" target="_blank">convert.go</a> <a href="https://golang.org/src/database/sql/ctxutil.go" target="_blank">ctxutil.go</a> <a href="https://golang.org/src/database/sql/sql.go" target="_blank">sql.go</a>  </p>   <h2 id="pkg-variables">Variables</h2> <p> ErrConnDone is returned by any operation that is performed on a connection that has already been returned to the connection pool. </p> <pre data-language="go">var ErrConnDone = errors.New("sql: connection is already closed")</pre> <p> ErrNoRows is returned by Scan when QueryRow doesn't return a row. In such a case, QueryRow returns a placeholder *Row value that defers this error until a Scan. </p> <pre data-language="go">var ErrNoRows = errors.New("sql: no rows in result set")</pre> <p> ErrTxDone is returned by any operation that is performed on a transaction that has already been committed or rolled back. </p> <pre data-language="go">var ErrTxDone = errors.New("sql: transaction has already been committed or rolled back")</pre> <h2 id="Drivers">func Drivers<a href="https://golang.org/src/database/sql/sql.go?s=1525:1548#L54" class="source" target="_blank">Source</a>  <span title="Added in Go 1.4">1.4</span> </h2> <pre data-language="go">func Drivers() []string</pre> <p> Drivers returns a sorted list of the names of the registered drivers. </p> <h2 id="Register">func Register<a href="https://golang.org/src/database/sql/sql.go?s=1039:1087#L34" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Register(name string, driver driver.Driver)</pre> <p> Register makes a database driver available by the provided name. If Register is called twice with the same name or if driver is nil, it panics. </p> <h2 id="ColumnType">type ColumnType<a href="https://golang.org/src/database/sql/sql.go?s=78403:78643#L2765" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h2> <p> ColumnType contains the name and type of a column. </p> <pre data-language="go">type ColumnType struct {
        // contains filtered or unexported fields
}
</pre> <h3 id="ColumnType.DatabaseTypeName">func (*ColumnType) DatabaseTypeName<a href="https://golang.org/src/database/sql/sql.go?s=80226:80273#L2818" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (ci *ColumnType) DatabaseTypeName() string</pre> <p> DatabaseTypeName returns the database system name of the column type. If an empty string is returned the driver type name is not supported. Consult your driver documentation for a list of driver data types. Length specifiers are not included. Common type include "VARCHAR", "TEXT", "NVARCHAR", "DECIMAL", "BOOL", "INT", "BIGINT". </p> <h3 id="ColumnType.DecimalSize">func (*ColumnType) DecimalSize<a href="https://golang.org/src/database/sql/sql.go?s=79296:79365#L2796" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (ci *ColumnType) DecimalSize() (precision, scale int64, ok bool)</pre> <p> DecimalSize returns the scale and precision of a decimal type. If not applicable or if not supported ok is false. </p> <h3 id="ColumnType.Length">func (*ColumnType) Length<a href="https://golang.org/src/database/sql/sql.go?s=79084:79138#L2790" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (ci *ColumnType) Length() (length int64, ok bool)</pre> <p> Length returns the column type length for variable length column types such as text and binary field types. If the type length is unbounded the value will be math.MaxInt64 (any database limits will still apply). If the column type is not variable length, such as an int, or if not supported by the driver ok is false. </p> <h3 id="ColumnType.Name">func (*ColumnType) Name<a href="https://golang.org/src/database/sql/sql.go?s=78694:78729#L2781" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (ci *ColumnType) Name() string</pre> <p> Name returns the name or alias of the column. </p> <h3 id="ColumnType.Nullable">func (*ColumnType) Nullable<a href="https://golang.org/src/database/sql/sql.go?s=79787:79839#L2809" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (ci *ColumnType) Nullable() (nullable, ok bool)</pre> <p> Nullable returns whether the column may be null. If a driver does not support this property ok will be false. </p> <h3 id="ColumnType.ScanType">func (*ColumnType) ScanType<a href="https://golang.org/src/database/sql/sql.go?s=79600:79645#L2803" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (ci *ColumnType) ScanType() reflect.Type</pre> <p> ScanType returns a Go type suitable for scanning into using Rows.Scan. If a driver does not support this property ScanType will return the type of an empty interface. </p> <h2 id="Conn">type Conn<a href="https://golang.org/src/database/sql/sql.go?s=48129:48616#L1716" class="source" target="_blank">Source</a>  <span title="Added in Go 1.9">1.9</span> </h2> <p> Conn represents a single database connection rather than a pool of database connections. Prefer running queries from DB unless there is a specific need for a continuous single database connection. </p> <p> A Conn must call Close to return the connection to the database pool and may do so concurrently with a running query. </p> <p> After a call to Close, all operations on the connection fail with ErrConnDone. </p> <pre data-language="go">type Conn struct {
        // contains filtered or unexported fields
}
</pre> <h3 id="Conn.BeginTx">func (*Conn) BeginTx<a href="https://golang.org/src/database/sql/sql.go?s=51392:51465#L1808" class="source" target="_blank">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *Conn) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)</pre> <p> BeginTx starts a transaction. </p> <p> The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. Tx.Commit will return an error if the context provided to BeginTx is canceled. </p> <p> The provided TxOptions is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"context"
	"database/sql"
	"log"
)

var ctx = context.Background()
var db *sql.DB

func main() {
	tx, err := db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		log.Fatal(err)
	}
	id := 37
	_, execErr := tx.Exec(`UPDATE users SET status = ? WHERE id = ?`, "paid", id)
	if execErr != nil {
		_ = tx.Rollback()
		log.Fatal(execErr)
	}
	if err := tx.Commit(); err != nil {
		log.Fatal(err)
	}
}
</pre>   <h3 id="Conn.Close">func (*Conn) Close<a href="https://golang.org/src/database/sql/sql.go?s=52527:52555#L1850" class="source" target="_blank">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *Conn) Close() error</pre> <p> Close returns the connection to the connection pool. All operations after a Close will return with ErrConnDone. Close is safe to call concurrently with other operations and will block until all other operations finish. It may be useful to first cancel any used context and then call close directly after. </p> <h3 id="Conn.ExecContext">func (*Conn) ExecContext<a href="https://golang.org/src/database/sql/sql.go?s=49198:49296#L1753" class="source" target="_blank">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *Conn) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)</pre> <p> ExecContext executes a query without returning any rows. The args are for any placeholder parameters in the query. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"context"
	"database/sql"
	"log"
)

var ctx = context.Background()
var db *sql.DB

func main() {
	// A *DB is a pool of connections. Call Conn to reserve a connection for
	// exclusive use.
	conn, err := db.Conn(ctx)
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close() // Return the connection to the pool.
	id := 41
	result, err := conn.ExecContext(ctx, `UPDATE balances SET balance = balance + 10 WHERE user_id = ?`, id)
	if err != nil {
		log.Fatal(err)
	}
	rows, err := result.RowsAffected()
	if err != nil {
		log.Fatal(err)
	}
	if rows != 1 {
		panic(err)
	}
}
</pre>   <h3 id="Conn.PingContext">func (*Conn) PingContext<a href="https://golang.org/src/database/sql/sql.go?s=48910:48963#L1743" class="source" target="_blank">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *Conn) PingContext(ctx context.Context) error</pre> <p> PingContext verifies the connection to the database is still alive. </p> <h3 id="Conn.PrepareContext">func (*Conn) PrepareContext<a href="https://golang.org/src/database/sql/sql.go?s=50707:50786#L1790" class="source" target="_blank">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *Conn) PrepareContext(ctx context.Context, query string) (*Stmt, error)</pre> <p> PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed. </p> <p> The provided context is used for the preparation of the statement, not for the execution of the statement. </p> <h3 id="Conn.QueryContext">func (*Conn) QueryContext<a href="https://golang.org/src/database/sql/sql.go?s=49561:49659#L1763" class="source" target="_blank">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *Conn) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)</pre> <p> QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query. </p> <h3 id="Conn.QueryRowContext">func (*Conn) QueryRowContext<a href="https://golang.org/src/database/sql/sql.go?s=50143:50234#L1777" class="source" target="_blank">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *Conn) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row</pre> <p> QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest. </p> <h2 id="DB">type DB<a href="https://golang.org/src/database/sql/sql.go?s=9508:11278#L339" class="source" target="_blank">Source</a>  </h2> <p> DB is a database handle representing a pool of zero or more underlying connections. It's safe for concurrent use by multiple goroutines. </p> <p> The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can be reliably observed within a transaction (Tx) or connection (Conn). Once DB.Begin is called, the returned Tx is bound to a single connection. Once Commit or Rollback is called on the transaction, that transaction's connection is returned to DB's idle connection pool. The pool size can be controlled with SetMaxIdleConns. </p> <pre data-language="go">type DB struct {
        // contains filtered or unexported fields
}
</pre> <h3 id="Open">func Open<a href="https://golang.org/src/database/sql/sql.go?s=20363:20420#L684" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Open(driverName, dataSourceName string) (*DB, error)</pre> <p> Open opens a database specified by its database driver name and a driver-specific data source name, usually consisting of at least a database name and connection information. </p> <p> Most users will open a database via a driver-specific connection helper function that returns a *DB. No database drivers are included in the Go standard library. See <a href="https://golang.org/s/sqldrivers" target="_blank">https://golang.org/s/sqldrivers</a> for a list of third-party drivers. </p> <p> Open may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call Ping. </p> <p> The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a DB. </p> <h3 id="OpenDB">func OpenDB<a href="https://golang.org/src/database/sql/sql.go?s=19124:19159#L650" class="source" target="_blank">Source</a>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func OpenDB(c driver.Connector) *DB</pre> <p> OpenDB opens a database using a Connector, allowing drivers to bypass a string based data source name. </p> <p> Most users will open a database via a driver-specific connection helper function that returns a *DB. No database drivers are included in the Go standard library. See <a href="https://golang.org/s/sqldrivers" target="_blank">https://golang.org/s/sqldrivers</a> for a list of third-party drivers. </p> <p> OpenDB may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call Ping. </p> <p> The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the OpenDB function should be called just once. It is rarely necessary to close a DB. </p> <h3 id="DB.Begin">func (*DB) Begin<a href="https://golang.org/src/database/sql/sql.go?s=45547:45581#L1628" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (db *DB) Begin() (*Tx, error)</pre> <p> Begin starts a transaction. The default isolation level is dependent on the driver. </p> <h3 id="DB.BeginTx">func (*DB) BeginTx<a href="https://golang.org/src/database/sql/sql.go?s=45119:45191#L1611" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (db *DB) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)</pre> <p> BeginTx starts a transaction. </p> <p> The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. Tx.Commit will return an error if the context provided to BeginTx is canceled. </p> <p> The provided TxOptions is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned. </p> <h3 id="DB.Close">func (*DB) Close<a href="https://golang.org/src/database/sql/sql.go?s=22048:22075#L748" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (db *DB) Close() error</pre> <p> Close closes the database and prevents new queries from starting. Close then waits for all queries that have started processing on the server to finish. </p> <p> It is rare to Close a DB, as the DB handle is meant to be long-lived and shared between many goroutines. </p> <h3 id="DB.Conn">func (*DB) Conn<a href="https://golang.org/src/database/sql/sql.go?s=47279:47333#L1682" class="source" target="_blank">Source</a>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (db *DB) Conn(ctx context.Context) (*Conn, error)</pre> <p> Conn returns a single connection by either opening a new connection or returning an existing connection from the connection pool. Conn will block until either a connection is returned or ctx is canceled. Queries run on the same Conn will be run in the same database session. </p> <p> Every Conn must be returned to the database pool after use by calling Conn.Close. </p> <h3 id="DB.Driver">func (*DB) Driver<a href="https://golang.org/src/database/sql/sql.go?s=46626:46662#L1667" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (db *DB) Driver() driver.Driver</pre> <p> Driver returns the database's underlying driver. </p> <h3 id="DB.Exec">func (*DB) Exec<a href="https://golang.org/src/database/sql/sql.go?s=39610:39679#L1429" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (db *DB) Exec(query string, args ...interface{}) (Result, error)</pre> <p> Exec executes a query without returning any rows. The args are for any placeholder parameters in the query. </p> <h3 id="DB.ExecContext">func (*DB) ExecContext<a href="https://golang.org/src/database/sql/sql.go?s=39115:39212#L1412" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (db *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)</pre> <p> ExecContext executes a query without returning any rows. The args are for any placeholder parameters in the query. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"context"
	"database/sql"
	"log"
)

var ctx = context.Background()
var db *sql.DB

func main() {
	id := 47
	result, err := db.ExecContext(ctx, "UPDATE balances SET balance = balance + 10 WHERE user_id = ?", id)
	if err != nil {
		log.Fatal(err)
	}
	rows, err := result.RowsAffected()
	if err != nil {
		log.Fatal(err)
	}
	if rows != 1 {
		panic(err)
	}
}
</pre>   <h3 id="DB.Ping">func (*DB) Ping<a href="https://golang.org/src/database/sql/sql.go?s=21695:21721#L738" class="source" target="_blank">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (db *DB) Ping() error</pre> <p> Ping verifies a connection to the database is still alive, establishing a connection if necessary. </p> <h3 id="DB.PingContext">func (*DB) PingContext<a href="https://golang.org/src/database/sql/sql.go?s=21213:21265#L716" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (db *DB) PingContext(ctx context.Context) error</pre> <p> PingContext verifies a connection to the database is still alive, establishing a connection if necessary. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"context"
	"database/sql"
	"log"
	"time"
)

var ctx = context.Background()
var db *sql.DB

func main() {
	ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
	defer cancel()
	if err := db.PingContext(ctx); err != nil {
		log.Fatal(err)
	}
}
</pre>   <h3 id="DB.Prepare">func (*DB) Prepare<a href="https://golang.org/src/database/sql/sql.go?s=37394:37444#L1359" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (db *DB) Prepare(query string) (*Stmt, error)</pre> <p> Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed. </p> <h3 id="DB.PrepareContext">func (*DB) PrepareContext<a href="https://golang.org/src/database/sql/sql.go?s=36777:36855#L1339" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (db *DB) PrepareContext(ctx context.Context, query string) (*Stmt, error)</pre> <p> PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed. </p> <p> The provided context is used for the preparation of the statement, not for the execution of the statement. </p> <h3 id="DB.Query">func (*DB) Query<a href="https://golang.org/src/database/sql/sql.go?s=41563:41632#L1499" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (db *DB) Query(query string, args ...interface{}) (*Rows, error)</pre> <p> Query executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query. </p>    <h4> <span class="text">Example (MultipleResultSets)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"database/sql"
	"fmt"
	"log"
)

var db *sql.DB

func main() {
	age := 27
	q := `
create temp table uid (id bigint); -- Create temp table for queries.
insert into uid
select id from users where age &lt; ?; -- Populate temp table.

-- First result set.
select
	users.id, name
from
	users
	join uid on users.id = uid.id
;

-- Second result set.
select 
	ur.user, ur.role
from
	user_roles as ur
	join uid on uid.id = ur.user
;
	`
	rows, err := db.Query(q, age)
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()

	for rows.Next() {
		var (
			id   int64
			name string
		)
		if err := rows.Scan(&amp;id, &amp;name); err != nil {
			log.Fatal(err)
		}
		fmt.Printf("id %d name is %s\n", id, name)
	}
	if !rows.NextResultSet() {
		log.Fatal("expected more result sets", rows.Err())
	}
	var roleMap = map[int64]string{
		1: "user",
		2: "admin",
		3: "gopher",
	}
	for rows.Next() {
		var (
			id   int64
			role int64
		)
		if err := rows.Scan(&amp;id, &amp;role); err != nil {
			log.Fatal(err)
		}
		fmt.Printf("id %d has role %s\n", id, roleMap[role])
	}
	if err := rows.Err(); err != nil {
		log.Fatal(err)
	}
}
</pre>   <h3 id="DB.QueryContext">func (*DB) QueryContext<a href="https://golang.org/src/database/sql/sql.go?s=41052:41149#L1482" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)</pre> <p> QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"strings"
)

var ctx = context.Background()
var db *sql.DB

func main() {
	age := 27
	rows, err := db.QueryContext(ctx, "SELECT name FROM users WHERE age=?", age)
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	names := make([]string, 0)
	for rows.Next() {
		var name string
		if err := rows.Scan(&amp;name); err != nil {
			log.Fatal(err)
		}
		names = append(names, name)
	}
	if err := rows.Err(); err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%s are %d years old", strings.Join(names, ", "), age)
}
</pre>   <h3 id="DB.QueryRow">func (*DB) QueryRow<a href="https://golang.org/src/database/sql/sql.go?s=44512:44574#L1597" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (db *DB) QueryRow(query string, args ...interface{}) *Row</pre> <p> QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest. </p> <h3 id="DB.QueryRowContext">func (*DB) QueryRowContext<a href="https://golang.org/src/database/sql/sql.go?s=43998:44088#L1586" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (db *DB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row</pre> <p> QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"time"
)

var ctx = context.Background()
var db *sql.DB

func main() {
	id := 123
	var username string
	var created time.Time
	err := db.QueryRowContext(ctx, "SELECT username, created_at FROM users WHERE id=?", id).Scan(&amp;username, &amp;created)
	switch {
	case err == sql.ErrNoRows:
		log.Printf("No user with id %d", id)
	case err != nil:
		log.Fatal(err)
	default:
		fmt.Printf("Username is %s, account created on %s\n", username, created)
	}
}
</pre>   <h3 id="DB.SetConnMaxLifetime">func (*DB) SetConnMaxLifetime<a href="https://golang.org/src/database/sql/sql.go?s=24592:24641#L855" class="source" target="_blank">Source</a>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (db *DB) SetConnMaxLifetime(d time.Duration)</pre> <p> SetConnMaxLifetime sets the maximum amount of time a connection may be reused. </p> <p> Expired connections may be closed lazily before reuse. </p> <p> If d &lt;= 0, connections are reused forever. </p> <h3 id="DB.SetMaxIdleConns">func (*DB) SetMaxIdleConns<a href="https://golang.org/src/database/sql/sql.go?s=23234:23270#L803" class="source" target="_blank">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (db *DB) SetMaxIdleConns(n int)</pre> <p> SetMaxIdleConns sets the maximum number of connections in the idle connection pool. </p> <p> If MaxOpenConns is greater than 0 but less than the new MaxIdleConns, then the new MaxIdleConns will be reduced to match the MaxOpenConns limit. </p> <p> If n &lt;= 0, no idle connections are retained. </p> <p> The default max idle connections is currently 2. This may change in a future release. </p> <h3 id="DB.SetMaxOpenConns">func (*DB) SetMaxOpenConns<a href="https://golang.org/src/database/sql/sql.go?s=24164:24200#L837" class="source" target="_blank">Source</a>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (db *DB) SetMaxOpenConns(n int)</pre> <p> SetMaxOpenConns sets the maximum number of open connections to the database. </p> <p> If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than MaxIdleConns, then MaxIdleConns will be reduced to match the new MaxOpenConns limit. </p> <p> If n &lt;= 0, then there is no limit on the number of open connections. The default is 0 (unlimited). </p> <h3 id="DB.Stats">func (*DB) Stats<a href="https://golang.org/src/database/sql/sql.go?s=26883:26912#L946" class="source" target="_blank">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (db *DB) Stats() DBStats</pre> <p> Stats returns database statistics. </p> <h2 id="DBStats">type DBStats<a href="https://golang.org/src/database/sql/sql.go?s=26132:26843#L930" class="source" target="_blank">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> DBStats contains database statistics. </p> <pre data-language="go">type DBStats struct {
        MaxOpenConnections int // Maximum number of open connections to the database; added in Go 1.11

        // Pool Status
        OpenConnections int // The number of established connections both in use and idle.
        InUse           int // The number of connections currently in use; added in Go 1.11
        Idle            int // The number of idle connections; added in Go 1.11

        // Counters
        WaitCount         int64         // The total number of connections waited for; added in Go 1.11
        WaitDuration      time.Duration // The total time blocked waiting for a new connection; added in Go 1.11
        MaxIdleClosed     int64         // The total number of connections closed due to SetMaxIdleConns; added in Go 1.11
        MaxLifetimeClosed int64         // The total number of connections closed due to SetConnMaxLifetime; added in Go 1.11
}
</pre> <h2 id="IsolationLevel">type IsolationLevel<a href="https://golang.org/src/database/sql/sql.go?s=3063:3086#L109" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h2> <p> IsolationLevel is the transaction isolation level used in TxOptions. </p> <pre data-language="go">type IsolationLevel int</pre> <p> Various isolation levels that drivers may support in BeginTx. If a driver does not support a given isolation level an error may be returned. </p> <p> See <a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels" target="_blank">https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels</a>. </p> <pre data-language="go">const (
        LevelDefault IsolationLevel = iota
        LevelReadUncommitted
        LevelReadCommitted
        LevelWriteCommitted
        LevelRepeatableRead
        LevelSnapshot
        LevelSerializable
        LevelLinearizable
)</pre> <h3 id="IsolationLevel.String">func (IsolationLevel) String<a href="https://golang.org/src/database/sql/sql.go?s=3506:3545#L126" class="source" target="_blank">Source</a>  <span title="Added in Go 1.11">1.11</span> </h3> <pre data-language="go">func (i IsolationLevel) String() string</pre> <h2 id="NamedArg">type NamedArg<a href="https://golang.org/src/database/sql/sql.go?s=1962:2337#L71" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h2> <p> A NamedArg is a named argument. NamedArg values may be used as arguments to Query or Exec and bind to the corresponding named parameter in the SQL statement. </p> <p> For a more concise way to create NamedArg values, see the Named function. </p> <pre data-language="go">type NamedArg struct {

        // Name is the name of the parameter placeholder.
        //
        // If empty, the ordinal position in the argument list will be
        // used.
        //
        // Name must omit any symbol prefix.
        Name string

        // Value is the value of the parameter.
        // It may be assigned the same value types as the query
        // arguments.
        Value interface{}
        // contains filtered or unexported fields
}
</pre> <h3 id="Named">func Named<a href="https://golang.org/src/database/sql/sql.go?s=2671:2722#L100" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func Named(name string, value interface{}) NamedArg</pre> <p> Named provides a more concise way to create NamedArg values. </p> <p> Example usage: </p> <pre data-language="go">db.ExecContext(ctx, `
    delete from Invoice
    where
        TimeCreated &lt; @end
        and TimeCreated &gt;= @start;`,
    sql.Named("start", startTime),
    sql.Named("end", endTime),
)
</pre> <h2 id="NullBool">type NullBool<a href="https://golang.org/src/database/sql/sql.go?s=6790:6875#L255" class="source" target="_blank">Source</a>  </h2> <p> NullBool represents a bool that may be null. NullBool implements the Scanner interface so it can be used as a scan destination, similar to NullString. </p> <pre data-language="go">type NullBool struct {
        Bool  bool
        Valid bool // Valid is true if Bool is not NULL
}
</pre> <h3 id="NullBool.Scan">func (*NullBool) Scan<a href="https://golang.org/src/database/sql/sql.go?s=6919:6967#L261" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (n *NullBool) Scan(value interface{}) error</pre> <p> Scan implements the Scanner interface. </p> <h3 id="NullBool.Value">func (NullBool) Value<a href="https://golang.org/src/database/sql/sql.go?s=7144:7191#L271" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (n NullBool) Value() (driver.Value, error)</pre> <p> Value implements the driver Valuer interface. </p> <h2 id="NullFloat64">type NullFloat64<a href="https://golang.org/src/database/sql/sql.go?s=6143:6241#L229" class="source" target="_blank">Source</a>  </h2> <p> NullFloat64 represents a float64 that may be null. NullFloat64 implements the Scanner interface so it can be used as a scan destination, similar to NullString. </p> <pre data-language="go">type NullFloat64 struct {
        Float64 float64
        Valid   bool // Valid is true if Float64 is not NULL
}
</pre> <h3 id="NullFloat64.Scan">func (*NullFloat64) Scan<a href="https://golang.org/src/database/sql/sql.go?s=6285:6336#L235" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (n *NullFloat64) Scan(value interface{}) error</pre> <p> Scan implements the Scanner interface. </p> <h3 id="NullFloat64.Value">func (NullFloat64) Value<a href="https://golang.org/src/database/sql/sql.go?s=6515:6565#L245" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (n NullFloat64) Value() (driver.Value, error)</pre> <p> Value implements the driver Valuer interface. </p> <h2 id="NullInt64">type NullInt64<a href="https://golang.org/src/database/sql/sql.go?s=5507:5595#L203" class="source" target="_blank">Source</a>  </h2> <p> NullInt64 represents an int64 that may be null. NullInt64 implements the Scanner interface so it can be used as a scan destination, similar to NullString. </p> <pre data-language="go">type NullInt64 struct {
        Int64 int64
        Valid bool // Valid is true if Int64 is not NULL
}
</pre> <h3 id="NullInt64.Scan">func (*NullInt64) Scan<a href="https://golang.org/src/database/sql/sql.go?s=5639:5688#L209" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (n *NullInt64) Scan(value interface{}) error</pre> <p> Scan implements the Scanner interface. </p> <h3 id="NullInt64.Value">func (NullInt64) Value<a href="https://golang.org/src/database/sql/sql.go?s=5863:5911#L219" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (n NullInt64) Value() (driver.Value, error)</pre> <p> Value implements the driver Valuer interface. </p> <h2 id="NullString">type NullString<a href="https://golang.org/src/database/sql/sql.go?s=4857:4950#L177" class="source" target="_blank">Source</a>  </h2> <p> NullString represents a string that may be null. NullString implements the Scanner interface so it can be used as a scan destination: </p> <pre data-language="go">var s NullString
err := db.QueryRow("SELECT name FROM foo WHERE id=?", id).Scan(&amp;s)
...
if s.Valid {
   // use s.String
} else {
   // NULL value
}
</pre> <pre data-language="go">type NullString struct {
        String string
        Valid  bool // Valid is true if String is not NULL
}
</pre> <h3 id="NullString.Scan">func (*NullString) Scan<a href="https://golang.org/src/database/sql/sql.go?s=4994:5045#L183" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ns *NullString) Scan(value interface{}) error</pre> <p> Scan implements the Scanner interface. </p> <h3 id="NullString.Value">func (NullString) Value<a href="https://golang.org/src/database/sql/sql.go?s=5227:5277#L193" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ns NullString) Value() (driver.Value, error)</pre> <p> Value implements the driver Valuer interface. </p> <h2 id="Out">type Out<a href="https://golang.org/src/database/sql/sql.go?s=8204:8600#L309" class="source" target="_blank">Source</a>  <span title="Added in Go 1.9">1.9</span> </h2> <p> Out may be used to retrieve OUTPUT value parameters from stored procedures. </p> <p> Not all drivers and databases support OUTPUT value parameters. </p> <p> Example usage: </p> <pre data-language="go">var outArg string
_, err := db.ExecContext(ctx, "ProcName", sql.Named("Arg1", sql.Out{Dest: &amp;outArg}))
</pre> <pre data-language="go">type Out struct {

        // Dest is a pointer to the value that will be set to the result of the
        // stored procedure's OUTPUT parameter.
        Dest interface{}

        // In is whether the parameter is an INOUT parameter. If so, the input value to the stored
        // procedure is the dereferenced value of Dest's pointer, which is then replaced with
        // the output value.
        In bool
        // contains filtered or unexported fields
}
</pre> <h2 id="RawBytes">type RawBytes<a href="https://golang.org/src/database/sql/sql.go?s=4506:4526#L162" class="source" target="_blank">Source</a>  </h2> <p> RawBytes is a byte slice that holds a reference to memory owned by the database itself. After a Scan into a RawBytes, the slice is only valid until the next call to Next, Scan, or Close. </p> <pre data-language="go">type RawBytes []byte</pre> <h2 id="Result">type Result<a href="https://golang.org/src/database/sql/sql.go?s=86984:87490#L3026" class="source" target="_blank">Source</a>  </h2> <p> A Result summarizes an executed SQL command. </p> <pre data-language="go">type Result interface {
        // LastInsertId returns the integer generated by the database
        // in response to a command. Typically this will be from an
        // "auto increment" column when inserting a new row. Not all
        // databases support this feature, and the syntax of such
        // statements varies.
        LastInsertId() (int64, error)

        // RowsAffected returns the number of rows affected by an
        // update, insert, or delete. Not every database or database
        // driver may support this.
        RowsAffected() (int64, error)
}</pre> <h2 id="Row">type Row<a href="https://golang.org/src/database/sql/sql.go?s=85295:85412#L2975" class="source" target="_blank">Source</a>  </h2> <p> Row is the result of calling QueryRow to select a single row. </p> <pre data-language="go">type Row struct {
        // contains filtered or unexported fields
}
</pre> <h3 id="Row.Scan">func (*Row) Scan<a href="https://golang.org/src/database/sql/sql.go?s=85698:85743#L2986" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Row) Scan(dest ...interface{}) error</pre> <p> Scan copies the columns from the matched row into the values pointed at by dest. See the documentation on Rows.Scan for details. If more than one row matches the query, Scan uses the first row and discards the rest. If no row matches the query, Scan returns ErrNoRows. </p> <h2 id="Rows">type Rows<a href="https://golang.org/src/database/sql/sql.go?s=73165:73887#L2579" class="source" target="_blank">Source</a>  </h2> <p> Rows is the result of a query. Its cursor starts before the first row of the result set. Use Next to advance from row to row. </p> <pre data-language="go">type Rows struct {
        // contains filtered or unexported fields
}
</pre>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"strings"
)

var ctx = context.Background()
var db *sql.DB

func main() {
	age := 27
	rows, err := db.QueryContext(ctx, "SELECT name FROM users WHERE age=?", age)
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	names := make([]string, 0)
	for rows.Next() {
		var name string
		if err := rows.Scan(&amp;name); err != nil {
			log.Fatal(err)
		}
		names = append(names, name)
	}
	if err := rows.Err(); err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%s are %d years old", strings.Join(names, ", "), age)
}
</pre>   <h3 id="Rows.Close">func (*Rows) Close<a href="https://golang.org/src/database/sql/sql.go?s=84746:84775#L2940" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (rs *Rows) Close() error</pre> <p> Close closes the Rows, preventing further enumeration. If Next is called and returns false and there are no further result sets, the Rows are closed automatically and it will suffice to check the result of Err. Close is idempotent and does not affect the result of Err. </p> <h3 id="Rows.ColumnTypes">func (*Rows) ColumnTypes<a href="https://golang.org/src/database/sql/sql.go?s=78009:78061#L2749" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (rs *Rows) ColumnTypes() ([]*ColumnType, error)</pre> <p> ColumnTypes returns column information such as column type, length, and nullable. Some information may not be available from some drivers. </p> <h3 id="Rows.Columns">func (*Rows) Columns<a href="https://golang.org/src/database/sql/sql.go?s=77554:77597#L2732" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (rs *Rows) Columns() ([]string, error)</pre> <p> Columns returns the column names. Columns returns an error if the rows are closed, or if the rows are from QueryRow and there was a deferred error. </p> <h3 id="Rows.Err">func (*Rows) Err<a href="https://golang.org/src/database/sql/sql.go?s=77254:77281#L2720" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (rs *Rows) Err() error</pre> <p> Err returns the error, if any, that was encountered during iteration. Err may be called after an explicit or implicit Close. </p> <h3 id="Rows.Next">func (*Rows) Next<a href="https://golang.org/src/database/sql/sql.go?s=74946:74973#L2630" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (rs *Rows) Next() bool</pre> <p> Next prepares the next result row for reading with the Scan method. It returns true on success, or false if there is no next result row or an error happened while preparing it. Err should be consulted to distinguish between the two cases. </p> <p> Every call to Scan, even the first one, must be preceded by a call to Next. </p> <h3 id="Rows.NextResultSet">func (*Rows) NextResultSet<a href="https://golang.org/src/database/sql/sql.go?s=76505:76541#L2684" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (rs *Rows) NextResultSet() bool</pre> <p> NextResultSet prepares the next result set for reading. It returns true if there is further result sets, or false if there is no further result set or if there is an error advancing to it. The Err method should be consulted to distinguish between the two cases. </p> <p> After calling NextResultSet, the Next method should always be called before scanning. If there are further result sets they may not have rows in the result set. </p> <h3 id="Rows.Scan">func (*Rows) Scan<a href="https://golang.org/src/database/sql/sql.go?s=83583:83630#L2904" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (rs *Rows) Scan(dest ...interface{}) error</pre> <p> Scan copies the columns in the current row into the values pointed at by dest. The number of values in dest must be the same as the number of columns in Rows. </p> <p> Scan converts columns read from the database into the following common Go types and special types provided by the sql package: </p> <pre data-language="go">*string
*[]byte
*int, *int8, *int16, *int32, *int64
*uint, *uint8, *uint16, *uint32, *uint64
*bool
*float32, *float64
*interface{}
*RawBytes
any type implementing Scanner (see Scanner docs)
</pre> <p> In the most simple case, if the type of the value from the source column is an integer, bool or string type T and dest is of type *T, Scan simply assigns the value through the pointer. </p> <p> Scan also converts between string and numeric types, as long as no information would be lost. While Scan stringifies all numbers scanned from numeric database columns into *string, scans into numeric types are checked for overflow. For example, a float64 with value 300 or a string with value "300" can scan into a uint16, but not into a uint8, though float64(255) or "255" can scan into a uint8. One exception is that scans of some float64 numbers to strings may lose information when stringifying. In general, scan floating point columns into *float64. </p> <p> If a dest argument has type *[]byte, Scan saves in that argument a copy of the corresponding data. The copy is owned by the caller and can be modified and held indefinitely. The copy can be avoided by using an argument of type *RawBytes instead; see the documentation for RawBytes for restrictions on its use. </p> <p> If an argument has type *interface{}, Scan copies the value provided by the underlying driver without conversion. When scanning from a source value of type []byte to *interface{}, a copy of the slice is made and the caller owns the result. </p> <p> Source values of type time.Time may be scanned into values of type *time.Time, *interface{}, *string, or *[]byte. When converting to the latter two, time.RFC3339Nano is used. </p> <p> Source values of type bool may be scanned into types *bool, *interface{}, *string, *[]byte, or *RawBytes. </p> <p> For scanning into *bool, the source may be true, false, 1, 0, or string inputs parseable by strconv.ParseBool. </p> <h2 id="Scanner">type Scanner<a href="https://golang.org/src/database/sql/sql.go?s=7294:7917#L279" class="source" target="_blank">Source</a>  </h2> <p> Scanner is an interface used by Scan. </p> <pre data-language="go">type Scanner interface {
        // Scan assigns a value from a database driver.
        //
        // The src value will be of one of the following types:
        //
        //    int64
        //    float64
        //    bool
        //    []byte
        //    string
        //    time.Time
        //    nil - for NULL values
        //
        // An error should be returned if the value cannot be stored
        // without loss of information.
        //
        // Reference types such as []byte are only valid until the next call to Scan
        // and should not be retained. Their underlying memory is owned by the driver.
        // If retention is necessary, copy their values before the next call to Scan.
        Scan(src interface{}) error
}</pre> <h2 id="Stmt">type Stmt<a href="https://golang.org/src/database/sql/sql.go?s=64087:65505#L2250" class="source" target="_blank">Source</a>  </h2> <p> Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines. </p> <pre data-language="go">type Stmt struct {
        // contains filtered or unexported fields
}
</pre>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"context"
	"database/sql"
	"fmt"
	"log"
)

var ctx = context.Background()
var db *sql.DB

func main() {
	// In normal use, create one Stmt when your process starts.
	stmt, err := db.PrepareContext(ctx, "SELECT username FROM users WHERE id = ?")
	if err != nil {
		log.Fatal(err)
	}
	defer stmt.Close()
	// Then reuse it each time you need to issue the query.
	id := 43
	var username string
	err = stmt.QueryRowContext(ctx, id).Scan(&amp;username)
	switch {
	case err == sql.ErrNoRows:
		log.Printf("No user with that ID.")
	case err != nil:
		log.Fatal(err)
	default:
		fmt.Printf("Username is %s\n", username)
	}
}
</pre>   <h3 id="Stmt.Close">func (*Stmt) Close<a href="https://golang.org/src/database/sql/sql.go?s=72299:72327#L2534" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (s *Stmt) Close() error</pre> <p> Close closes the statement. </p> <h3 id="Stmt.Exec">func (*Stmt) Exec<a href="https://golang.org/src/database/sql/sql.go?s=66373:66429#L2319" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (s *Stmt) Exec(args ...interface{}) (Result, error)</pre> <p> Exec executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement. </p> <h3 id="Stmt.ExecContext">func (*Stmt) ExecContext<a href="https://golang.org/src/database/sql/sql.go?s=65642:65726#L2290" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (s *Stmt) ExecContext(ctx context.Context, args ...interface{}) (Result, error)</pre> <p> ExecContext executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement. </p> <h3 id="Stmt.Query">func (*Stmt) Query<a href="https://golang.org/src/database/sql/sql.go?s=70677:70733#L2490" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (s *Stmt) Query(args ...interface{}) (*Rows, error)</pre> <p> Query executes a prepared query statement with the given arguments and returns the query results as a *Rows. </p> <h3 id="Stmt.QueryContext">func (*Stmt) QueryContext<a href="https://golang.org/src/database/sql/sql.go?s=69274:69358#L2435" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (s *Stmt) QueryContext(ctx context.Context, args ...interface{}) (*Rows, error)</pre> <p> QueryContext executes a prepared query statement with the given arguments and returns the query results as a *Rows. </p> <h3 id="Stmt.QueryRow">func (*Stmt) QueryRow<a href="https://golang.org/src/database/sql/sql.go?s=72156:72205#L2529" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (s *Stmt) QueryRow(args ...interface{}) *Row</pre> <p> QueryRow executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest. </p> <p> Example usage: </p> <pre data-language="go">var name string
err := nameByUseridStmt.QueryRow(id).Scan(&amp;name)
</pre> <h3 id="Stmt.QueryRowContext">func (*Stmt) QueryRowContext<a href="https://golang.org/src/database/sql/sql.go?s=71476:71553#L2510" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (s *Stmt) QueryRowContext(ctx context.Context, args ...interface{}) *Row</pre> <p> QueryRowContext executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"context"
	"database/sql"
	"fmt"
	"log"
)

var ctx = context.Background()
var db *sql.DB

func main() {
	// In normal use, create one Stmt when your process starts.
	stmt, err := db.PrepareContext(ctx, "SELECT username FROM users WHERE id = ?")
	if err != nil {
		log.Fatal(err)
	}
	// Then reuse it each time you need to issue the query.
	id := 43
	var username string
	err = stmt.QueryRowContext(ctx, id).Scan(&amp;username)
	switch {
	case err == sql.ErrNoRows:
		log.Printf("No user with that ID.")
	case err != nil:
		log.Fatal(err)
	default:
		fmt.Printf("Username is %s\n", username)
	}
}
</pre>   <h2 id="Tx">type Tx<a href="https://golang.org/src/database/sql/sql.go?s=52945:53918#L1864" class="source" target="_blank">Source</a>  </h2> <p> Tx is an in-progress database transaction. </p> <p> A transaction must end with a call to Commit or Rollback. </p> <p> After a call to Commit or Rollback, all operations on the transaction fail with ErrTxDone. </p> <p> The statements prepared for a transaction by calling the transaction's Prepare or Stmt methods are closed by the call to Commit or Rollback. </p> <pre data-language="go">type Tx struct {
        // contains filtered or unexported fields
}
</pre> <h3 id="Tx.Commit">func (*Tx) Commit<a href="https://golang.org/src/database/sql/sql.go?s=56158:56186#L1982" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (tx *Tx) Commit() error</pre> <p> Commit commits the transaction. </p> <h3 id="Tx.Exec">func (*Tx) Exec<a href="https://golang.org/src/database/sql/sql.go?s=61642:61711#L2184" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (tx *Tx) Exec(query string, args ...interface{}) (Result, error)</pre> <p> Exec executes a query that doesn't return rows. For example: an INSERT and UPDATE. </p> <h3 id="Tx.ExecContext">func (*Tx) ExecContext<a href="https://golang.org/src/database/sql/sql.go?s=61322:61419#L2174" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (tx *Tx) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)</pre> <p> ExecContext executes a query that doesn't return rows. For example: an INSERT and UPDATE. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"context"
	"database/sql"
	"log"
)

var ctx = context.Background()
var db *sql.DB

func main() {
	tx, err := db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		log.Fatal(err)
	}
	id := 37
	_, execErr := tx.ExecContext(ctx, "UPDATE users SET status = ? WHERE id = ?", "paid", id)
	if execErr != nil {
		if rollbackErr := tx.Rollback(); rollbackErr != nil {
			log.Printf("Could not roll back: %v\n", rollbackErr)
		}
		log.Fatal(execErr)
	}
	if err := tx.Commit(); err != nil {
		log.Fatal(err)
	}
}
</pre>   <h3 id="Tx.Prepare">func (*Tx) Prepare<a href="https://golang.org/src/database/sql/sql.go?s=58384:58434#L2065" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (tx *Tx) Prepare(query string) (*Stmt, error)</pre> <p> Prepare creates a prepared statement for use within a transaction. </p> <p> The returned statement operates within the transaction and can no longer be used once the transaction has been committed or rolled back. </p> <p> To use an existing prepared statement on this transaction, see Tx.Stmt. </p> <h3 id="Tx.PrepareContext">func (*Tx) PrepareContext<a href="https://golang.org/src/database/sql/sql.go?s=57739:57817#L2043" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (tx *Tx) PrepareContext(ctx context.Context, query string) (*Stmt, error)</pre> <p> PrepareContext creates a prepared statement for use within a transaction. </p> <p> The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back. </p> <p> To use an existing prepared statement on this transaction, see Tx.Stmt. </p> <p> The provided context will be used for the preparation of the context, not for the execution of the returned statement. The returned statement will run in the transaction context. </p> <h3 id="Tx.Query">func (*Tx) Query<a href="https://golang.org/src/database/sql/sql.go?s=62156:62225#L2199" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error)</pre> <p> Query executes a query that returns rows, typically a SELECT. </p> <h3 id="Tx.QueryContext">func (*Tx) QueryContext<a href="https://golang.org/src/database/sql/sql.go?s=61850:61947#L2189" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (tx *Tx) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)</pre> <p> QueryContext executes a query that returns rows, typically a SELECT. </p> <h3 id="Tx.QueryRow">func (*Tx) QueryRow<a href="https://golang.org/src/database/sql/sql.go?s=63153:63215#L2220" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (tx *Tx) QueryRow(query string, args ...interface{}) *Row</pre> <p> QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest. </p> <h3 id="Tx.QueryRowContext">func (*Tx) QueryRowContext<a href="https://golang.org/src/database/sql/sql.go?s=62639:62729#L2209" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (tx *Tx) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row</pre> <p> QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest. </p> <h3 id="Tx.Rollback">func (*Tx) Rollback<a href="https://golang.org/src/database/sql/sql.go?s=57191:57221#L2029" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (tx *Tx) Rollback() error</pre> <p> Rollback aborts the transaction. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"context"
	"database/sql"
	"log"
)

var ctx = context.Background()
var db *sql.DB

func main() {
	tx, err := db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		log.Fatal(err)
	}
	id := 53
	_, err = tx.ExecContext(ctx, "UPDATE drivers SET status = ? WHERE id = ?", "assigned", id)
	if err != nil {
		if rollbackErr := tx.Rollback(); rollbackErr != nil {
			log.Printf("Could not roll back: %v\n", rollbackErr)
		}
		log.Fatal(err)
	}
	_, err = tx.ExecContext(ctx, "UPDATE pickups SET driver_id = $1", id)
	if err != nil {
		if rollbackErr := tx.Rollback(); rollbackErr != nil {
			log.Printf("Could not roll back: %v\n", rollbackErr)
		}
		log.Fatal(err)
	}
	if err := tx.Commit(); err != nil {
		log.Fatal(err)
	}
}
</pre>   <h3 id="Tx.Stmt">func (*Tx) Stmt<a href="https://golang.org/src/database/sql/sql.go?s=61133:61169#L2168" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (tx *Tx) Stmt(stmt *Stmt) *Stmt</pre> <p> Stmt returns a transaction-specific prepared statement from an existing statement. </p> <p> Example: </p> <pre data-language="go">updateMoney, err := db.Prepare("UPDATE balance SET money=money+? WHERE id=?")
...
tx, err := db.Begin()
...
res, err := tx.Stmt(updateMoney).Exec(123.45, 98293203)
</pre> <p> The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back. </p> <h3 id="Tx.StmtContext">func (*Tx) StmtContext<a href="https://golang.org/src/database/sql/sql.go?s=59057:59121#L2084" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (tx *Tx) StmtContext(ctx context.Context, stmt *Stmt) *Stmt</pre> <p> StmtContext returns a transaction-specific prepared statement from an existing statement. </p> <p> Example: </p> <pre data-language="go">updateMoney, err := db.Prepare("UPDATE balance SET money=money+? WHERE id=?")
...
tx, err := db.Begin()
...
res, err := tx.StmtContext(ctx, updateMoney).Exec(123.45, 98293203)
</pre> <p> The provided context is used for the preparation of the statement, not for the execution of the statement. </p> <p> The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back. </p> <h2 id="TxOptions">type TxOptions<a href="https://golang.org/src/database/sql/sql.go?s=4130:4308#L152" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h2> <p> TxOptions holds the transaction options to be used in DB.BeginTx. </p> <pre data-language="go">type TxOptions struct {
        // Isolation is the transaction isolation level.
        // If zero, the driver or database's default level is used.
        Isolation IsolationLevel
        ReadOnly  bool
}
</pre> <h2 id="pkg-subdirectories">Subdirectories</h2> <div class="pkg-dir"> <table> <tr> <th class="pkg-name">Name</th> <th class="pkg-synopsis">Synopsis</th> </tr> <tr> <td colspan="2"><a href="../">..</a></td> </tr> <tr> <td class="pkg-name"> <a href="driver/">driver</a> </td> <td class="pkg-synopsis"> Package driver defines interfaces to be implemented by database drivers as used by package sql. </td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/database/sql/" class="_attribution-link" target="_blank">https://golang.org/pkg/database/sql/</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
