
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>numpy.distutils.misc_util.Configuration() - NumPy 1.14 - W3cubDocs</title>
  
  <meta name="description" content="NumPy provides enhanced distutils functionality to make it easier to build and install sub-packages, auto-generate code, and extension modules that &hellip;">
  <meta name="keywords" content="packaging, numpy, distutils, misc, util, configuration, -, numpy~1.14">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/numpy~1.14/distutils/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/numpy~1.14.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/numpy~1.14/" class="_nav-link" title="" style="margin-left:0;">NumPy 1.14</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1 id="packaging-numpy-distutils">Packaging (numpy.distutils)</h1> <p id="module-numpy.distutils">NumPy provides enhanced distutils functionality to make it easier to build and install sub-packages, auto-generate code, and extension modules that use Fortran-compiled libraries. To use features of NumPy distutils, use the <code>setup</code> command from <code>numpy.distutils.core</code>. A useful <a class="reference internal" href="#numpy.distutils.misc_util.Configuration" title="numpy.distutils.misc_util.Configuration"><code>Configuration</code></a> class is also provided in <a class="reference internal" href="#module-numpy.distutils.misc_util" title="numpy.distutils.misc_util"><code>numpy.distutils.misc_util</code></a> that can make it easier to construct keyword arguments to pass to the setup function (by passing the dictionary obtained from the todict() method of the class). More information is available in the NumPy Distutils Users Guide in <code>&lt;site-packages&gt;/numpy/doc/DISTUTILS.txt</code>.</p>  <h2 id="index-0">Modules in numpy.distutils</h2>  <h3 id="misc-util">misc_util</h3> <table class="longtable docutils" id="modules-in-numpy-distutils">   <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.get_numpy_include_dirs/#numpy.distutils.misc_util.get_numpy_include_dirs" title="numpy.distutils.misc_util.get_numpy_include_dirs"><code>get_numpy_include_dirs</code></a>()</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.dict_append/#numpy.distutils.misc_util.dict_append" title="numpy.distutils.misc_util.dict_append"><code>dict_append</code></a>(d, **kws)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.appendpath/#numpy.distutils.misc_util.appendpath" title="numpy.distutils.misc_util.appendpath"><code>appendpath</code></a>(prefix, path)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.allpath/#numpy.distutils.misc_util.allpath" title="numpy.distutils.misc_util.allpath"><code>allpath</code></a>(name)</td> <td>Convert a /-separated pathname to one using the OS’s path separator.</td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.dot_join/#numpy.distutils.misc_util.dot_join" title="numpy.distutils.misc_util.dot_join"><code>dot_join</code></a>(*args)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.generate_config_py/#numpy.distutils.misc_util.generate_config_py" title="numpy.distutils.misc_util.generate_config_py"><code>generate_config_py</code></a>(target)</td> <td>Generate config.py file containing system_info information used during building the package.</td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.get_cmd/#numpy.distutils.misc_util.get_cmd" title="numpy.distutils.misc_util.get_cmd"><code>get_cmd</code></a>(cmdname[, _cache])</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.terminal_has_colors/#numpy.distutils.misc_util.terminal_has_colors" title="numpy.distutils.misc_util.terminal_has_colors"><code>terminal_has_colors</code></a>()</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.red_text/#numpy.distutils.misc_util.red_text" title="numpy.distutils.misc_util.red_text"><code>red_text</code></a>(s)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.green_text/#numpy.distutils.misc_util.green_text" title="numpy.distutils.misc_util.green_text"><code>green_text</code></a>(s)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.yellow_text/#numpy.distutils.misc_util.yellow_text" title="numpy.distutils.misc_util.yellow_text"><code>yellow_text</code></a>(s)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.blue_text/#numpy.distutils.misc_util.blue_text" title="numpy.distutils.misc_util.blue_text"><code>blue_text</code></a>(s)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.cyan_text/#numpy.distutils.misc_util.cyan_text" title="numpy.distutils.misc_util.cyan_text"><code>cyan_text</code></a>(s)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.cyg2win32/#numpy.distutils.misc_util.cyg2win32" title="numpy.distutils.misc_util.cyg2win32"><code>cyg2win32</code></a>(path)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.all_strings/#numpy.distutils.misc_util.all_strings" title="numpy.distutils.misc_util.all_strings"><code>all_strings</code></a>(lst)</td> <td>Return True if all items in lst are string objects.</td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.has_f_sources/#numpy.distutils.misc_util.has_f_sources" title="numpy.distutils.misc_util.has_f_sources"><code>has_f_sources</code></a>(sources)</td> <td>Return True if sources contains Fortran files</td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.has_cxx_sources/#numpy.distutils.misc_util.has_cxx_sources" title="numpy.distutils.misc_util.has_cxx_sources"><code>has_cxx_sources</code></a>(sources)</td> <td>Return True if sources contains C++ files</td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.filter_sources/#numpy.distutils.misc_util.filter_sources" title="numpy.distutils.misc_util.filter_sources"><code>filter_sources</code></a>(sources)</td> <td>Return four lists of filenames containing C, C++, Fortran, and Fortran 90 module sources, respectively.</td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.get_dependencies/#numpy.distutils.misc_util.get_dependencies" title="numpy.distutils.misc_util.get_dependencies"><code>get_dependencies</code></a>(sources)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.is_local_src_dir/#numpy.distutils.misc_util.is_local_src_dir" title="numpy.distutils.misc_util.is_local_src_dir"><code>is_local_src_dir</code></a>(directory)</td> <td>Return true if directory is local directory.</td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.get_ext_source_files/#numpy.distutils.misc_util.get_ext_source_files" title="numpy.distutils.misc_util.get_ext_source_files"><code>get_ext_source_files</code></a>(ext)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.misc_util.get_script_files/#numpy.distutils.misc_util.get_script_files" title="numpy.distutils.misc_util.get_script_files"><code>get_script_files</code></a>(scripts)</td> <td></td> </tr>  </table> <dl class="class"> <dt id="numpy.distutils.misc_util.Configuration">
<code>class numpy.distutils.misc_util.Configuration(package_name=None, parent_name=None, top_path=None, package_path=None, **attrs)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L720-L2078" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Construct a configuration instance for the given package name. If <em>parent_name</em> is not None, then construct the package as a sub-package of the <em>parent_name</em> package. If <em>top_path</em> and <em>package_path</em> are None then they are assumed equal to the path of the file this instance was created in. The setup.py files in the numpy distribution are good examples of how to use the <a class="reference internal" href="#numpy.distutils.misc_util.Configuration" title="numpy.distutils.misc_util.Configuration"><code>Configuration</code></a> instance.</p> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.todict">
<code>todict()</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L827-L844" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a dictionary compatible with the keyword arguments of distutils setup function.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; setup(**config.todict())                           
</pre> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.get_distribution">
<code>get_distribution()</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L870-L873" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the distutils distribution object for self.</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.get_subpackage">
<code>get_subpackage(subpackage_name, subpackage_path=None, parent_name=None, caller_level=1)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L938-L997" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return list of subpackage configurations.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>subpackage_name</strong> : str or None</p>  <p>Name of the subpackage to get the configuration. ‘*’ in subpackage_name is handled as a wildcard.</p>  <p><strong>subpackage_path</strong> : str</p>  <p>If None, then the path is assumed to be the local path plus the subpackage_name. If a setup.py file is not found in the subpackage_path, then a default configuration is used.</p>  <p><strong>parent_name</strong> : str</p>  <p>Parent name.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.add_subpackage">
<code>add_subpackage(subpackage_name, subpackage_path=None, standalone=False)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L999-L1040" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a sub-package to the current Configuration instance.</p> <p>This is useful in a setup.py script for adding sub-packages to a package.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>subpackage_name</strong> : str</p>  <p>name of the subpackage</p>  <p><strong>subpackage_path</strong> : str</p>  <p>if given, the subpackage path such as the subpackage is in subpackage_path / subpackage_name. If None,the subpackage is assumed to be located in the local path / subpackage_name.</p>  <p class="last"><strong>standalone</strong> : bool</p> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.add_data_files">
<code>add_data_files(*files)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1172-L1321" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add data files to configuration data_files.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>files</strong> : sequence</p>  <p>Argument(s) can be either</p>  <ul class="simple"> <li>2-sequence (&lt;datadir prefix&gt;,&lt;path to data file(s)&gt;)</li> <li>paths to data files where python datadir prefix defaults to package dir.</li> </ul>   </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The form of each element of the files sequence is very flexible allowing many combinations of where to get the files from the package and where they should ultimately be installed on the system. The most basic usage is for an element of the files argument sequence to be a simple filename. This will cause that file from the local path to be installed to the installation path of the self.name package (package path). The file argument can also be a relative path in which case the entire relative path will be installed into the package directory. Finally, the file can be an absolute path name in which case the file will be found at the absolute path name but installed to the package path.</p> <p>This basic behavior can be augmented by passing a 2-tuple in as the file argument. The first element of the tuple should specify the relative path (under the package install directory) where the remaining sequence of files should be installed to (it has nothing to do with the file-names in the source distribution). The second element of the tuple is the sequence of files that should be installed. The files in this sequence can be filenames, relative paths, or absolute paths. For absolute paths the file will be installed in the top-level package installation directory (regardless of the first argument). Filenames and relative path names will be installed in the package install directory under the path name given as the first element of the tuple.</p> <p>Rules for installation paths:</p>  <ol class="arabic simple"> <li>file.txt -&gt; (., file.txt)-&gt; parent/file.txt</li> <li>foo/file.txt -&gt; (foo, foo/file.txt) -&gt; parent/foo/file.txt</li> <li>/foo/bar/file.txt -&gt; (., /foo/bar/file.txt) -&gt; parent/file.txt</li> <li>
<a href="#id1"><span class="problematic" id="id2">*</span></a>.txt -&gt; parent/a.txt, parent/b.txt</li> <li>foo/<a href="#id3"><span class="problematic" id="id4">*</span></a>.txt -&gt; parent/foo/a.txt, parent/foo/b.txt</li> <li>
<em>/</em>.txt -&gt; (<em>, */</em>.txt) -&gt; parent/c/a.txt, parent/d/b.txt</li> <li>(sun, file.txt) -&gt; parent/sun/file.txt</li> <li>(sun, bar/file.txt) -&gt; parent/sun/file.txt</li> <li>(sun, /foo/bar/file.txt) -&gt; parent/sun/file.txt</li> <li>(sun, <a href="#id5"><span class="problematic" id="id6">*</span></a>.txt) -&gt; parent/sun/a.txt, parent/sun/b.txt</li> <li>(sun, bar/<a href="#id7"><span class="problematic" id="id8">*</span></a>.txt) -&gt; parent/sun/a.txt, parent/sun/b.txt</li> <li>(sun/<em>, */</em>.txt) -&gt; parent/sun/c/a.txt, parent/d/b.txt</li> </ol>  <p>An additional feature is that the path to a data-file can actually be a function that takes no arguments and returns the actual path(s) to the data-files. This is useful when the data files are generated while building the package.</p> <h4 class="rubric">Examples</h4> <p>Add files to the list of data_files to be included with the package.</p> <pre data-language="python">&gt;&gt;&gt; self.add_data_files('foo.dat',
...     ('fun', ['gun.dat', 'nun/pun.dat', '/tmp/sun.dat']),
...     'bar/cat.dat',
...     '/full/path/to/can.dat')                   
</pre> <p>will install these data files to:</p> <pre data-language="python">&lt;package install directory&gt;/
 foo.dat
 fun/
   gun.dat
   nun/
     pun.dat
 sun.dat
 bar/
   car.dat
 can.dat
</pre> <p>where &lt;package install directory&gt; is the package (or sub-package) directory such as ‘/usr/lib/python2.4/site-packages/mypackage’ (‘C: Python2.4 Lib site-packages mypackage’) or ‘/usr/lib/python2.4/site- packages/mypackage/mysubpackage’ (‘C: Python2.4 Lib site-packages mypackage mysubpackage’).</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.add_data_dir">
<code>add_data_dir(data_path)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1042-L1161" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Recursively add files under data_path to data_files list.</p> <p>Recursively add files under data_path to the list of data_files to be installed (and distributed). The data_path can be either a relative path-name, or an absolute path-name, or a 2-tuple where the first argument shows where in the install directory the data directory should be installed to.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data_path</strong> : seq or str</p>  <p>Argument can be either</p>  <ul class="simple"> <li>2-sequence (&lt;datadir suffix&gt;, &lt;path to data directory&gt;)</li> <li>path to data directory where python datadir suffix defaults to package dir.</li> </ul>   </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Rules for installation paths:</p> <pre data-language="python">foo/bar -&gt; (foo/bar, foo/bar) -&gt; parent/foo/bar
(gun, foo/bar) -&gt; parent/gun
foo/* -&gt; (foo/a, foo/a), (foo/b, foo/b) -&gt; parent/foo/a, parent/foo/b
(gun, foo/*) -&gt; (gun, foo/a), (gun, foo/b) -&gt; gun
(gun/*, foo/*) -&gt; parent/gun/a, parent/gun/b
/foo/bar -&gt; (bar, /foo/bar) -&gt; parent/bar
(gun, /foo/bar) -&gt; parent/gun
(fun/*/gun/*, sun/foo/bar) -&gt; parent/fun/foo/gun/bar
</pre> <h4 class="rubric">Examples</h4> <p>For example suppose the source directory contains fun/foo.dat and fun/bar/car.dat:</p> <pre data-language="python">&gt;&gt;&gt; self.add_data_dir('fun')                       
&gt;&gt;&gt; self.add_data_dir(('sun', 'fun'))              
&gt;&gt;&gt; self.add_data_dir(('gun', '/full/path/to/fun'))
</pre> <p>Will install data-files to the locations:</p> <pre data-language="python">&lt;package install directory&gt;/
  fun/
    foo.dat
    bar/
      car.dat
  sun/
    foo.dat
    bar/
      car.dat
  gun/
    foo.dat
    car.dat
</pre> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.add_include_dirs">
<code>add_include_dirs(*paths)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1341-L1355" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add paths to configuration include directories.</p> <p>Add the given sequence of paths to the beginning of the include_dirs list. This list will be visible to all extension modules of the current package.</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.add_headers">
<code>add_headers(*files)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1357-L1389" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add installable headers to configuration.</p> <p>Add the given sequence of files to the beginning of the headers list. By default, headers will be installed under &lt;python- include&gt;/&lt;self.name.replace(‘.’,’/’)&gt;/ directory. If an item of files is a tuple, then its first argument specifies the actual installation location relative to the &lt;python-include&gt; path.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>files</strong> : str or seq</p>  <p>Argument(s) can be either:</p>  <ul class="simple"> <li>2-sequence (&lt;includedir suffix&gt;,&lt;path to header file(s)&gt;)</li> <li>path(s) to header file(s) where python includedir suffix will default to package name.</li> </ul>   </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.add_extension">
<code>add_extension(name, sources, **kw)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1414-L1515" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add extension to configuration.</p> <p>Create and add an Extension instance to the ext_modules list. This method also takes the following optional keyword arguments that are passed on to the Extension constructor.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>name</strong> : str</p>  <p>name of the extension</p>  <p><strong>sources</strong> : seq</p>  <p>list of the sources. The list of sources may contain functions (called source generators) which must take an extension instance and a build directory as inputs and return a source file or list of source files or None. If None is returned then no sources are generated. If the Extension instance has no sources after processing all source generators, then no extension module is built.</p>  <p><strong>include_dirs :</strong></p> <p><strong>define_macros :</strong></p> <p><strong>undef_macros :</strong></p> <p><strong>library_dirs :</strong></p> <p><strong>libraries :</strong></p> <p><strong>runtime_library_dirs :</strong></p> <p><strong>extra_objects :</strong></p> <p><strong>extra_compile_args :</strong></p> <p><strong>extra_link_args :</strong></p> <p><strong>extra_f77_compile_args :</strong></p> <p><strong>extra_f90_compile_args :</strong></p> <p><strong>export_symbols :</strong></p> <p><strong>swig_opts :</strong></p> <p><strong>depends :</strong></p>  <p>The depends list contains paths to files or directories that the sources of the extension module depend on. If any path in the depends list is newer than the extension module, then the module will be rebuilt.</p>  <p><strong>language :</strong></p> <p><strong>f2py_options :</strong></p> <p><strong>module_dirs :</strong></p> <p><strong>extra_info</strong> : dict or list</p>  <p>dict or list of dict of keywords to be appended to keywords.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The self.paths(…) method is applied to all lists that may contain paths.</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.add_library">
<code>add_library(name, sources, **build_info)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1517-L1551" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add library to configuration.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>name</strong> : str</p>  <p>Name of the extension.</p>  <p><strong>sources</strong> : sequence</p>  <p>List of the sources. The list of sources may contain functions (called source generators) which must take an extension instance and a build directory as inputs and return a source file or list of source files or None. If None is returned then no sources are generated. If the Extension instance has no sources after processing all source generators, then no extension module is built.</p>  <p><strong>build_info</strong> : dict, optional</p>  <p>The following keys are allowed:</p>  <ul class="simple"> <li>depends</li> <li>macros</li> <li>include_dirs</li> <li>extra_compiler_args</li> <li>extra_f77_compile_args</li> <li>extra_f90_compile_args</li> <li>f2py_options</li> <li>language</li> </ul>   </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.add_scripts">
<code>add_scripts(*files)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1694-L1708" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add scripts to configuration.</p> <p>Add the sequence of files to the beginning of the scripts list. Scripts will be installed under the &lt;prefix&gt;/bin/ directory.</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.add_installed_library">
<code>add_installed_library(name, sources, install_dir, build_info=None)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1570-L1619" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Similar to add_library, but the specified library is installed.</p> <p>Most C libraries used with <a class="reference external" href="https://docs.python.org/dev/library/distutils.html#module-distutils" title="(in Python v3.8)" target="_blank"><code>distutils</code></a> are only used to build python extensions, but libraries built through this method will be installed so that they can be reused by third-party packages.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>name</strong> : str</p>  <p>Name of the installed library.</p>  <p><strong>sources</strong> : sequence</p>  <p>List of the library’s source files. See <a class="reference internal" href="#numpy.distutils.misc_util.Configuration.add_library" title="numpy.distutils.misc_util.Configuration.add_library"><code>add_library</code></a> for details.</p>  <p><strong>install_dir</strong> : str</p>  <p>Path to install the library, relative to the current sub-package.</p>  <p><strong>build_info</strong> : dict, optional</p>  <p>The following keys are allowed:</p>  <ul class="simple"> <li>depends</li> <li>macros</li> <li>include_dirs</li> <li>extra_compiler_args</li> <li>extra_f77_compile_args</li> <li>extra_f90_compile_args</li> <li>f2py_options</li> <li>language</li> </ul>   </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last">None</p> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#numpy.distutils.misc_util.Configuration.add_library" title="numpy.distutils.misc_util.Configuration.add_library"><code>add_library</code></a>, <a class="reference internal" href="#numpy.distutils.misc_util.Configuration.add_npy_pkg_config" title="numpy.distutils.misc_util.Configuration.add_npy_pkg_config"><code>add_npy_pkg_config</code></a>, <a class="reference internal" href="#numpy.distutils.misc_util.Configuration.get_info" title="numpy.distutils.misc_util.Configuration.get_info"><code>get_info</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>The best way to encode the options required to link against the specified C libraries is to use a “libname.ini” file, and use <a class="reference internal" href="#numpy.distutils.misc_util.Configuration.get_info" title="numpy.distutils.misc_util.Configuration.get_info"><code>get_info</code></a> to retrieve the required options (see <a class="reference internal" href="#numpy.distutils.misc_util.Configuration.add_npy_pkg_config" title="numpy.distutils.misc_util.Configuration.add_npy_pkg_config"><code>add_npy_pkg_config</code></a> for more information).</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.add_npy_pkg_config">
<code>add_npy_pkg_config(template, install_dir, subst_dict=None)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1621-L1691" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate and install a npy-pkg config file from a template.</p> <p>The config file generated from <code>template</code> is installed in the given install directory, using <code>subst_dict</code> for variable substitution.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>template</strong> : str</p>  <p>The path of the template, relatively to the current package path.</p>  <p><strong>install_dir</strong> : str</p>  <p>Where to install the npy-pkg config file, relatively to the current package path.</p>  <p><strong>subst_dict</strong> : dict, optional</p>  <p>If given, any string of the form <code>@key@</code> will be replaced by <code>subst_dict[key]</code> in the template file when installed. The install prefix is always available through the variable <code>@prefix@</code>, since the install prefix is not easy to get reliably from setup.py.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#numpy.distutils.misc_util.Configuration.add_installed_library" title="numpy.distutils.misc_util.Configuration.add_installed_library"><code>add_installed_library</code></a>, <a class="reference internal" href="#numpy.distutils.misc_util.Configuration.get_info" title="numpy.distutils.misc_util.Configuration.get_info"><code>get_info</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>This works for both standard installs and in-place builds, i.e. the <code>@prefix@</code> refer to the source directory for in-place builds.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">config.add_npy_pkg_config('foo.ini.in', 'lib', {'foo': bar})
</pre> <p>Assuming the foo.ini.in file has the following content:</p> <pre data-language="python">[meta]
Name=@foo@
Version=1.0
Description=dummy description

[default]
Cflags=-I@prefix@/include
Libs=
</pre> <p>The generated file will have the following content:</p> <pre data-language="python">[meta]
Name=bar
Version=1.0
Description=dummy description

[default]
Cflags=-Iprefix_dir/include
Libs=
</pre> <p>and will be installed as foo.ini in the ‘lib’ subpath.</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.paths">
<code>paths(*paths, **kws)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1391-L1404" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply glob to paths and prepend local_path if needed.</p> <p>Applies glob.glob(…) to each path in the sequence (if needed) and pre-pends the local_path if needed. Because this is called on all source lists, this allows wildcard characters to be specified in lists of sources for extension modules and libraries and scripts and allows path-names be relative to the source directory.</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.get_config_cmd">
<code>get_config_cmd()</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1748-L1760" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the numpy.distutils config command instance.</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.get_build_temp_dir">
<code>get_build_temp_dir()</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1762-L1769" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a path to a temporary directory where temporary files should be placed.</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.have_f77c">
<code>have_f77c()</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1771-L1788" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Check for availability of Fortran 77 compiler.</p> <p>Use it inside source generating function to ensure that setup distribution instance has been initialized.</p> <h4 class="rubric">Notes</h4> <p>True if a Fortran 77 compiler is available (because a simple Fortran 77 code was able to be compiled successfully).</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.have_f90c">
<code>have_f90c()</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1790-L1807" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Check for availability of Fortran 90 compiler.</p> <p>Use it inside source generating function to ensure that setup distribution instance has been initialized.</p> <h4 class="rubric">Notes</h4> <p>True if a Fortran 90 compiler is available (because a simple Fortran 90 code was able to be compiled successfully)</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.get_version">
<code>get_version(version_file=None, version_variable=None)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1903-L1971" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Try to get version string of a package.</p> <p>Return a version string of the current package or None if the version information could not be detected.</p> <h4 class="rubric">Notes</h4> <p>This method scans files named __version__.py, &lt;packagename&gt;_version.py, version.py, and __svn_version__.py for string variables version, __version__, and &lt;packagename&gt;_version, until a version number is found.</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.make_svn_version_py">
<code>make_svn_version_py(delete=True)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L1973-L2014" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Appends a data function to the data_files list that will generate __svn_version__.py file to the current package directory.</p> <p>Generate package __svn_version__.py file from SVN revision number, it will be removed after python exits but will be available when sdist, etc commands are executed.</p> <h4 class="rubric">Notes</h4> <p>If __svn_version__.py existed before, nothing is done.</p> <p>This is intended for working with source directories that are in an SVN repository.</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.make_config_py">
<code>make_config_py(name='__config__')</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L2058-L2066" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate package __config__.py file containing system_info information used during building the package.</p> <p>This file is installed to the package installation directory.</p> </dd>
</dl> <dl class="method"> <dt id="numpy.distutils.misc_util.Configuration.get_info">
<code>get_info(*names)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.14.2/numpy/distutils/misc_util.py#L2068-L2078" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get resources information.</p> <p>Return information (from system_info.get_info) for all of the names in the argument list in a single dictionary.</p> </dd>
</dl> </dd>
</dl>   <h3 id="other-modules">Other modules</h3> <table class="longtable docutils">   <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.system_info.get_info/#numpy.distutils.system_info.get_info" title="numpy.distutils.system_info.get_info"><code>system_info.get_info</code></a>(name[, notfound_action])</td> <td>notfound_action:</td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.system_info.get_standard_file/#numpy.distutils.system_info.get_standard_file" title="numpy.distutils.system_info.get_standard_file"><code>system_info.get_standard_file</code></a>(fname)</td> <td>Returns a list of files named ‘fname’ from</td> </tr> <tr>
<td><a class="reference internal" href="../generated/numpy.distutils.cpuinfo.cpu/#numpy.distutils.cpuinfo.cpu" title="numpy.distutils.cpuinfo.cpu"><code>cpuinfo.cpu</code></a></td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="../generated/numpy.distutils.log.set_verbosity/#numpy.distutils.log.set_verbosity" title="numpy.distutils.log.set_verbosity"><code>log.set_verbosity</code></a>(v[, force])</td> <td></td> </tr> <tr>
<td><a class="reference internal" href="../generated/numpy.distutils.exec_command/#module-numpy.distutils.exec_command" title="numpy.distutils.exec_command"><code>exec_command</code></a></td> <td>exec_command</td> </tr>  </table>    <h2 id="building-installable-c-libraries">Building Installable C libraries</h2> <p>Conventional C libraries (installed through <code>add_library</code>) are not installed, and are just used during the build (they are statically linked). An installable C library is a pure C library, which does not depend on the python C runtime, and is installed such that it may be used by third-party packages. To build and install the C library, you just use the method <code>add_installed_library</code> instead of <code>add_library</code>, which takes the same arguments except for an additional <code>install_dir</code> argument:</p> <pre data-language="python">&gt;&gt;&gt; config.add_installed_library('foo', sources=['foo.c'], install_dir='lib')
</pre>  <h3 id="npy-pkg-config-files">npy-pkg-config files</h3> <p>To make the necessary build options available to third parties, you could use the <code>npy-pkg-config</code> mechanism implemented in <a class="reference internal" href="#module-numpy.distutils" title="numpy.distutils"><code>numpy.distutils</code></a>. This mechanism is based on a .ini file which contains all the options. A .ini file is very similar to .pc files as used by the pkg-config unix utility:</p> <pre data-language="python">[meta]
Name: foo
Version: 1.0
Description: foo library

[variables]
prefix = /home/user/local
libdir = ${prefix}/lib
includedir = ${prefix}/include

[default]
cflags = -I${includedir}
libs = -L${libdir} -lfoo
</pre> <p>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the <code>Configuration</code> method <code>add_npy_pkg_config</code>. Assuming we have a template file foo.ini.in as follows:</p> <pre data-language="python">[meta]
Name: foo
Version: @version@
Description: foo library

[variables]
prefix = @prefix@
libdir = ${prefix}/lib
includedir = ${prefix}/include

[default]
cflags = -I${includedir}
libs = -L${libdir} -lfoo
</pre> <p>and the following code in setup.py:</p> <pre data-language="python">&gt;&gt;&gt; config.add_installed_library('foo', sources=['foo.c'], install_dir='lib')
&gt;&gt;&gt; subst = {'version': '1.0'}
&gt;&gt;&gt; config.add_npy_pkg_config('foo.ini.in', 'lib', subst_dict=subst)
</pre> <p>This will install the file foo.ini into the directory package_dir/lib, and the foo.ini file will be generated from foo.ini.in, where each <code>@version@</code> will be replaced by <code>subst_dict['version']</code>. The dictionary has an additional prefix substitution rule automatically added, which contains the install prefix (since this is not easy to get from setup.py). npy-pkg-config files can also be installed at the same location as used for numpy, using the path returned from <code>get_npy_pkg_dir</code> function.</p>   <h3 id="reusing-a-c-library-from-another-package">Reusing a C library from another package</h3> <p>Info are easily retrieved from the <code>get_info</code> function in <a class="reference internal" href="#module-numpy.distutils.misc_util" title="numpy.distutils.misc_util"><code>numpy.distutils.misc_util</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; info = get_info('npymath')
&gt;&gt;&gt; config.add_extension('foo', sources=['foo.c'], extra_info=**info)
</pre> <p>An additional list of paths to look for .ini files can be given to <code>get_info</code>.</p>    <h2 id="conversion-of-src-files">Conversion of <code>.src</code> files</h2> <p>NumPy distutils supports automatic conversion of source files named &lt;somefile&gt;.src. This facility can be used to maintain very similar code blocks requiring only simple changes between blocks. During the build phase of setup, if a template file named &lt;somefile&gt;.src is encountered, a new file named &lt;somefile&gt; is constructed from the template and placed in the build directory to be used instead. Two forms of template conversion are supported. The first form occurs for files named &lt;file&gt;.ext.src where ext is a recognized Fortran extension (f, f90, f95, f77, for, ftn, pyf). The second form is used for all other cases.</p>  <h3 id="index-1">Fortran files</h3> <p id="fortran-files">This template converter will replicate all <strong>function</strong> and <strong>subroutine</strong> blocks in the file with names that contain ‘&lt;…&gt;’ according to the rules in ‘&lt;…&gt;’. The number of comma-separated words in ‘&lt;…&gt;’ determines the number of times the block is repeated. What these words are indicates what that repeat rule, ‘&lt;…&gt;’, should be replaced with in each block. All of the repeat rules in a block must contain the same number of comma-separated words indicating the number of times that block should be repeated. If the word in the repeat rule needs a comma, leftarrow, or rightarrow, then prepend it with a backslash ‘ ‘. If a word in the repeat rule matches ‘ \&lt;index&gt;’ then it will be replaced with the &lt;index&gt;-th word in the same repeat specification. There are two forms for the repeat rule: named and short.</p>  <h4 id="named-repeat-rule">Named repeat rule</h4> <p>A named repeat rule is useful when the same set of repeats must be used several times in a block. It is specified using &lt;rule1=item1, item2, item3,…, itemN&gt;, where N is the number of times the block should be repeated. On each repeat of the block, the entire expression, ‘&lt;…&gt;’ will be replaced first with item1, and then with item2, and so forth until N repeats are accomplished. Once a named repeat specification has been introduced, the same repeat rule may be used <strong>in the current block</strong> by referring only to the name (i.e. &lt;rule1&gt;.</p>   <h4 id="short-repeat-rule">Short repeat rule</h4> <p>A short repeat rule looks like &lt;item1, item2, item3, …, itemN&gt;. The rule specifies that the entire expression, ‘&lt;…&gt;’ should be replaced first with item1, and then with item2, and so forth until N repeats are accomplished.</p>   <h4 id="pre-defined-names">Pre-defined names</h4> <p>The following predefined named repeat rules are available:</p> <ul class="simple"> <li>&lt;prefix=s,d,c,z&gt;</li> <li>&lt;_c=s,d,c,z&gt;</li> <li>&lt;_t=real, double precision, complex, double complex&gt;</li> <li>&lt;ftype=real, double precision, complex, double complex&gt;</li> <li>&lt;ctype=float, double, complex_float, complex_double&gt;</li> <li>&lt;ftypereal=float, double precision, \0, \1&gt;</li> <li>&lt;ctypereal=float, double, \0, \1&gt;</li> </ul>    <h3 id="other-files">Other files</h3> <p>Non-Fortran files use a separate syntax for defining template blocks that should be repeated using a variable expansion similar to the named repeat rules of the Fortran-specific repeats. The template rules for these files are:</p> <ol class="arabic simple"> <li>“/**begin repeat “on a line by itself marks the beginning of a segment that should be repeated.</li> <li>Named variable expansions are defined using #name=item1, item2, item3, …, itemN# and placed on successive lines. These variables are replaced in each repeat block with corresponding word. All named variables in the same repeat block must define the same number of words.</li> <li>In specifying the repeat rule for a named variable, item*N is short- hand for item, item, …, item repeated N times. In addition, parenthesis in combination with *N can be used for grouping several items that should be repeated. Thus, #name=(item1, item2)*4# is equivalent to #name=item1, item2, item1, item2, item1, item2, item1, item2#</li> <li>“*/ “on a line by itself marks the end of the variable expansion naming. The next line is the first line that will be repeated using the named rules.</li> <li>Inside the block to be repeated, the variables that should be expanded are specified as @name@.</li> <li>“/**end repeat**/ “on a line by itself marks the previous line as the last line of the block to be repeated.</li> </ol>
<div class="_attribution">
  <p class="_attribution-p">
    © 2008–2017 NumPy Developers<br>Licensed under the NumPy License.<br>
    <a href="https://docs.scipy.org/doc/numpy-1.14.2/reference/distutils.html" class="_attribution-link" target="_blank">https://docs.scipy.org/doc/numpy-1.14.2/reference/distutils.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
