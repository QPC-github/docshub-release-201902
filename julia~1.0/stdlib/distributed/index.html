
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Distributed Computing - Julia 1.0 - W3cubDocs</title>
  
  <meta name="description" content=" Launches worker processes via the specified cluster manager. ">
  <meta name="keywords" content="distributed, computing, -, julia, julia~1.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia~1.0/stdlib/distributed/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/julia~1.0.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia~1.0/" class="_nav-link" title="" style="margin-left:0;">Julia 1.0</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _julia">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1 id="Distributed-Computing-1">Distributed Computing</h1>
<h3 id="Distributed.addprocs">
<code>Distributed.addprocs</code><span class="docstring-category">Function</span>
</h3>
<pre>addprocs(manager::ClusterManager; kwargs...) -&gt; List of process identifiers</pre>
<p>Launches worker processes via the specified cluster manager.</p>
<p>For example, Beowulf clusters are supported via a custom cluster manager implemented in the package <code>ClusterManagers.jl</code>.</p>
<p>The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable <code>JULIA_WORKER_TIMEOUT</code> in the worker process's environment. Relevant only when using TCP/IP as transport.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L350-L361">source</a><pre>addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -&gt; List of process identifiers</pre>
<p>Add processes on remote machines via SSH. Requires <code>julia</code> to be installed in the same location on each node, or to be available via a shared file system.</p>
<p><code>machines</code> is a vector of machine specifications. Workers are started for each specification.</p>
<p>A machine specification is either a string <code>machine_spec</code> or a tuple - <code>(machine_spec, count)</code>.</p>
<p><code>machine_spec</code> is a string of the form <code>[user@]host[:port] [bind_addr[:port]]</code>. <code>user</code> defaults to current user, <code>port</code> to the standard ssh port. If <code>[bind_addr[:port]]</code> is specified, other workers will connect to this worker at the specified <code>bind_addr</code> and <code>port</code>.</p>
<p><code>count</code> is the number of workers to be launched on the specified host. If specified as <code>:auto</code> it will launch as many workers as the number of CPU threads on the specific host.</p>
<p>Keyword arguments:</p>
<ul>
<li><p><code>tunnel</code>: if <code>true</code> then SSH tunneling will be used to connect to the worker from the master process. Default is <code>false</code>.</p></li>
<li><p><code>sshflags</code>: specifies additional ssh options, e.g. <code>sshflags=`-i /home/foo/bar.pem</code>`</p></li>
<li><p><code>max_parallel</code>: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.</p></li>
<li><p><code>dir</code>: specifies the working directory on the workers. Defaults to the host's current directory (as found by <code>pwd()</code>)</p></li>
<li><p><code>enable_threaded_blas</code>: if <code>true</code> then BLAS will run on multiple threads in added processes. Default is <code>false</code>.</p></li>
<li><p><code>exename</code>: name of the <code>julia</code> executable. Defaults to <code>"$(Sys.BINDIR)/julia"</code> or <code>"$(Sys.BINDIR)/julia-debug"</code> as the case may be.</p></li>
<li><p><code>exeflags</code>: additional flags passed to the worker processes.</p></li>
<li>
<p><code>topology</code>: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.</p>
<ul>
<li><p><code>topology=:all_to_all</code>: All processes are connected to each other. The default.</p></li>
<li><p><code>topology=:master_worker</code>: Only the driver process, i.e. <code>pid</code> 1 connects to the workers. The workers do not connect to each other.</p></li>
<li><p><code>topology=:custom</code>: The <code>launch</code> method of the cluster manager specifies the connection topology via fields <code>ident</code> and <code>connect_idents</code> in <code>WorkerConfig</code>. A worker with a cluster manager identity <code>ident</code> will connect to all workers specified in <code>connect_idents</code>.</p></li>
</ul>
</li>
<li><p><code>lazy</code>: Applicable only with <code>topology=:all_to_all</code>. If <code>true</code>, worker-worker connections are setup lazily, i.e. they are setup at the first instance of a remote call between workers. Default is true.</p></li>
</ul>
<p>Environment variables :</p>
<p>If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable <code>JULIA_WORKER_TIMEOUT</code>. The value of <code>JULIA_WORKER_TIMEOUT</code> on the master process specifies the number of seconds a newly launched worker waits for connection establishment.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/managers.jl#L51-L115">source</a><pre>addprocs(; kwargs...) -&gt; List of process identifiers</pre>
<p>Equivalent to <code>addprocs(Sys.CPU_THREADS; kwargs...)</code></p>
<p>Note that workers do not run a <code>.julia/config/startup.jl</code> startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/managers.jl#L294-L302">source</a><pre>addprocs(np::Integer; restrict=true, kwargs...) -&gt; List of process identifiers</pre>
<p>Launches workers using the in-built <code>LocalManager</code> which only launches workers on the local host. This can be used to take advantage of multiple cores. <code>addprocs(4)</code> will add 4 processes on the local machine. If <code>restrict</code> is <code>true</code>, binding is restricted to <code>127.0.0.1</code>. Keyword args <code>dir</code>, <code>exename</code>, <code>exeflags</code>, <code>topology</code>, <code>lazy</code> and <code>enable_threaded_blas</code> have the same effect as documented for <code>addprocs(machines)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/managers.jl#L305-L313">source</a><h3 id="Distributed.nprocs">
<code>Distributed.nprocs</code><span class="docstring-category">Function</span>
</h3>
<pre>nprocs()</pre>
<p>Get the number of available processes.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; nprocs()
3

julia&gt; workers()
5-element Array{Int64,1}:
 2
 3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L735-L750">source</a><h3 id="Distributed.nworkers">
<code>Distributed.nworkers</code><span class="docstring-category">Function</span>
</h3>
<pre>nworkers()</pre>
<p>Get the number of available worker processes. This is one less than <a href="#Distributed.nprocs"><code>nprocs()</code></a>. Equal to <code>nprocs()</code> if <code>nprocs() == 1</code>.</p>
<p><strong>Examples</strong></p>
<pre>$ julia -p 5

julia&gt; nprocs()
6

julia&gt; nworkers()
5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L766-L782">source</a><h3 id="Distributed.procs-Tuple{}">
<code>Distributed.procs</code><span class="docstring-category">Method</span>
</h3>
<pre>procs()</pre>
<p>Return a list of all process identifiers, including pid 1 (which is not included by <a href="#Distributed.workers"><code>workers()</code></a>).</p>
<p><strong>Examples</strong></p>
<pre>$ julia -p 5

julia&gt; procs()
3-element Array{Int64,1}:
 1
 2
 3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L788-L803">source</a><h3 id="Distributed.procs-Tuple{Integer}">
<code>Distributed.procs</code><span class="docstring-category">Method</span>
</h3>
<pre>procs(pid::Integer)</pre>
<p>Return a list of all process identifiers on the same physical node. Specifically all workers bound to the same ip-address as <code>pid</code> are returned.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L830-L835">source</a><h3 id="Distributed.workers">
<code>Distributed.workers</code><span class="docstring-category">Function</span>
</h3>
<pre>workers()</pre>
<p>Return a list of all worker process identifiers.</p>
<p><strong>Examples</strong></p>
<pre>$ julia -p 5

julia&gt; workers()
2-element Array{Int64,1}:
 2
 3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L850-L864">source</a><h3 id="Distributed.rmprocs">
<code>Distributed.rmprocs</code><span class="docstring-category">Function</span>
</h3>
<pre>rmprocs(pids...; waitfor=typemax(Int))</pre>
<p>Remove the specified workers. Note that only process 1 can add or remove workers.</p>
<p>Argument <code>waitfor</code> specifies how long to wait for the workers to shut down:</p>
<ul>
<li>If unspecified, <code>rmprocs</code> will wait until all requested <code>pids</code> are removed.</li>
<li>An <a href="https://docs.julialang.org/en/v1.0.1/base/base/#Core.ErrorException" target="_blank"><code>ErrorException</code></a> is raised if all workers cannot be terminated before the requested <code>waitfor</code> seconds.</li>
<li>With a <code>waitfor</code> value of 0, the call returns immediately with the workers scheduled for removal in a different task. The scheduled <a href="https://docs.julialang.org/en/v1.0.1/base/parallel/#Core.Task" target="_blank"><code>Task</code></a> object is returned. The user should call <a href="#Base.wait"><code>wait</code></a> on the task before invoking any other parallel calls.</li>
</ul>
<p><strong>Examples</strong></p>
<pre>$ julia -p 5

julia&gt; t = rmprocs(2, 3, waitfor=0)
Task (runnable) @0x0000000107c718d0

julia&gt; wait(t)

julia&gt; workers()
3-element Array{Int64,1}:
 4
 5
 6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L880-L910">source</a><h3 id="Distributed.interrupt">
<code>Distributed.interrupt</code><span class="docstring-category">Function</span>
</h3>
<pre>interrupt(pids::Integer...)</pre>
<p>Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L1082-L1087">source</a><pre>interrupt(pids::AbstractVector=workers())</pre>
<p>Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L1090-L1095">source</a><h3 id="Distributed.myid">
<code>Distributed.myid</code><span class="docstring-category">Function</span>
</h3>
<pre>myid()</pre>
<p>Get the id of the current process.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; myid()
1

julia&gt; remotecall_fetch(() -&gt; myid(), 4)
4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L719-L732">source</a><h3 id="Distributed.pmap">
<code>Distributed.pmap</code><span class="docstring-category">Function</span>
</h3>
<pre>pmap(f, [::AbstractWorkerPool], c...; distributed=true, batch_size=1, on_error=nothing, retry_delays=[], retry_check=nothing) -&gt; collection</pre>
<p>Transform collection <code>c</code> by applying <code>f</code> to each element using available workers and tasks.</p>
<p>For multiple collection arguments, apply <code>f</code> elementwise.</p>
<p>Note that <code>f</code> must be made available to all worker processes; see <a href="../../manual/parallel-computing/#Code-Availability-and-Loading-Packages-1">Code Availability and Loading Packages</a> for details.</p>
<p>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</p>
<p>By default, <code>pmap</code> distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify <code>distributed=false</code>. This is equivalent to using <a href="https://docs.julialang.org/en/v1.0.1/base/parallel/#Base.asyncmap" target="_blank"><code>asyncmap</code></a>. For example, <code>pmap(f, c; distributed=false)</code> is equivalent to <code>asyncmap(f,c; ntasks=()-&gt;nworkers())</code></p>
<p><code>pmap</code> can also use a mix of processes and tasks via the <code>batch_size</code> argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length <code>batch_size</code> or less. A batch is sent as a single request to a free worker, where a local <a href="https://docs.julialang.org/en/v1.0.1/base/parallel/#Base.asyncmap" target="_blank"><code>asyncmap</code></a> processes elements from the batch using multiple concurrent tasks.</p>
<p>Any error stops <code>pmap</code> from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument <code>on_error</code> which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.</p>
<p>Consider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:</p>
<pre>julia&gt; pmap(x-&gt;iseven(x) ? error("foo") : x, 1:4; on_error=identity)
4-element Array{Any,1}:
 1
  ErrorException("foo")
 3
  ErrorException("foo")

julia&gt; pmap(x-&gt;iseven(x) ? error("foo") : x, 1:4; on_error=ex-&gt;0)
4-element Array{Int64,1}:
 1
 0
 3
 0</pre>
<p>Errors can also be handled by retrying failed computations. Keyword arguments <code>retry_delays</code> and <code>retry_check</code> are passed through to <a href="https://docs.julialang.org/en/v1.0.1/base/base/#Base.retry" target="_blank"><code>retry</code></a> as keyword arguments <code>delays</code> and <code>check</code> respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.</p>
<p>Note that if both <code>on_error</code> and <code>retry_delays</code> are specified, the <code>on_error</code> hook is called before retrying. If <code>on_error</code> does not throw (or rethrow) an exception, the element will not be retried.</p>
<p>Example: On errors, retry <code>f</code> on an element a maximum of 3 times without any delay between retries.</p>
<pre>pmap(f, c; retry_delays = zeros(3))</pre>
<p>Example: Retry <code>f</code> only if the exception is not of type <code>InexactError</code>, with exponentially increasing delays up to 3 times. Return a <code>NaN</code> in place for all <code>InexactError</code> occurrences.</p>
<pre>pmap(f, c; on_error = e-&gt;(isa(e, InexactError) ? NaN : rethrow(e)), retry_delays = ExponentialBackOff(n = 3))</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/pmap.jl#L32-L98">source</a><h3 id="Distributed.RemoteException">
<code>Distributed.RemoteException</code><span class="docstring-category">Type</span>
</h3>
<pre>RemoteException(captured)</pre>
<p>Exceptions on remote computations are captured and rethrown locally. A <code>RemoteException</code> wraps the <code>pid</code> of the worker and a captured exception. A <code>CapturedException</code> captures the remote exception and a serializable form of the call stack when the exception was raised.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/process_messages.jl#L24-L30">source</a><h3 id="Distributed.Future">
<code>Distributed.Future</code><span class="docstring-category">Type</span>
</h3>
<pre>Future(pid::Integer=myid())</pre>
<p>Create a <code>Future</code> on process <code>pid</code>. The default <code>pid</code> is the current process.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L15-L20">source</a><h3 id="Distributed.RemoteChannel">
<code>Distributed.RemoteChannel</code><span class="docstring-category">Type</span>
</h3>
<pre>RemoteChannel(pid::Integer=myid())</pre>
<p>Make a reference to a <code>Channel{Any}(1)</code> on process <code>pid</code>. The default <code>pid</code> is the current process.</p>
<pre>RemoteChannel(f::Function, pid::Integer=myid())</pre>
<p>Create references to remote channels of a specific size and type. <code>f</code> is a function that when executed on <code>pid</code> must return an implementation of an <code>AbstractChannel</code>.</p>
<p>For example, <code>RemoteChannel(()-&gt;Channel{Int}(10), pid)</code>, will return a reference to a channel of type <code>Int</code> and size 10 on <code>pid</code>.</p>
<p>The default <code>pid</code> is the current process.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L33-L48">source</a><h3 id="Base.wait">
<code>Base.wait</code><span class="docstring-category">Function</span>
</h3>
<pre>wait([x])</pre>
<p>Block the current task until some event occurs, depending on the type of the argument:</p>
<ul>
<li>
<a href="https://docs.julialang.org/en/v1.0.1/base/parallel/#Base.Channel" target="_blank"><code>Channel</code></a>: Wait for a value to be appended to the channel.</li>
<li>
<a href="https://docs.julialang.org/en/v1.0.1/base/parallel/#Base.Condition" target="_blank"><code>Condition</code></a>: Wait for <a href="https://docs.julialang.org/en/v1.0.1/base/parallel/#Base.notify" target="_blank"><code>notify</code></a> on a condition.</li>
<li>
<code>Process</code>: Wait for a process or process chain to exit. The <code>exitcode</code> field of a process can be used to determine success or failure.</li>
<li>
<a href="https://docs.julialang.org/en/v1.0.1/base/parallel/#Core.Task" target="_blank"><code>Task</code></a>: Wait for a <code>Task</code> to finish. If the task fails with an exception, the exception is propagated (re-thrown in the task that called <code>wait</code>).</li>
<li>
<a href="https://docs.julialang.org/en/v1.0.1/base/file/#Base.Libc.RawFD" target="_blank"><code>RawFD</code></a>: Wait for changes on a file descriptor (see the <code>FileWatching</code> package).</li>
</ul>
<p>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to <a href="https://docs.julialang.org/en/v1.0.1/base/parallel/#Base.schedule" target="_blank"><code>schedule</code></a> or <a href="https://docs.julialang.org/en/v1.0.1/base/parallel/#Base.yieldto" target="_blank"><code>yieldto</code></a>.</p>
<p>Often <code>wait</code> is called within a <code>while</code> loop to ensure a waited-for condition is met before proceeding.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/event.jl#L21-L39">source</a><pre>wait(r::Future)</pre>
<p>Wait for a value to become available for the specified <a href="#Distributed.Future"><code>Future</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L495-L499">source</a><pre>wait(r::RemoteChannel, args...)</pre>
<p>Wait for a value to become available on the specified <a href="#Distributed.RemoteChannel"><code>RemoteChannel</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L502-L506">source</a><h3 id="Base.fetch-Tuple{Any}">
<code>Base.fetch</code><span class="docstring-category">Method</span>
</h3>
<pre>fetch(x)</pre>
<p>Waits and fetches a value from <code>x</code> depending on the type of <code>x</code>:</p>
<ul>
<li>
<a href="#Distributed.Future"><code>Future</code></a>: Wait for and get the value of a <code>Future</code>. The fetched value is cached locally. Further calls to <code>fetch</code> on the same reference return the cached value. If the remote value is an exception, throws a <a href="#Distributed.RemoteException"><code>RemoteException</code></a> which captures the remote exception and backtrace.</li>
<li>
<a href="#Distributed.RemoteChannel"><code>RemoteChannel</code></a>: Wait for and get the value of a remote reference. Exceptions raised are same as for a <code>Future</code> .</li>
</ul>
<p>Does not remove the item fetched.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L520-L532">source</a><h3 id="Distributed.remotecall-Tuple{Any,Integer,Vararg{Any,N} where N}">
<code>Distributed.remotecall</code><span class="docstring-category">Method</span>
</h3>
<pre>remotecall(f, id::Integer, args...; kwargs...) -&gt; Future</pre>
<p>Call a function <code>f</code> asynchronously on the given arguments on the specified process. Return a <a href="#Distributed.Future"><code>Future</code></a>. Keyword arguments, if any, are passed through to <code>f</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L354-L360">source</a><h3 id="Distributed.remotecall_wait-Tuple{Any,Integer,Vararg{Any,N} where N}">
<code>Distributed.remotecall_wait</code><span class="docstring-category">Method</span>
</h3>
<pre>remotecall_wait(f, id::Integer, args...; kwargs...)</pre>
<p>Perform a faster <code>wait(remotecall(...))</code> in one message on the <code>Worker</code> specified by worker id <code>id</code>. Keyword arguments, if any, are passed through to <code>f</code>.</p>
<p>See also <a href="#Base.wait"><code>wait</code></a> and <a href="#Distributed.remotecall-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D"><code>remotecall</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L425-L432">source</a><h3 id="Distributed.remotecall_fetch-Tuple{Any,Integer,Vararg{Any,N} where N}">
<code>Distributed.remotecall_fetch</code><span class="docstring-category">Method</span>
</h3>
<pre>remotecall_fetch(f, id::Integer, args...; kwargs...)</pre>
<p>Perform <code>fetch(remotecall(...))</code> in one message. Keyword arguments, if any, are passed through to <code>f</code>. Any remote exceptions are captured in a <a href="#Distributed.RemoteException"><code>RemoteException</code></a> and thrown.</p>
<p>See also <a href="#"><code>fetch</code></a> and <a href="#Distributed.remotecall-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D"><code>remotecall</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>$ julia -p 2

julia&gt; remotecall_fetch(sqrt, 2, 4)
2.0

julia&gt; remotecall_fetch(sqrt, 2, -4)
ERROR: On worker 2:
DomainError with -4.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
...</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L382-L405">source</a><h3 id="Distributed.remote_do-Tuple{Any,Integer,Vararg{Any,N} where N}">
<code>Distributed.remote_do</code><span class="docstring-category">Method</span>
</h3>
<pre>remote_do(f, id::Integer, args...; kwargs...) -&gt; nothing</pre>
<p>Executes <code>f</code> on worker <code>id</code> asynchronously. Unlike <a href="#Distributed.remotecall-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D"><code>remotecall</code></a>, it does not store the result of computation, nor is there a way to wait for its completion.</p>
<p>A successful invocation indicates that the request has been accepted for execution on the remote node.</p>
<p>While consecutive <code>remotecall</code>s to the same worker are serialized in the order they are invoked, the order of executions on the remote worker is undetermined. For example, <code>remote_do(f1, 2); remotecall(f2, 2); remote_do(f3, 2)</code> will serialize the call to <code>f1</code>, followed by <code>f2</code> and <code>f3</code> in that order. However, it is not guaranteed that <code>f1</code> is executed before <code>f3</code> on worker 2.</p>
<p>Any exceptions thrown by <code>f</code> are printed to <a href="https://docs.julialang.org/en/v1.0.1/base/io-network/#Base.stderr" target="_blank"><code>stderr</code></a> on the remote worker.</p>
<p>Keyword arguments, if any, are passed through to <code>f</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L451-L470">source</a><h3 id="Base.put!-Tuple{RemoteChannel,Vararg{Any,N} where N}">
<code>Base.put!</code><span class="docstring-category">Method</span>
</h3>
<pre>put!(rr::RemoteChannel, args...)</pre>
<p>Store a set of values to the <a href="#Distributed.RemoteChannel"><code>RemoteChannel</code></a>. If the channel is full, blocks until space is available. Return the first argument.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L565-L571">source</a><h3 id="Base.put!-Tuple{Future,Any}">
<code>Base.put!</code><span class="docstring-category">Method</span>
</h3>
<pre>put!(rr::Future, v)</pre>
<p>Store a value to a <a href="#Distributed.Future"><code>Future</code></a> <code>rr</code>. <code>Future</code>s are write-once remote references. A <code>put!</code> on an already set <code>Future</code> throws an <code>Exception</code>. All asynchronous remote calls return <code>Future</code>s and set the value to the return value of the call upon completion.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L537-L545">source</a><h3 id="Base.take!-Tuple{RemoteChannel,Vararg{Any,N} where N}">
<code>Base.take!</code><span class="docstring-category">Method</span>
</h3>
<pre>take!(rr::RemoteChannel, args...)</pre>
<p>Fetch value(s) from a <a href="#Distributed.RemoteChannel"><code>RemoteChannel</code></a> <code>rr</code>, removing the value(s) in the process.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L583-L588">source</a><h3 id="Base.isready-Tuple{RemoteChannel,Vararg{Any,N} where N}">
<code>Base.isready</code><span class="docstring-category">Method</span>
</h3>
<pre>isready(rr::RemoteChannel, args...)</pre>
<p>Determine whether a <a href="#Distributed.RemoteChannel"><code>RemoteChannel</code></a> has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a <a href="#Distributed.Future"><code>Future</code></a> since they are assigned only once.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L195-L202">source</a><h3 id="Base.isready-Tuple{Future}">
<code>Base.isready</code><span class="docstring-category">Method</span>
</h3>
<pre>isready(rr::Future)</pre>
<p>Determine whether a <a href="#Distributed.Future"><code>Future</code></a> has a value stored to it.</p>
<p>If the argument <code>Future</code> is owned by a different node, this call will block to wait for the answer. It is recommended to wait for <code>rr</code> in a separate task instead or to use a local <a href="https://docs.julialang.org/en/v1.0.1/base/parallel/#Base.Channel" target="_blank"><code>Channel</code></a> as a proxy:</p>
<pre>c = Channel(1)
@async put!(c, remotecall_fetch(long_computation, p))
isready(c)  # will not block</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L171-L183">source</a><h3 id="Distributed.WorkerPool">
<code>Distributed.WorkerPool</code><span class="docstring-category">Type</span>
</h3>
<pre>WorkerPool(workers::Vector{Int})</pre>
<p>Create a <code>WorkerPool</code> from a vector of worker ids.</p>
<p><strong>Examples</strong></p>
<pre>$ julia -p 3

julia&gt; WorkerPool([2, 3])
WorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:2), Set([2, 3]), RemoteChannel{Channel{Any}}(1, 1, 6))</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/workerpool.jl#L32-L44">source</a><h3 id="Distributed.CachingPool">
<code>Distributed.CachingPool</code><span class="docstring-category">Type</span>
</h3>
<pre>CachingPool(workers::Vector{Int})</pre>
<p>An implementation of an <code>AbstractWorkerPool</code>. <a href="#Distributed.remote"><code>remote</code></a>, <a href="#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D"><code>remotecall_fetch</code></a>, <a href="#Distributed.pmap"><code>pmap</code></a> (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).</p>
<p>The remote cache is maintained for the lifetime of the returned <code>CachingPool</code> object. To clear the cache earlier, use <code>clear!(pool)</code>.</p>
<p>For global variables, only the bindings are captured in a closure, not the data. <code>let</code> blocks can be used to capture global data.</p>
<p><strong>Examples</strong></p>
<pre>const foo = rand(10^8);
wp = CachingPool(workers())
let foo = foo
    pmap(wp, i -&gt; sum(foo) + i, 1:100);
end</pre>
<p>The above would transfer <code>foo</code> only once to each worker.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/workerpool.jl#L289-L315">source</a><h3 id="Distributed.default_worker_pool">
<code>Distributed.default_worker_pool</code><span class="docstring-category">Function</span>
</h3>
<pre>default_worker_pool()</pre>
<p><a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> containing idle <a href="#Distributed.workers"><code>workers</code></a> - used by <code>remote(f)</code> and <a href="#Distributed.pmap"><code>pmap</code></a> (by default).</p>
<p><strong>Examples</strong></p>
<pre>$ julia -p 3

julia&gt; default_worker_pool()
WorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:3), Set([4, 2, 3]), RemoteChannel{Channel{Any}}(1, 1, 4))</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/workerpool.jl#L238-L250">source</a><h3 id="Distributed.clear!-Tuple{CachingPool}">
<code>Distributed.clear!</code><span class="docstring-category">Method</span>
</h3>
<pre>clear!(pool::CachingPool) -&gt; pool</pre>
<p>Removes all cached functions from all participating workers.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/workerpool.jl#L324-L328">source</a><h3 id="Distributed.remote">
<code>Distributed.remote</code><span class="docstring-category">Function</span>
</h3>
<pre>remote([p::AbstractWorkerPool], f) -&gt; Function</pre>
<p>Return an anonymous function that executes function <code>f</code> on an available worker (drawn from <a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> <code>p</code> if provided) using <a href="#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D"><code>remotecall_fetch</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/workerpool.jl#L264-L269">source</a><h3 id="Distributed.remotecall-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}">
<code>Distributed.remotecall</code><span class="docstring-category">Method</span>
</h3>
<pre>remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -&gt; Future</pre>
<p><a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> variant of <code>remotecall(f, pid, ....)</code>. Wait for and take a free worker from <code>pool</code> and perform a <code>remotecall</code> on it.</p>
<p><strong>Examples</strong></p>
<pre>$ julia -p 3

julia&gt; wp = WorkerPool([2, 3]);

julia&gt; A = rand(3000);

julia&gt; f = remotecall(maximum, wp, A)
Future(2, 1, 6, nothing)</pre>
<p>In this example, the task ran on pid 2, called from pid 1.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/workerpool.jl#L163-L180">source</a><h3 id="Distributed.remotecall_wait-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}">
<code>Distributed.remotecall_wait</code><span class="docstring-category">Method</span>
</h3>
<pre>remotecall_wait(f, pool::AbstractWorkerPool, args...; kwargs...) -&gt; Future</pre>
<p><a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> variant of <code>remotecall_wait(f, pid, ....)</code>. Wait for and take a free worker from <code>pool</code> and perform a <code>remotecall_wait</code> on it.</p>
<p><strong>Examples</strong></p>
<pre>$ julia -p 3

julia&gt; wp = WorkerPool([2, 3]);

julia&gt; A = rand(3000);

julia&gt; f = remotecall_wait(maximum, wp, A)
Future(3, 1, 9, nothing)

julia&gt; fetch(f)
0.9995177101692958</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/workerpool.jl#L184-L204">source</a><h3 id="Distributed.remotecall_fetch-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}">
<code>Distributed.remotecall_fetch</code><span class="docstring-category">Method</span>
</h3>
<pre>remotecall_fetch(f, pool::AbstractWorkerPool, args...; kwargs...) -&gt; result</pre>
<p><a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> variant of <code>remotecall_fetch(f, pid, ....)</code>. Waits for and takes a free worker from <code>pool</code> and performs a <code>remotecall_fetch</code> on it.</p>
<p><strong>Examples</strong></p>
<pre>$ julia -p 3

julia&gt; wp = WorkerPool([2, 3]);

julia&gt; A = rand(3000);

julia&gt; remotecall_fetch(maximum, wp, A)
0.9995177101692958</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/workerpool.jl#L208-L225">source</a><h3 id="Distributed.remote_do-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}">
<code>Distributed.remote_do</code><span class="docstring-category">Method</span>
</h3>
<pre>remote_do(f, pool::AbstractWorkerPool, args...; kwargs...) -&gt; nothing</pre>
<p><a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> variant of <code>remote_do(f, pid, ....)</code>. Wait for and take a free worker from <code>pool</code> and perform a <code>remote_do</code> on it.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/workerpool.jl#L228-L233">source</a><h3 id="Base.timedwait">
<code>Base.timedwait</code><span class="docstring-category">Function</span>
</h3>
<pre>timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)</pre>
<p>Waits until <code>testcb</code> returns <code>true</code> or for <code>secs</code> seconds, whichever is earlier. <code>testcb</code> is polled every <code>pollint</code> seconds.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/task.jl#L324-L329">source</a><h3 id="Distributed.@spawn">
<code>Distributed.@spawn</code><span class="docstring-category">Macro</span>
</h3>
<pre>@spawn</pre>
<p>Create a closure around an expression and run it on an automatically-chosen process, returning a <a href="#Distributed.Future"><code>Future</code></a> to the result.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; addprocs(3);

julia&gt; f = @spawn myid()
Future(2, 1, 5, nothing)

julia&gt; fetch(f)
2

julia&gt; f = @spawn myid()
Future(3, 1, 7, nothing)

julia&gt; fetch(f)
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/macros.jl#L19-L41">source</a><h3 id="Distributed.@spawnat">
<code>Distributed.@spawnat</code><span class="docstring-category">Macro</span>
</h3>
<pre>@spawnat</pre>
<p>Create a closure around an expression and run the closure asynchronously on process <code>p</code>. Return a <a href="#Distributed.Future"><code>Future</code></a> to the result. Accepts two arguments, <code>p</code> and an expression.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; addprocs(1);

julia&gt; f = @spawnat 2 myid()
Future(2, 1, 3, nothing)

julia&gt; fetch(f)
2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/macros.jl#L54-L71">source</a><h3 id="Distributed.@fetch">
<code>Distributed.@fetch</code><span class="docstring-category">Macro</span>
</h3>
<pre>@fetch</pre>
<p>Equivalent to <code>fetch(@spawn expr)</code>. See <a href="#"><code>fetch</code></a> and <a href="#Distributed.@spawn"><code>@spawn</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; addprocs(3);

julia&gt; @fetch myid()
2

julia&gt; @fetch myid()
3

julia&gt; @fetch myid()
4

julia&gt; @fetch myid()
2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/macros.jl#L84-L106">source</a><h3 id="Distributed.@fetchfrom">
<code>Distributed.@fetchfrom</code><span class="docstring-category">Macro</span>
</h3>
<pre>@fetchfrom</pre>
<p>Equivalent to <code>fetch(@spawnat p expr)</code>. See <a href="#"><code>fetch</code></a> and <a href="#Distributed.@spawnat"><code>@spawnat</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; addprocs(3);

julia&gt; @fetchfrom 2 myid()
2

julia&gt; @fetchfrom 4 myid()
4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/macros.jl#L112-L128">source</a><h3 id="Base.@async">
<code>Base.@async</code><span class="docstring-category">Macro</span>
</h3>
<pre>@async</pre>
<p>Wrap an expression in a <a href="https://docs.julialang.org/en/v1.0.1/base/parallel/#Core.Task" target="_blank"><code>Task</code></a> and add it to the local machine's scheduler queue.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/task.jl#L253-L257">source</a><h3 id="Base.@sync">
<code>Base.@sync</code><span class="docstring-category">Macro</span>
</h3>
<pre>@sync</pre>
<p>Wait until all lexically-enclosed uses of <code>@async</code>, <code>@spawn</code>, <code>@spawnat</code> and <code>@distributed</code> are complete. All exceptions thrown by enclosed async operations are collected and thrown as a <code>CompositeException</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/task.jl#L233-L239">source</a><h3 id="Distributed.@distributed">
<code>Distributed.@distributed</code><span class="docstring-category">Macro</span>
</h3>
<pre>@distributed</pre>
<p>A distributed memory, parallel for loop of the form :</p>
<pre>@distributed [reducer] for var = range
    body
end</pre>
<p>The specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, <code>@distributed</code> performs local reductions on each worker with a final reduction on the calling process.</p>
<p>Note that without a reducer function, <code>@distributed</code> executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with <a href="#Base.@sync"><code>@sync</code></a>, like :</p>
<pre>@sync @distributed for var = range
    body
end</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/macros.jl#L297-L317">source</a><h3 id="Distributed.@everywhere">
<code>Distributed.@everywhere</code><span class="docstring-category">Macro</span>
</h3>
<pre>@everywhere [procs()] expr</pre>
<p>Execute an expression under <code>Main</code> on all <code>procs</code>. Errors on any of the processes are collected into a <code>CompositeException</code> and thrown. For example:</p>
<pre>@everywhere bar = 1</pre>
<p>will define <code>Main.bar</code> on all processes.</p>
<p>Unlike <a href="#Distributed.@spawn"><code>@spawn</code></a> and <a href="#Distributed.@spawnat"><code>@spawnat</code></a>, <code>@everywhere</code> does not capture any local variables. Instead, local variables can be broadcast using interpolation:</p>
<pre>foo = 1
@everywhere bar = $foo</pre>
<p>The optional argument <code>procs</code> allows specifying a subset of all processes to have execute the expression.</p>
<p>Equivalent to calling <code>remotecall_eval(Main, procs, expr)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/macros.jl#L157-L179">source</a><h3 id="Distributed.clear!-Tuple{Any,Any}">
<code>Distributed.clear!</code><span class="docstring-category">Method</span>
</h3>
<pre>clear!(syms, pids=workers(); mod=Main)</pre>
<p>Clears global bindings in modules by initializing them to <code>nothing</code>. <code>syms</code> should be of type <code>Symbol</code> or a collection of <code>Symbol</code>s . <code>pids</code> and <code>mod</code> identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under <code>mod</code> are cleared.</p>
<p>An exception is raised if a global constant is requested to be cleared.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/clusterserialize.jl#L250-L259">source</a><h3 id="Distributed.remoteref_id">
<code>Distributed.remoteref_id</code><span class="docstring-category">Function</span>
</h3>
<pre>remoteref_id(r::AbstractRemoteRef) -&gt; RRID</pre>
<p><code>Future</code>s and <code>RemoteChannel</code>s are identified by fields:</p>
<ul>
<li><p><code>where</code> - refers to the node where the underlying object/storage referred to by the reference actually exists.</p></li>
<li><p><code>whence</code> - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling <code>RemoteChannel(2)</code> from the master process would result in a <code>where</code> value of 2 and a <code>whence</code> value of 1.</p></li>
<li><p><code>id</code> is unique across all references created from the worker specified by <code>whence</code>.</p></li>
</ul>
<p>Taken together, <code>whence</code> and <code>id</code> uniquely identify a reference across all workers.</p>
<p><code>remoteref_id</code> is a low-level API which returns a <code>RRID</code> object that wraps <code>whence</code> and <code>id</code> values of a remote reference.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L117-L137">source</a><h3 id="Distributed.channel_from_id">
<code>Distributed.channel_from_id</code><span class="docstring-category">Function</span>
</h3>
<pre>channel_from_id(id) -&gt; c</pre>
<p>A low-level API which returns the backing <code>AbstractChannel</code> for an <code>id</code> returned by <a href="#Distributed.remoteref_id"><code>remoteref_id</code></a>. The call is valid only on the node where the backing channel exists.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/remotecall.jl#L140-L146">source</a><h3 id="Distributed.worker_id_from_socket">
<code>Distributed.worker_id_from_socket</code><span class="docstring-category">Function</span>
</h3>
<pre>worker_id_from_socket(s) -&gt; pid</pre>
<p>A low-level API which, given a <code>IO</code> connection or a <code>Worker</code>, returns the <code>pid</code> of the worker it is connected to. This is useful when writing custom <a href="../serialization/#Serialization.serialize"><code>serialize</code></a> methods for a type, which optimizes the data written out depending on the receiving process id.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L988-L995">source</a><h3 id="Distributed.cluster_cookie-Tuple{}">
<code>Distributed.cluster_cookie</code><span class="docstring-category">Method</span>
</h3>
<pre>cluster_cookie() -&gt; cookie</pre>
<p>Return the cluster cookie.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L642-L646">source</a><h3 id="Distributed.cluster_cookie-Tuple{Any}">
<code>Distributed.cluster_cookie</code><span class="docstring-category">Method</span>
</h3>
<pre>cluster_cookie(cookie) -&gt; cookie</pre>
<p>Set the passed cookie as the cluster cookie, then returns it.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L649-L653">source</a><h2 id="Cluster-Manager-Interface-1">Cluster Manager Interface</h2>
<p>This interface provides a mechanism to launch and manage Julia workers on different cluster environments. There are two types of managers present in Base: <code>LocalManager</code>, for launching additional workers on the same host, and <code>SSHManager</code>, for launching on remote hosts via <code>ssh</code>. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.</p>
<h3 id="Distributed.launch">
<code>Distributed.launch</code><span class="docstring-category">Function</span>
</h3>
<pre>launch(manager::ClusterManager, params::Dict, launched::Array, launch_ntfy::Condition)</pre>
<p>Implemented by cluster managers. For every Julia worker launched by this function, it should append a <code>WorkerConfig</code> entry to <code>launched</code> and notify <code>launch_ntfy</code>. The function MUST exit once all workers, requested by <code>manager</code> have been launched. <code>params</code> is a dictionary of all keyword arguments <a href="#Distributed.addprocs"><code>addprocs</code></a> was called with.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/managers.jl#L348-L355">source</a><h3 id="Distributed.manage">
<code>Distributed.manage</code><span class="docstring-category">Function</span>
</h3>
<pre>manage(manager::ClusterManager, id::Integer, config::WorkerConfig. op::Symbol)</pre>
<p>Implemented by cluster managers. It is called on the master process, during a worker's lifetime, with appropriate <code>op</code> values:</p>
<ul>
<li>with <code>:register</code>/<code>:deregister</code> when a worker is added / removed from the Julia worker pool.</li>
<li>with <code>:interrupt</code> when <code>interrupt(workers)</code> is called. The <code>ClusterManager</code> should signal the appropriate worker with an interrupt signal.</li>
<li>with <code>:finalize</code> for cleanup purposes.</li>
</ul>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/managers.jl#L358-L368">source</a><h3 id="Base.kill-Tuple{ClusterManager,Int64,WorkerConfig}">
<code>Base.kill</code><span class="docstring-category">Method</span>
</h3>
<pre>kill(manager::ClusterManager, pid::Int, config::WorkerConfig)</pre>
<p>Implemented by cluster managers. It is called on the master process, by <a href="#Distributed.rmprocs"><code>rmprocs</code></a>. It should cause the remote worker specified by <code>pid</code> to exit. <code>kill(manager::ClusterManager.....)</code> executes a remote <code>exit()</code> on <code>pid</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/managers.jl#L519-L527">source</a><h3 id="Sockets.connect-Tuple{ClusterManager,Int64,WorkerConfig}">
<code>Sockets.connect</code><span class="docstring-category">Method</span>
</h3>
<pre>connect(manager::ClusterManager, pid::Int, config::WorkerConfig) -&gt; (instrm::IO, outstrm::IO)</pre>
<p>Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id <code>pid</code>, specified by <code>config</code> and return a pair of <code>IO</code> objects. Messages from <code>pid</code> to current process will be read off <code>instrm</code>, while messages to be sent to <code>pid</code> will be written to <code>outstrm</code>. The custom transport implementation must ensure that messages are delivered and received completely and in order. <code>connect(manager::ClusterManager.....)</code> sets up TCP/IP socket connections in-between workers.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/managers.jl#L378-L388">source</a><h3 id="Distributed.init_worker">
<code>Distributed.init_worker</code><span class="docstring-category">Function</span>
</h3>
<pre>init_worker(cookie::AbstractString, manager::ClusterManager=DefaultClusterManager())</pre>
<p>Called by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument <code>--worker[=&lt;cookie&gt;]</code> has the effect of initializing a process as a worker using TCP/IP sockets for transport. <code>cookie</code> is a <a href="#Distributed.cluster_cookie-Tuple%7B%7D"><code>cluster_cookie</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L313-L320">source</a><h3 id="Distributed.start_worker">
<code>Distributed.start_worker</code><span class="docstring-category">Function</span>
</h3>
<pre>start_worker([out::IO=stdout], cookie::AbstractString=readline(stdin))</pre>
<p><code>start_worker</code> is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.</p>
<p>host:port information is written to stream <code>out</code> (defaults to stdout).</p>
<p>The function closes stdin (after reading the cookie if required), redirects stderr to stdout, listens on a free port (or if specified, the port in the <code>--bind-to</code> command line option) and schedules tasks to process incoming TCP connections and requests.</p>
<p>It does not return.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/cluster.jl#L174-L188">source</a><h3 id="Distributed.process_messages">
<code>Distributed.process_messages</code><span class="docstring-category">Function</span>
</h3>
<pre>process_messages(r_stream::IO, w_stream::IO, incoming::Bool=true)</pre>
<p>Called by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two <code>IO</code> objects, one for incoming messages and the other for messages addressed to the remote worker. If <code>incoming</code> is <code>true</code>, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.</p>
<p>See also <a href="#Distributed.cluster_cookie-Tuple%7B%7D"><code>cluster_cookie</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/Distributed/src/process_messages.jl#L120-L133">source</a><div class="_attribution">
  <p class="_attribution-p">
    © 2009–2018 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/v1.0.1/stdlib/Distributed/" class="_attribution-link" target="_blank">https://docs.julialang.org/en/v1.0.1/stdlib/Distributed/</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
