
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Linear Algebra - Julia 1.0 - W3cubDocs</title>
  
  <meta name="description" content="In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear &hellip;">
  <meta name="keywords" content="linear, algebra, -, julia, julia~1.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia~1.0/stdlib/linearalgebra/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/julia~1.0.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia~1.0/" class="_nav-link" title="" style="margin-left:0;">Julia 1.0</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _julia">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1 id="Linear-Algebra-1">Linear Algebra</h1>
<p>In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations. Basic operations, such as <a href="#LinearAlgebra.tr"><code>tr</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, and <a href="#"><code>inv</code></a> are all supported:</p>
<pre>julia&gt; A = [1 2 3; 4 1 6; 7 8 1]
3×3 Array{Int64,2}:
 1  2  3
 4  1  6
 7  8  1

julia&gt; tr(A)
3

julia&gt; det(A)
104.0

julia&gt; inv(A)
3×3 Array{Float64,2}:
 -0.451923   0.211538    0.0865385
  0.365385  -0.192308    0.0576923
  0.240385   0.0576923  -0.0673077</pre>
<p>As well as other useful operations, such as finding eigenvalues or eigenvectors:</p>
<pre>julia&gt; A = [-4. -17.; 2. 2.]
2×2 Array{Float64,2}:
 -4.0  -17.0
  2.0    2.0

julia&gt; eigvals(A)
2-element Array{Complex{Float64},1}:
 -1.0 + 5.0im
 -1.0 - 5.0im

julia&gt; eigvecs(A)
2×2 Array{Complex{Float64},2}:
  0.945905+0.0im        0.945905-0.0im
 -0.166924-0.278207im  -0.166924+0.278207im</pre>
<p>In addition, Julia provides many <a href="#man-linalg-factorizations-1">factorizations</a> which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on <a href="#LinearAlgebra.factorize"><code>factorize</code></a> for more information. As an example:</p>
<pre>julia&gt; A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3×3 Array{Float64,2}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia&gt; factorize(A)
LU{Float64,Array{Float64,2}}
L factor:
3×3 Array{Float64,2}:
  1.0    0.0       0.0
 -0.15   1.0       0.0
 -0.3   -0.132196  1.0
U factor:
3×3 Array{Float64,2}:
 -10.0  2.3     4.0
   0.0  2.345  -3.4
   0.0  0.0    -5.24947</pre>
<p>Since <code>A</code> is not Hermitian, symmetric, triangular, tridiagonal, or bidiagonal, an LU factorization may be the best we can do. Compare with:</p>
<pre>julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; factorize(B)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
3×3 Tridiagonal{Float64,Array{Float64,1}}:
 -1.64286   0.0   ⋅
  0.0      -2.8  0.0
   ⋅        0.0  5.0
U factor:
3×3 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.142857  -0.8
  ⋅   1.0       -0.6
  ⋅    ⋅         1.0
permutation:
3-element Array{Int64,1}:
 1
 2
 3</pre>
<p>Here, Julia was able to detect that <code>B</code> is in fact symmetric, and used a more appropriate factorization. Often it's possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can "tag" matrices as having these properties. For instance:</p>
<pre>julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0</pre>
<p><code>sB</code> has been tagged as a matrix that's (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:</p>
<pre>julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; x = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; sB\x
3-element Array{Float64,1}:
 -1.7391304347826084
 -1.1086956521739126
 -1.4565217391304346</pre>
<p>The <code>\</code> operation here performs the linear solution. The left-division operator is pretty powerful and it's easy to write compact, readable code that is flexible enough to solve all sorts of systems of linear equations.</p>
<h2 id="Special-matrices-1">Special matrices</h2>
<p><a href="http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=3274" target="_blank">Matrices with special symmetries and structures</a> arise often in linear algebra and are frequently associated with various matrix factorizations. Julia features a rich collection of special matrix types, which allow for fast computation with specialized routines that are specially developed for particular matrix types.</p>
<p>The following tables summarize the types of special matrices that have been implemented in Julia, as well as whether hooks to various optimized methods for them in LAPACK are available.</p>
<table>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
<tr>
<td><a href="#LinearAlgebra.Symmetric"><code>Symmetric</code></a></td>
<td><a href="https://en.wikipedia.org/wiki/Symmetric_matrix" target="_blank">Symmetric matrix</a></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Hermitian"><code>Hermitian</code></a></td>
<td><a href="https://en.wikipedia.org/wiki/Hermitian_matrix" target="_blank">Hermitian matrix</a></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.UpperTriangular"><code>UpperTriangular</code></a></td>
<td>Upper <a href="https://en.wikipedia.org/wiki/Triangular_matrix" target="_blank">triangular matrix</a>
</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.LowerTriangular"><code>LowerTriangular</code></a></td>
<td>Lower <a href="https://en.wikipedia.org/wiki/Triangular_matrix" target="_blank">triangular matrix</a>
</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a></td>
<td><a href="https://en.wikipedia.org/wiki/Tridiagonal_matrix" target="_blank">Tridiagonal matrix</a></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a></td>
<td>Symmetric tridiagonal matrix</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Bidiagonal"><code>Bidiagonal</code></a></td>
<td>Upper/lower <a href="https://en.wikipedia.org/wiki/Bidiagonal_matrix" target="_blank">bidiagonal matrix</a>
</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Diagonal"><code>Diagonal</code></a></td>
<td><a href="https://en.wikipedia.org/wiki/Diagonal_matrix" target="_blank">Diagonal matrix</a></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a></td>
<td><a href="https://en.wikipedia.org/wiki/Uniform_scaling" target="_blank">Uniform scaling operator</a></td>
</tr>
</table>
<h3 id="Elementary-operations-1">Elementary operations</h3>
<table>
<tr>
<th>Matrix type</th>
<th><code>+</code></th>
<th><code>-</code></th>
<th><code>*</code></th>
<th><code>\</code></th>
<th>Other functions with optimized methods</th>
</tr>
<tr>
<td><a href="#LinearAlgebra.Symmetric"><code>Symmetric</code></a></td>
<td></td>
<td></td>
<td></td>
<td>MV</td>
<td>
<a href="#"><code>inv</code></a>, <a href="#"><code>sqrt</code></a>, <a href="#"><code>exp</code></a>
</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Hermitian"><code>Hermitian</code></a></td>
<td></td>
<td></td>
<td></td>
<td>MV</td>
<td>
<a href="#"><code>inv</code></a>, <a href="#"><code>sqrt</code></a>, <a href="#"><code>exp</code></a>
</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.UpperTriangular"><code>UpperTriangular</code></a></td>
<td></td>
<td></td>
<td>MV</td>
<td>MV</td>
<td>
<a href="#"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>
</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.LowerTriangular"><code>LowerTriangular</code></a></td>
<td></td>
<td></td>
<td>MV</td>
<td>MV</td>
<td>
<a href="#"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>
</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a></td>
<td>M</td>
<td>M</td>
<td>MS</td>
<td>MV</td>
<td>
<a href="#LinearAlgebra.eigmax"><code>eigmax</code></a>, <a href="#LinearAlgebra.eigmin"><code>eigmin</code></a>
</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a></td>
<td>M</td>
<td>M</td>
<td>MS</td>
<td>MV</td>
<td></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Bidiagonal"><code>Bidiagonal</code></a></td>
<td>M</td>
<td>M</td>
<td>MS</td>
<td>MV</td>
<td></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Diagonal"><code>Diagonal</code></a></td>
<td>M</td>
<td>M</td>
<td>MV</td>
<td>MV</td>
<td>
<a href="#"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, <a href="#LinearAlgebra.logdet"><code>logdet</code></a>, <a href="https://docs.julialang.org/en/v1.0.1/base/math/#Base.:/" target="_blank"><code>/</code></a>
</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a></td>
<td>M</td>
<td>M</td>
<td>MVS</td>
<td>MVS</td>
<td><a href="https://docs.julialang.org/en/v1.0.1/base/math/#Base.:/" target="_blank"><code>/</code></a></td>
</tr>
</table>
<p>Legend:</p>
<table>
<tr>
<th>Key</th>
<th>Description</th>
</tr>
<tr>
<td>M (matrix)</td>
<td>An optimized method for matrix-matrix operations is available</td>
</tr>
<tr>
<td>V (vector)</td>
<td>An optimized method for matrix-vector operations is available</td>
</tr>
<tr>
<td>S (scalar)</td>
<td>An optimized method for matrix-scalar operations is available</td>
</tr>
</table>
<h3 id="Matrix-factorizations-1">Matrix factorizations</h3>
<table>
<tr>
<th>Matrix type</th>
<th>LAPACK</th>
<th><a href="#LinearAlgebra.eigen"><code>eigen</code></a></th>
<th><a href="#LinearAlgebra.eigvals"><code>eigvals</code></a></th>
<th><a href="#LinearAlgebra.eigvecs"><code>eigvecs</code></a></th>
<th><a href="#LinearAlgebra.svd"><code>svd</code></a></th>
<th><a href="#LinearAlgebra.svdvals"><code>svdvals</code></a></th>
</tr>
<tr>
<td><a href="#LinearAlgebra.Symmetric"><code>Symmetric</code></a></td>
<td>SY</td>
<td></td>
<td>ARI</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Hermitian"><code>Hermitian</code></a></td>
<td>HE</td>
<td></td>
<td>ARI</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.UpperTriangular"><code>UpperTriangular</code></a></td>
<td>TR</td>
<td>A</td>
<td>A</td>
<td>A</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.LowerTriangular"><code>LowerTriangular</code></a></td>
<td>TR</td>
<td>A</td>
<td>A</td>
<td>A</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a></td>
<td>ST</td>
<td>A</td>
<td>ARI</td>
<td>AV</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a></td>
<td>GT</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Bidiagonal"><code>Bidiagonal</code></a></td>
<td>BD</td>
<td></td>
<td></td>
<td></td>
<td>A</td>
<td>A</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.Diagonal"><code>Diagonal</code></a></td>
<td>DI</td>
<td></td>
<td>A</td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
<p>Legend:</p>
<table>
<tr>
<th>Key</th>
<th>Description</th>
<th>Example</th>
</tr>
<tr>
<td>A (all)</td>
<td>An optimized method to find all the characteristic values and/or vectors is available</td>
<td>e.g. <code>eigvals(M)</code>
</td>
</tr>
<tr>
<td>R (range)</td>
<td>An optimized method to find the <code>il</code>th through the <code>ih</code>th characteristic values are available</td>
<td><code>eigvals(M, il, ih)</code></td>
</tr>
<tr>
<td>I (interval)</td>
<td>An optimized method to find the characteristic values in the interval [<code>vl</code>, <code>vh</code>] is available</td>
<td><code>eigvals(M, vl, vh)</code></td>
</tr>
<tr>
<td>V (vectors)</td>
<td>An optimized method to find the characteristic vectors corresponding to the characteristic values <code>x=[x1, x2,...]</code> is available</td>
<td><code>eigvecs(M, x)</code></td>
</tr>
</table>
<h3 id="The-uniform-scaling-operator-1">The uniform scaling operator</h3>
<p>A <a href="#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a> operator represents a scalar times the identity operator, <code>λ*I</code>. The identity operator <code>I</code> is defined as a constant and is an instance of <code>UniformScaling</code>. The size of these operators are generic and match the other matrix in the binary operations <a href="https://docs.julialang.org/en/v1.0.1/base/math/#Base.:+" target="_blank"><code>+</code></a>, <a href="#"><code>-</code></a>, <a href="#"><code>*</code></a> and <a href="#"><code>\</code></a>. For <code>A+I</code> and <code>A-I</code> this means that <code>A</code> must be square. Multiplication with the identity operator <code>I</code> is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.</p>
<p>To see the <code>UniformScaling</code> operator in action:</p>
<pre>julia&gt; U = UniformScaling(2);

julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; a + U
2×2 Array{Int64,2}:
 3  2
 3  6

julia&gt; a * U
2×2 Array{Int64,2}:
 2  4
 6  8

julia&gt; [a U]
2×4 Array{Int64,2}:
 1  2  2  0
 3  4  0  2

julia&gt; b = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; b - U
ERROR: DimensionMismatch("matrix is not square: dimensions are (2, 3)")
Stacktrace:
[...]</pre>
<h2 id="man-linalg-factorizations-1">Matrix factorizations</h2>
<p><a href="https://en.wikipedia.org/wiki/Matrix_decomposition" target="_blank">Matrix factorizations (a.k.a. matrix decompositions)</a> compute the factorization of a matrix into a product of matrices, and are one of the central concepts in linear algebra.</p>
<p>The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the <a href="#Standard-Functions-1">Standard Functions</a> section of the Linear Algebra documentation.</p>
<table>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
<tr>
<td><code>Cholesky</code></td>
<td><a href="https://en.wikipedia.org/wiki/Cholesky_decomposition" target="_blank">Cholesky factorization</a></td>
</tr>
<tr>
<td><code>CholeskyPivoted</code></td>
<td>
<a href="https://en.wikipedia.org/wiki/Pivot_element" target="_blank">Pivoted</a> Cholesky factorization</td>
</tr>
<tr>
<td><code>LU</code></td>
<td><a href="https://en.wikipedia.org/wiki/LU_decomposition" target="_blank">LU factorization</a></td>
</tr>
<tr>
<td><code>LUTridiagonal</code></td>
<td>LU factorization for <a href="#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a> matrices</td>
</tr>
<tr>
<td><code>QR</code></td>
<td><a href="https://en.wikipedia.org/wiki/QR_decomposition" target="_blank">QR factorization</a></td>
</tr>
<tr>
<td><code>QRCompactWY</code></td>
<td>Compact WY form of the QR factorization</td>
</tr>
<tr>
<td><code>QRPivoted</code></td>
<td>Pivoted <a href="https://en.wikipedia.org/wiki/QR_decomposition" target="_blank">QR factorization</a>
</td>
</tr>
<tr>
<td><code>Hessenberg</code></td>
<td><a href="http://mathworld.wolfram.com/HessenbergDecomposition.html" target="_blank">Hessenberg decomposition</a></td>
</tr>
<tr>
<td><code>Eigen</code></td>
<td><a href="https://en.wikipedia.org/wiki/Eigendecomposition_(matrix)" target="_blank">Spectral decomposition</a></td>
</tr>
<tr>
<td><code>SVD</code></td>
<td><a href="https://en.wikipedia.org/wiki/Singular_value_decomposition" target="_blank">Singular value decomposition</a></td>
</tr>
<tr>
<td><code>GeneralizedSVD</code></td>
<td><a href="https://en.wikipedia.org/wiki/Generalized_singular_value_decomposition#Higher_order_version" target="_blank">Generalized SVD</a></td>
</tr>
</table>
<h2 id="Standard-Functions-1">Standard Functions</h2>
<p>Linear algebra functions in Julia are largely implemented by calling functions from <a href="http://www.netlib.org/lapack/" target="_blank">LAPACK</a>. Sparse factorizations call functions from <a href="http://faculty.cse.tamu.edu/davis/suitesparse.html" target="_blank">SuiteSparse</a>.</p>
<h3 id="Base.:*-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}">
<code>Base.:*</code><span class="docstring-category">Method</span>
</h3>
<pre>*(A::AbstractMatrix, B::AbstractMatrix)</pre>
<p>Matrix multiplication.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; [1 1; 0 1] * [1 0; 1 1]
2×2 Array{Int64,2}:
 2  1
 1  1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/matmul.jl#L126-L138">source</a><h3 id="Base.:\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}">
<code>Base.:\</code><span class="docstring-category">Method</span>
</h3>
<pre>\(A, B)</pre>
<p>Matrix division using a polyalgorithm. For input matrices <code>A</code> and <code>B</code>, the result <code>X</code> is such that <code>A*X == B</code> when <code>A</code> is square. The solver that is used depends upon the structure of <code>A</code>. If <code>A</code> is upper or lower triangular (or diagonal), no factorization of <code>A</code> is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.</p>
<p>For rectangular <code>A</code> the result is the minimum-norm least squares solution computed by a pivoted QR factorization of <code>A</code> and a rank estimate of <code>A</code> based on the R factor.</p>
<p>When <code>A</code> is sparse, a similar polyalgorithm is used. For indefinite matrices, the <code>LDLt</code> factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 0; 1 -2]; B = [32; -4];

julia&gt; X = A \ B
2-element Array{Float64,1}:
 32.0
 18.0

julia&gt; A * X == B
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L827-L855">source</a><h3 id="LinearAlgebra.dot">
<code>LinearAlgebra.dot</code><span class="docstring-category">Function</span>
</h3>
<pre>dot(x, y)
x ⋅ y</pre>
<p>For any iterable containers <code>x</code> and <code>y</code> (including arrays of any dimension) of numbers (or any element type for which <code>dot</code> is defined), compute the dot product (or inner product or scalar product), i.e. the sum of <code>dot(x[i],y[i])</code>, as if they were vectors.</p>
<p><code>x ⋅ y</code> (where <code>⋅</code> can be typed by tab-completing <code>\cdot</code> in the REPL) is a synonym for <code>dot(x, y)</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; dot(1:5, 2:6)
70

julia&gt; x = fill(2., (5,5));

julia&gt; y = fill(3., (5,5));

julia&gt; dot(x, y)
150.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L627-L650">source</a><pre>dot(x, y)
x ⋅ y</pre>
<p>Compute the dot product between two vectors. For complex vectors, the first vector is conjugated. When the vectors have equal lengths, calling <code>dot</code> is semantically equivalent to <code>sum(dot(vx,vy) for (vx,vy) in zip(x, y))</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; dot([1; 1], [2; 3])
5

julia&gt; dot([im; im], [1; 1])
0 - 2im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L682-L698">source</a><h3 id="LinearAlgebra.cross">
<code>LinearAlgebra.cross</code><span class="docstring-category">Function</span>
</h3>
<pre>cross(x, y)
×(x,y)</pre>
<p>Compute the cross product of two 3-vectors.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = [0;1;0]
3-element Array{Int64,1}:
 0
 1
 0

julia&gt; b = [0;0;1]
3-element Array{Int64,1}:
 0
 0
 1

julia&gt; cross(a,b)
3-element Array{Int64,1}:
 1
 0
 0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L85-L111">source</a><h3 id="LinearAlgebra.factorize">
<code>LinearAlgebra.factorize</code><span class="docstring-category">Function</span>
</h3>
<pre>factorize(A)</pre>
<p>Compute a convenient factorization of <code>A</code>, based upon the type of the input matrix. <code>factorize</code> checks <code>A</code> to see if it is symmetric/triangular/etc. if <code>A</code> is passed as a generic matrix. <code>factorize</code> checks every element of <code>A</code> to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: <code>A=factorize(A); x=A\b; y=A\C</code>.</p>
<table>
<tr>
<th>Properties of <code>A</code>
</th>
<th>type of factorization</th>
</tr>
<tr>
<td>Positive-definite</td>
<td>Cholesky (see <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>)</td>
</tr>
<tr>
<td>Dense Symmetric/Hermitian</td>
<td>Bunch-Kaufman (see <a href="#LinearAlgebra.bunchkaufman"><code>bunchkaufman</code></a>)</td>
</tr>
<tr>
<td>Sparse Symmetric/Hermitian</td>
<td>LDLt (see <a href="#LinearAlgebra.ldlt"><code>ldlt</code></a>)</td>
</tr>
<tr>
<td>Triangular</td>
<td>Triangular</td>
</tr>
<tr>
<td>Diagonal</td>
<td>Diagonal</td>
</tr>
<tr>
<td>Bidiagonal</td>
<td>Bidiagonal</td>
</tr>
<tr>
<td>Tridiagonal</td>
<td>LU (see <a href="#LinearAlgebra.lu"><code>lu</code></a>)</td>
</tr>
<tr>
<td>Symmetric real tridiagonal</td>
<td>LDLt (see <a href="#LinearAlgebra.ldlt"><code>ldlt</code></a>)</td>
</tr>
<tr>
<td>General square</td>
<td>LU (see <a href="#LinearAlgebra.lu"><code>lu</code></a>)</td>
</tr>
<tr>
<td>General non-square</td>
<td>QR (see <a href="#LinearAlgebra.qr"><code>qr</code></a>)</td>
</tr>
</table>
<p>If <code>factorize</code> is called on a Hermitian positive-definite matrix, for instance, then <code>factorize</code> will return a Cholesky factorization.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = Array(Bidiagonal(fill(1.0, (5, 5)), :U))
5×5 Array{Float64,2}:
 1.0  1.0  0.0  0.0  0.0
 0.0  1.0  1.0  0.0  0.0
 0.0  0.0  1.0  1.0  0.0
 0.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0

julia&gt; factorize(A) # factorize will check to see that A is already factorized
5×5 Bidiagonal{Float64,Array{Float64,1}}:
 1.0  1.0   ⋅    ⋅    ⋅
  ⋅   1.0  1.0   ⋅    ⋅
  ⋅    ⋅   1.0  1.0   ⋅
  ⋅    ⋅    ⋅   1.0  1.0
  ⋅    ⋅    ⋅    ⋅   1.0</pre>
<p>This returns a <code>5×5 Bidiagonal{Float64}</code>, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for <code>Bidiagonal</code> types.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1093-L1139">source</a><h3 id="LinearAlgebra.Diagonal">
<code>LinearAlgebra.Diagonal</code><span class="docstring-category">Type</span>
</h3>
<pre>Diagonal(A::AbstractMatrix)</pre>
<p>Construct a matrix from the diagonal of <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; Diagonal(A)
3×3 Diagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅
 ⋅  5  ⋅
 ⋅  ⋅  9</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/diagonal.jl#L16-L35">source</a><pre>Diagonal(V::AbstractVector)</pre>
<p>Construct a matrix with <code>V</code> as its diagonal.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; V = [1, 2]
2-element Array{Int64,1}:
 1
 2

julia&gt; Diagonal(V)
2×2 Diagonal{Int64,Array{Int64,1}}:
 1  ⋅
 ⋅  2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/diagonal.jl#L38-L55">source</a><h3 id="LinearAlgebra.Bidiagonal">
<code>LinearAlgebra.Bidiagonal</code><span class="docstring-category">Type</span>
</h3>
<pre>Bidiagonal(dv::V, ev::V, uplo::Symbol) where V &lt;: AbstractVector</pre>
<p>Constructs an upper (<code>uplo=:U</code>) or lower (<code>uplo=:L</code>) bidiagonal matrix using the given diagonal (<code>dv</code>) and off-diagonal (<code>ev</code>) vectors. The result is of type <code>Bidiagonal</code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a href="https://docs.julialang.org/en/v1.0.1/base/base/#Base.convert" target="_blank"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short). The length of <code>ev</code> must be one less than the length of <code>dv</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia&gt; Bu = Bidiagonal(dv, ev, :U) # ev is on the first superdiagonal
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia&gt; Bl = Bidiagonal(dv, ev, :L) # ev is on the first subdiagonal
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/bidiag.jl#L25-L63">source</a><pre>Bidiagonal(A, uplo::Symbol)</pre>
<p>Construct a <code>Bidiagonal</code> matrix from the main diagonal of <code>A</code> and its first super- (if <code>uplo=:U</code>) or sub-diagonal (if <code>uplo=:L</code>).</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]
4×4 Array{Int64,2}:
 1  1  1  1
 2  2  2  2
 3  3  3  3
 4  4  4  4

julia&gt; Bidiagonal(A, :U) # contains the main diagonal and first superdiagonal of A
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  1  ⋅  ⋅
 ⋅  2  2  ⋅
 ⋅  ⋅  3  3
 ⋅  ⋅  ⋅  4

julia&gt; Bidiagonal(A, :L) # contains the main diagonal and first subdiagonal of A
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅  ⋅
 2  2  ⋅  ⋅
 ⋅  3  3  ⋅
 ⋅  ⋅  4  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/bidiag.jl#L71-L100">source</a><h3 id="LinearAlgebra.SymTridiagonal">
<code>LinearAlgebra.SymTridiagonal</code><span class="docstring-category">Type</span>
</h3>
<pre>SymTridiagonal(dv::V, ev::V) where V &lt;: AbstractVector</pre>
<p>Construct a symmetric tridiagonal matrix from the diagonal (<code>dv</code>) and first sub/super-diagonal (<code>ev</code>), respectively. The result is of type <code>SymTridiagonal</code> and provides efficient specialized eigensolvers, but may be converted into a regular matrix with <a href="https://docs.julialang.org/en/v1.0.1/base/base/#Base.convert" target="_blank"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short).</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia&gt; SymTridiagonal(dv, ev)
4×4 SymTridiagonal{Int64,Array{Int64,1}}:
 1  7  ⋅  ⋅
 7  2  8  ⋅
 ⋅  8  3  9
 ⋅  ⋅  9  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/tridiag.jl#L18-L48">source</a><pre>SymTridiagonal(A::AbstractMatrix)</pre>
<p>Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, of the symmetric matrix <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2 3; 2 4 5; 3 5 6]
3×3 Array{Int64,2}:
 1  2  3
 2  4  5
 3  5  6

julia&gt; SymTridiagonal(A)
3×3 SymTridiagonal{Int64,Array{Int64,1}}:
 1  2  ⋅
 2  4  5
 ⋅  5  6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/tridiag.jl#L56-L76">source</a><h3 id="LinearAlgebra.Tridiagonal">
<code>LinearAlgebra.Tridiagonal</code><span class="docstring-category">Type</span>
</h3>
<pre>Tridiagonal(dl::V, d::V, du::V) where V &lt;: AbstractVector</pre>
<p>Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively. The result is of type <code>Tridiagonal</code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a href="https://docs.julialang.org/en/v1.0.1/base/base/#Base.convert" target="_blank"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short). The lengths of <code>dl</code> and <code>du</code> must be one less than the length of <code>d</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; dl = [1, 2, 3];

julia&gt; du = [4, 5, 6];

julia&gt; d = [7, 8, 9, 0];

julia&gt; Tridiagonal(dl, d, du)
4×4 Tridiagonal{Int64,Array{Int64,1}}:
 7  4  ⋅  ⋅
 1  8  5  ⋅
 ⋅  2  9  6
 ⋅  ⋅  3  0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/tridiag.jl#L427-L451">source</a><pre>Tridiagonal(A)</pre>
<p>Construct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]
4×4 Array{Int64,2}:
 1  2  3  4
 1  2  3  4
 1  2  3  4
 1  2  3  4

julia&gt; Tridiagonal(A)
4×4 Tridiagonal{Int64,Array{Int64,1}}:
 1  2  ⋅  ⋅
 1  2  3  ⋅
 ⋅  2  3  4
 ⋅  ⋅  3  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/tridiag.jl#L458-L480">source</a><h3 id="LinearAlgebra.Symmetric">
<code>LinearAlgebra.Symmetric</code><span class="docstring-category">Type</span>
</h3>
<pre>Symmetric(A, uplo=:U)</pre>
<p>Construct a <code>Symmetric</code> view of the upper (if <code>uplo = :U</code>) or lower (if <code>uplo = :L</code>) triangle of the matrix <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]
5×5 Array{Int64,2}:
 1  0  2  0  3
 0  4  0  5  0
 6  0  7  0  8
 0  9  0  1  0
 2  0  3  0  4

julia&gt; Supper = Symmetric(A)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  2  0  3
 0  4  0  5  0
 2  0  7  0  8
 0  5  0  1  0
 3  0  8  0  4

julia&gt; Slower = Symmetric(A, :L)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  6  0  2
 0  4  0  9  0
 6  0  7  0  3
 0  9  0  1  0
 2  0  3  0  4</pre>
<p>Note that <code>Supper</code> will not be equal to <code>Slower</code> unless <code>A</code> is itself symmetric (e.g. if <code>A == transpose(A)</code>).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/symmetric.jl#L13-L47">source</a><h3 id="LinearAlgebra.Hermitian">
<code>LinearAlgebra.Hermitian</code><span class="docstring-category">Type</span>
</h3>
<pre>Hermitian(A, uplo=:U)</pre>
<p>Construct a <code>Hermitian</code> view of the upper (if <code>uplo = :U</code>) or lower (if <code>uplo = :L</code>) triangle of the matrix <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];

julia&gt; Hupper = Hermitian(A)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  2+2im  0+0im  3-3im
 0+0im  4+0im  0+0im  5+0im  0+0im
 2-2im  0+0im  7+0im  0+0im  8+8im
 0+0im  5+0im  0+0im  1+0im  0+0im
 3+3im  0+0im  8-8im  0+0im  4+0im

julia&gt; Hlower = Hermitian(A, :L)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  6+6im  0+0im  2-2im
 0+0im  4+0im  0+0im  9+0im  0+0im
 6-6im  0+0im  7+0im  0+0im  3+3im
 0+0im  9+0im  0+0im  1+0im  0+0im
 2+2im  0+0im  3-3im  0+0im  4+0im</pre>
<p>Note that <code>Hupper</code> will not be equal to <code>Hlower</code> unless <code>A</code> is itself Hermitian (e.g. if <code>A == adjoint(A)</code>).</p>
<p>All non-real parts of the diagonal will be ignored.</p>
<pre>Hermitian(fill(complex(1,1), 1, 1)) == fill(1, 1, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/symmetric.jl#L88-L122">source</a><h3 id="LinearAlgebra.LowerTriangular">
<code>LinearAlgebra.LowerTriangular</code><span class="docstring-category">Type</span>
</h3>
<pre>LowerTriangular(A::AbstractMatrix)</pre>
<p>Construct a <code>LowerTriangular</code> view of the matrix <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; LowerTriangular(A)
3×3 LowerTriangular{Float64,Array{Float64,2}}:
 1.0   ⋅    ⋅
 4.0  5.0   ⋅
 7.0  8.0  9.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/triangular.jl#L58-L77">source</a><h3 id="LinearAlgebra.UpperTriangular">
<code>LinearAlgebra.UpperTriangular</code><span class="docstring-category">Type</span>
</h3>
<pre>UpperTriangular(A::AbstractMatrix)</pre>
<p>Construct an <code>UpperTriangular</code> view of the matrix <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; UpperTriangular(A)
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  ⋅   5.0  6.0
  ⋅    ⋅   9.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/triangular.jl#L79-L98">source</a><h3 id="LinearAlgebra.UniformScaling">
<code>LinearAlgebra.UniformScaling</code><span class="docstring-category">Type</span>
</h3>
<pre>UniformScaling{T&lt;:Number}</pre>
<p>Generically sized uniform scaling operator defined as a scalar times the identity operator, <code>λ*I</code>. See also <a href="#LinearAlgebra.I"><code>I</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; J = UniformScaling(2.)
UniformScaling{Float64}
2.0*I

julia&gt; A = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; J*A
2×2 Array{Float64,2}:
 2.0  4.0
 6.0  8.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/uniformscaling.jl#L6-L28">source</a><h3 id="LinearAlgebra.lu">
<code>LinearAlgebra.lu</code><span class="docstring-category">Function</span>
</h3>
<pre>lu(A, pivot=Val(true); check = true) -&gt; F::LU</pre>
<p>Compute the LU factorization of <code>A</code>.</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition's validity (via <a href="#LinearAlgebra.issuccess"><code>issuccess</code></a>) lies with the user.</p>
<p>In most cases, if <code>A</code> is a subtype <code>S</code> of <code>AbstractMatrix{T}</code> with an element type <code>T</code> supporting <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>, the return type is <code>LU{T,S{T}}</code>. If pivoting is chosen (default) the element type should also support <code>abs</code> and <code>&lt;</code>.</p>
<p>The individual components of the factorization <code>F</code> can be accessed via <code>getproperty</code>:</p>
<table>
<tr>
<th>Component</th>
<th>Description</th>
</tr>
<tr>
<td><code>F.L</code></td>
<td>
<code>L</code> (lower triangular) part of <code>LU</code>
</td>
</tr>
<tr>
<td><code>F.U</code></td>
<td>
<code>U</code> (upper triangular) part of <code>LU</code>
</td>
</tr>
<tr>
<td><code>F.p</code></td>
<td>(right) permutation <code>Vector</code>
</td>
</tr>
<tr>
<td><code>F.P</code></td>
<td>(right) permutation <code>Matrix</code>
</td>
</tr>
</table>
<p>Iterating the factorization produces the components <code>F.L</code>, <code>F.U</code>, and <code>F.p</code>.</p>
<p>The relationship between <code>F</code> and <code>A</code> is</p>
<p><code>F.L*F.U == A[F.p, :]</code></p>
<p><code>F</code> further supports the following functions:</p>
<table>
<tr>
<th>Supported function</th>
<th><code>LU</code></th>
<th><code>LU{T,Tridiagonal{T}}</code></th>
</tr>
<tr>
<td><a href="https://docs.julialang.org/en/v1.0.1/base/math/#Base.:/" target="_blank"><code>/</code></a></td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td><a href="#"><code>\</code></a></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><a href="#"><code>inv</code></a></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.det"><code>det</code></a></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.logdet"><code>logdet</code></a></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><a href="#LinearAlgebra.logabsdet"><code>logabsdet</code></a></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><a href="https://docs.julialang.org/en/v1.0.1/base/arrays/#Base.size" target="_blank"><code>size</code></a></td>
<td>✓</td>
<td>✓</td>
</tr>
</table>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia&gt; F = lu(A)
LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0  0.0
 1.5  1.0
U factor:
2×2 Array{Float64,2}:
 4.0   3.0
 0.0  -1.5

julia&gt; F.L * F.U == A[F.p, :]
true

julia&gt; l, u, p = lu(A); # destructuring via iteration

julia&gt; l == F.L &amp;&amp; u == F.U &amp;&amp; p == F.p
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lu.jl#L165-L232">source</a><h3 id="LinearAlgebra.lu!">
<code>LinearAlgebra.lu!</code><span class="docstring-category">Function</span>
</h3>
<pre>lu!(A, pivot=Val(true); check = true) -&gt; LU</pre>
<p><code>lu!</code> is the same as <a href="#LinearAlgebra.lu"><code>lu</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="https://docs.julialang.org/en/v1.0.1/base/base/#Core.InexactError" target="_blank"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [4. 3.; 6. 3.]
2×2 Array{Float64,2}:
 4.0  3.0
 6.0  3.0

julia&gt; F = lu!(A)
LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia&gt; iA = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia&gt; lu!(iA)
ERROR: InexactError: Int64(Int64, 0.6666666666666666)
Stacktrace:
[...]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lu.jl#L49-L85">source</a><h3 id="LinearAlgebra.cholesky">
<code>LinearAlgebra.cholesky</code><span class="docstring-category">Function</span>
</h3>
<pre>cholesky(A, Val(false); check = true) -&gt; Cholesky</pre>
<p>Compute the Cholesky factorization of a dense symmetric positive definite matrix <code>A</code> and return a <code>Cholesky</code> factorization. The matrix <code>A</code> can either be a <a href="#LinearAlgebra.Symmetric"><code>Symmetric</code></a> or <a href="#LinearAlgebra.Hermitian"><code>Hermitian</code></a> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F.L</code> and <code>F.U</code>. The following functions are available for <code>Cholesky</code> objects: <a href="https://docs.julialang.org/en/v1.0.1/base/arrays/#Base.size" target="_blank"><code>size</code></a>, <a href="#"><code>\</code></a>, <a href="#"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, <a href="#LinearAlgebra.logdet"><code>logdet</code></a> and <a href="#LinearAlgebra.isposdef"><code>isposdef</code></a>.</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition's validity (via <a href="#LinearAlgebra.issuccess"><code>issuccess</code></a>) lies with the user.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia&gt; C = cholesky(A)
Cholesky{Float64,Array{Float64,2}}
U factor:
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.U
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.L
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia&gt; C.L * C.U == A
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/cholesky.jl#L228-L273">source</a><pre>cholesky(A, Val(true); tol = 0.0, check = true) -&gt; CholeskyPivoted</pre>
<p>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix <code>A</code> and return a <code>CholeskyPivoted</code> factorization. The matrix <code>A</code> can either be a <a href="#LinearAlgebra.Symmetric"><code>Symmetric</code></a> or <a href="#LinearAlgebra.Hermitian"><code>Hermitian</code></a> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F.L</code> and <code>F.U</code>. The following functions are available for <code>PivotedCholesky</code> objects: <a href="https://docs.julialang.org/en/v1.0.1/base/arrays/#Base.size" target="_blank"><code>size</code></a>, <a href="#"><code>\</code></a>, <a href="#"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, and <a href="#LinearAlgebra.rank"><code>rank</code></a>. The argument <code>tol</code> determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition's validity (via <a href="#LinearAlgebra.issuccess"><code>issuccess</code></a>) lies with the user.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/cholesky.jl#L279-L294">source</a><h3 id="LinearAlgebra.cholesky!">
<code>LinearAlgebra.cholesky!</code><span class="docstring-category">Function</span>
</h3>
<pre>cholesky!(A, Val(false); check = true) -&gt; Cholesky</pre>
<p>The same as <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="https://docs.julialang.org/en/v1.0.1/base/base/#Core.InexactError" target="_blank"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia&gt; cholesky!(A)
ERROR: InexactError: Int64(Int64, 6.782329983125268)
Stacktrace:
[...]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/cholesky.jl#L158-L178">source</a><pre>cholesky!(A, Val(true); tol = 0.0, check = true) -&gt; CholeskyPivoted</pre>
<p>The same as <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="https://docs.julialang.org/en/v1.0.1/base/base/#Core.InexactError" target="_blank"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/cholesky.jl#L205-L212">source</a><h3 id="LinearAlgebra.lowrankupdate">
<code>LinearAlgebra.lowrankupdate</code><span class="docstring-category">Function</span>
</h3>
<pre>lowrankupdate(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</pre>
<p>Update a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U'C.U</code> then <code>CC = cholesky(C.U'C.U + v*v')</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/cholesky.jl#L603-L609">source</a><h3 id="LinearAlgebra.lowrankdowndate">
<code>LinearAlgebra.lowrankdowndate</code><span class="docstring-category">Function</span>
</h3>
<pre>lowrankdowndate(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</pre>
<p>Downdate a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U'C.U</code> then <code>CC = cholesky(C.U'C.U - v*v')</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/cholesky.jl#L612-L618">source</a><h3 id="LinearAlgebra.lowrankupdate!">
<code>LinearAlgebra.lowrankupdate!</code><span class="docstring-category">Function</span>
</h3>
<pre>lowrankupdate!(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</pre>
<p>Update a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U'C.U</code> then <code>CC = cholesky(C.U'C.U + v*v')</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations. The input factorization <code>C</code> is updated in place such that on exit <code>C == CC</code>. The vector <code>v</code> is destroyed during the computation.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/cholesky.jl#L504-L511">source</a><h3 id="LinearAlgebra.lowrankdowndate!">
<code>LinearAlgebra.lowrankdowndate!</code><span class="docstring-category">Function</span>
</h3>
<pre>lowrankdowndate!(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</pre>
<p>Downdate a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U'C.U</code> then <code>CC = cholesky(C.U'C.U - v*v')</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations. The input factorization <code>C</code> is updated in place such that on exit <code>C == CC</code>. The vector <code>v</code> is destroyed during the computation.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/cholesky.jl#L550-L557">source</a><h3 id="LinearAlgebra.ldlt">
<code>LinearAlgebra.ldlt</code><span class="docstring-category">Function</span>
</h3>
<pre>ldlt(S::SymTridiagonal) -&gt; LDLt</pre>
<p>Compute an <code>LDLt</code> factorization of the real symmetric tridiagonal matrix <code>S</code> such that <code>S = L*Diagonal(d)*L'</code> where <code>L</code> is a unit lower triangular matrix and <code>d</code> is a vector. The main use of an <code>LDLt</code> factorization <code>F = ldlt(S)</code> is to solve the linear system of equations <code>Sx = b</code> with <code>F\b</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia&gt; ldltS = ldlt(S);

julia&gt; b = [6., 7., 8.];

julia&gt; ldltS \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255

julia&gt; S \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/ldlt.jl#L62-L93">source</a><h3 id="LinearAlgebra.ldlt!">
<code>LinearAlgebra.ldlt!</code><span class="docstring-category">Function</span>
</h3>
<pre>ldlt!(S::SymTridiagonal) -&gt; LDLt</pre>
<p>Same as <a href="#LinearAlgebra.ldlt"><code>ldlt</code></a>, but saves space by overwriting the input <code>S</code>, instead of creating a copy.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia&gt; ldltS = ldlt!(S);

julia&gt; ldltS === S
false

julia&gt; S
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0       0.333333   ⋅
 0.333333  3.66667   0.545455
  ⋅        0.545455  3.90909</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/ldlt.jl#L26-L50">source</a><h3 id="LinearAlgebra.qr">
<code>LinearAlgebra.qr</code><span class="docstring-category">Function</span>
</h3>
<pre>qr(A, pivot=Val(false)) -&gt; F</pre>
<p>Compute the QR factorization of the matrix <code>A</code>: an orthogonal (or unitary if <code>A</code> is complex-valued) matrix <code>Q</code>, and an upper triangular matrix <code>R</code> such that</p>\[A = Q R\]<p>The returned object <code>F</code> stores the factorization in a packed format:</p>
<ul>
<li><p>if <code>pivot == Val(true)</code> then <code>F</code> is a <a href="#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> object,</p></li>
<li><p>otherwise if the element type of <code>A</code> is a BLAS type (<a href="https://docs.julialang.org/en/v1.0.1/base/numbers/#Core.Float32" target="_blank"><code>Float32</code></a>, <a href="https://docs.julialang.org/en/v1.0.1/base/numbers/#Core.Float64" target="_blank"><code>Float64</code></a>, <code>ComplexF32</code> or <code>ComplexF64</code>), then <code>F</code> is a <a href="#LinearAlgebra.QRCompactWY"><code>QRCompactWY</code></a> object,</p></li>
<li><p>otherwise <code>F</code> is a <a href="#LinearAlgebra.QR"><code>QR</code></a> object.</p></li>
</ul>
<p>The individual components of the decomposition <code>F</code> can be retrieved via property accessors:</p>
<ul>
<li>
<code>F.Q</code>: the orthogonal/unitary matrix <code>Q</code>
</li>
<li>
<code>F.R</code>: the upper triangular matrix <code>R</code>
</li>
<li>
<code>F.p</code>: the permutation vector of the pivot (<a href="#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> only)</li>
<li>
<code>F.P</code>: the permutation matrix of the pivot (<a href="#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> only)</li>
</ul>
<p>Iterating the decomposition produces the components <code>Q</code>, <code>R</code>, and if extant <code>p</code>.</p>
<p>The following functions are available for the <code>QR</code> objects: <a href="#"><code>inv</code></a>, <a href="https://docs.julialang.org/en/v1.0.1/base/arrays/#Base.size" target="_blank"><code>size</code></a>, and <a href="#"><code>\</code></a>. When <code>A</code> is rectangular, <code>\</code> will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.</p>
<p>Multiplication with respect to either full/square or non-full/square <code>Q</code> is allowed, i.e. both <code>F.Q*F.R</code> and <code>F.Q*A</code> are supported. A <code>Q</code> matrix can be converted into a regular matrix with <a href="https://docs.julialang.org/en/v1.0.1/base/arrays/#Base.Matrix" target="_blank"><code>Matrix</code></a>. This operation returns the "thin" Q factor, i.e., if <code>A</code> is <code>m</code>×<code>n</code> with <code>m&gt;=n</code>, then <code>Matrix(F.Q)</code> yields an <code>m</code>×<code>n</code> matrix with orthonormal columns. To retrieve the "full" Q factor, an <code>m</code>×<code>m</code> orthogonal matrix, use <code>F.Q*Matrix(I,m,m)</code>. If <code>m&lt;=n</code>, then <code>Matrix(F.Q)</code> yields an <code>m</code>×<code>m</code> orthogonal matrix.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3×2 Array{Float64,2}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia&gt; F = qr(A)
LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}
Q factor:
3×3 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.6   0.0   0.8
 -0.8   0.0  -0.6
  0.0  -1.0   0.0
R factor:
2×2 Array{Float64,2}:
 -5.0  10.0
  0.0  -1.0

julia&gt; F.Q * F.R == A
true</pre>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p><code>qr</code> returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the <code>Q</code> and <code>R</code> matrices can be stored compactly rather as two separate dense matrices.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/qr.jl#L291-L359">source</a><h3 id="LinearAlgebra.qr!">
<code>LinearAlgebra.qr!</code><span class="docstring-category">Function</span>
</h3>
<pre>qr!(A, pivot=Val(false))</pre>
<p><code>qr!</code> is the same as <a href="#LinearAlgebra.qr"><code>qr</code></a> when <code>A</code> is a subtype of <code>StridedMatrix</code>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="https://docs.julialang.org/en/v1.0.1/base/base/#Core.InexactError" target="_blank"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; qr!(a)
LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}
Q factor:
2×2 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.316228  -0.948683
 -0.948683   0.316228
R factor:
2×2 Array{Float64,2}:
 -3.16228  -4.42719
  0.0      -0.632456

julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; qr!(a)
ERROR: InexactError: Int64(Int64, -3.1622776601683795)
Stacktrace:
[...]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/qr.jl#L248-L284">source</a><h3 id="LinearAlgebra.QR">
<code>LinearAlgebra.QR</code><span class="docstring-category">Type</span>
</h3>
<pre>QR &lt;: Factorization</pre>
<p>A QR matrix factorization stored in a packed format, typically obtained from <a href="#LinearAlgebra.qr"><code>qr</code></a>. If <span>$A$</span> is an <code>m</code>×<code>n</code> matrix, then</p>\[A = Q R\]<p>where <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. The matrix <span>$Q$</span> is stored as a sequence of Householder reflectors <span>$v_i$</span> and coefficients <span>$\tau_i$</span> where:</p>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\]<p>Iterating the decomposition produces the components <code>Q</code> and <code>R</code>.</p>
<p>The object has two fields:</p>
<ul>
<li>
<p><code>factors</code> is an <code>m</code>×<code>n</code> matrix.</p>
<ul>
<li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li>
<li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format where <span>$v_i$</span> is the <span>$i$</span>th column of the matrix <code>V = I + tril(F.factors, -1)</code>.</p></li>
</ul>
</li>
<li><p><code>τ</code> is a vector of length <code>min(m,n)</code> containing the coefficients <span>$au_i$</span>.</p></li>
</ul>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/qr.jl#L4-L36">source</a><h3 id="LinearAlgebra.QRCompactWY">
<code>LinearAlgebra.QRCompactWY</code><span class="docstring-category">Type</span>
</h3>
<pre>QRCompactWY &lt;: Factorization</pre>
<p>A QR matrix factorization stored in a compact blocked format, typically obtained from <a href="#LinearAlgebra.qr"><code>qr</code></a>. If <span>$A$</span> is an <code>m</code>×<code>n</code> matrix, then</p>\[A = Q R\]<p>where <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. It is similar to the <a href="#LinearAlgebra.QR"><code>QR</code></a> format except that the orthogonal/unitary matrix <span>$Q$</span> is stored in <em>Compact WY</em> format <a href="#footnote-Schreiber1989">[Schreiber1989]</a>, as a lower trapezoidal matrix <span>$V$</span> and an upper triangular matrix <span>$T$</span> where</p>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T) = I - V T V^T\]<p>such that <span>$v_i$</span> is the <span>$i$</span>th column of <span>$V$</span>, and <span>$au_i$</span> is the <span>$i$</span>th diagonal element of <span>$T$</span>.</p>
<p>Iterating the decomposition produces the components <code>Q</code> and <code>R</code>.</p>
<p>The object has two fields:</p>
<ul>
<li>
<p><code>factors</code>, as in the <a href="#LinearAlgebra.QR"><code>QR</code></a> type, is an <code>m</code>×<code>n</code> matrix.</p>
<ul>
<li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li>
<li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format such that <code>V = I + tril(F.factors, -1)</code>.</p></li>
</ul>
</li>
<li><p><code>T</code> is a square matrix with <code>min(m,n)</code> columns, whose upper triangular part gives the matrix <span>$T$</span> above (the subdiagonal elements are ignored).</p></li>
</ul>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>This format should not to be confused with the older <em>WY</em> representation <a href="#footnote-Bischof1987">[Bischof1987]</a>.</p></div>
</div>
<div class="footnote" id="footnote-Bischof1987">
<a href="#footnote-Bischof1987"><strong>[Bischof1987]</strong></a><p>C Bischof and C Van Loan, "The WY representation for products of Householder matrices", SIAM J Sci Stat Comput 8 (1987), s2-s13. <a href="https://doi.org/10.1137/0908009" target="_blank">doi:10.1137/0908009</a></p>
</div>
<div class="footnote" id="footnote-Schreiber1989">
<a href="#footnote-Schreiber1989"><strong>[Schreiber1989]</strong></a><p>R Schreiber and C Van Loan, "A storage-efficient WY representation for products of Householder transformations", SIAM J Sci Stat Comput 10 (1989), 53-57. <a href="https://doi.org/10.1137/0910005" target="_blank">doi:10.1137/0910005</a></p>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/qr.jl#L57-L103">source</a><h3 id="LinearAlgebra.QRPivoted">
<code>LinearAlgebra.QRPivoted</code><span class="docstring-category">Type</span>
</h3>
<pre>QRPivoted &lt;: Factorization</pre>
<p>A QR matrix factorization with column pivoting in a packed format, typically obtained from <a href="#LinearAlgebra.qr"><code>qr</code></a>. If <span>$A$</span> is an <code>m</code>×<code>n</code> matrix, then</p>\[A P = Q R\]<p>where <span>$P$</span> is a permutation matrix, <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. The matrix <span>$Q$</span> is stored as a sequence of Householder reflectors:</p>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\]<p>Iterating the decomposition produces the components <code>Q</code>, <code>R</code>, and <code>p</code>.</p>
<p>The object has three fields:</p>
<ul>
<li>
<p><code>factors</code> is an <code>m</code>×<code>n</code> matrix.</p>
<ul>
<li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li>
<li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format where <span>$v_i$</span> is the <span>$i$</span>th column of the matrix <code>V = I + tril(F.factors, -1)</code>.</p></li>
</ul>
</li>
<li><p><code>τ</code> is a vector of length <code>min(m,n)</code> containing the coefficients <span>$au_i$</span>.</p></li>
<li><p><code>jpvt</code> is an integer vector of length <code>n</code> corresponding to the permutation <span>$P$</span>.</p></li>
</ul>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/qr.jl#L123-L155">source</a><h3 id="LinearAlgebra.lq!">
<code>LinearAlgebra.lq!</code><span class="docstring-category">Function</span>
</h3>
<pre>lq!(A) -&gt; LQ</pre>
<p>Compute the LQ factorization of <code>A</code>, using the input matrix as a workspace. See also <a href="#LinearAlgebra.lq"><code>lq</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lq.jl#L32-L37">source</a><h3 id="LinearAlgebra.lq">
<code>LinearAlgebra.lq</code><span class="docstring-category">Function</span>
</h3>
<pre>lq(A) -&gt; S::LQ</pre>
<p>Compute the LQ decomposition of <code>A</code>. The decomposition's lower triangular component can be obtained from the <code>LQ</code> object <code>S</code> via <code>S.L</code>, and the orthogonal/unitary component via <code>S.Q</code>, such that <code>A ≈ S.L*S.Q</code>.</p>
<p>Iterating the decomposition produces the components <code>S.L</code> and <code>S.Q</code>.</p>
<p>The LQ decomposition is the QR decomposition of <code>transpose(A)</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; S = lq(A)
LQ{Float64,Array{Float64,2}} with factors L and Q:
[-8.60233 0.0; 4.41741 -0.697486]
[-0.581238 -0.813733; -0.813733 0.581238]

julia&gt; S.L * S.Q
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; l, q = S; # destructuring via iteration

julia&gt; l == S.L &amp;&amp;  q == S.Q
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lq.jl#L39-L72">source</a><h3 id="LinearAlgebra.bunchkaufman">
<code>LinearAlgebra.bunchkaufman</code><span class="docstring-category">Function</span>
</h3>
<pre>bunchkaufman(A, rook::Bool=false; check = true) -&gt; S::BunchKaufman</pre>
<p>Compute the Bunch-Kaufman <a href="#footnote-Bunch1977">[Bunch1977]</a> factorization of a <code>Symmetric</code> or <code>Hermitian</code> matrix <code>A</code> as <span>$P'*U*D*U'*P$</span> or <span>$P'*L*D*L'*P$</span>, depending on which triangle is stored in <code>A</code>, and return a <code>BunchKaufman</code> object. Note that if <code>A</code> is complex symmetric then <code>U'</code> and <code>L'</code> denote the unconjugated transposes, i.e. <code>transpose(U)</code> and <code>transpose(L)</code>.</p>
<p>Iterating the decomposition produces the components <code>S.D</code>, <code>S.U</code> or <code>S.L</code> as appropriate given <code>S.uplo</code>, and <code>S.p</code>.</p>
<p>If <code>rook</code> is <code>true</code>, rook pivoting is used. If <code>rook</code> is false, rook pivoting is not used.</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition's validity (via <a href="#LinearAlgebra.issuccess"><code>issuccess</code></a>) lies with the user.</p>
<p>The following functions are available for <code>BunchKaufman</code> objects: <a href="https://docs.julialang.org/en/v1.0.1/base/arrays/#Base.size" target="_blank"><code>size</code></a>, <code>\</code>, <a href="#"><code>inv</code></a>, <a href="#LinearAlgebra.issymmetric"><code>issymmetric</code></a>, <a href="#LinearAlgebra.ishermitian"><code>ishermitian</code></a>, <a href="https://docs.julialang.org/en/v1.0.1/base/collections/#Base.getindex" target="_blank"><code>getindex</code></a>.</p>
<div class="footnote" id="footnote-Bunch1977">
<a href="#footnote-Bunch1977"><strong>[Bunch1977]</strong></a><p>J R Bunch and L Kaufman, Some stable methods for calculating inertia</p>
</div>
<p>and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. <a href="http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0/" target="_blank">url</a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 2 3]
2×2 Array{Int64,2}:
 1  2
 2  3

julia&gt; S = bunchkaufman(A)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 -0.333333  0.0
  0.0       3.0
U factor:
2×2 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.666667
  ⋅   1.0
permutation:
2-element Array{Int64,1}:
 1
 2

julia&gt; d, u, p = S; # destructuring via iteration

julia&gt; d == S.D &amp;&amp; u == S.U &amp;&amp; p == S.p
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/bunchkaufman.jl#L59-L113">source</a><h3 id="LinearAlgebra.bunchkaufman!">
<code>LinearAlgebra.bunchkaufman!</code><span class="docstring-category">Function</span>
</h3>
<pre>bunchkaufman!(A, rook::Bool=false; check = true) -&gt; BunchKaufman</pre>
<p><code>bunchkaufman!</code> is the same as <a href="#LinearAlgebra.bunchkaufman"><code>bunchkaufman</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/bunchkaufman.jl#L31-L36">source</a><h3 id="LinearAlgebra.eigvals">
<code>LinearAlgebra.eigvals</code><span class="docstring-category">Function</span>
</h3>
<pre>eigvals(A; permute::Bool=true, scale::Bool=true) -&gt; values</pre>
<p>Return the eigenvalues of <code>A</code>.</p>
<p>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is <code>true</code> for both options.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; diag_matrix = [1 0; 0 4]
2×2 Array{Int64,2}:
 1  0
 0  4

julia&gt; eigvals(diag_matrix)
2-element Array{Float64,1}:
 1.0
 4.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L187-L210">source</a><p>For a scalar input, <code>eigvals</code> will return a scalar.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; eigvals(-2)
-2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L214-L222">source</a><pre>eigvals(A, B) -&gt; values</pre>
<p>Computes the generalized eigenvalues of <code>A</code> and <code>B</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eigvals(A,B)
2-element Array{Complex{Float64},1}:
 0.0 + 1.0im
 0.0 - 1.0im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L437-L459">source</a><pre>eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values</pre>
<p>Returns the eigenvalues of <code>A</code>. It is possible to calculate only a subset of the eigenvalues by specifying a <code>UnitRange</code> <code>irange</code> covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.</p>
<pre>julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A, 2:2)
1-element Array{Float64,1}:
 0.9999999999999996

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/symmetric.jl#L564-L588">source</a><pre>eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values</pre>
<p>Returns the eigenvalues of <code>A</code>. It is possible to calculate only a subset of the eigenvalues by specifying a pair <code>vl</code> and <code>vu</code> for the lower and upper boundaries of the eigenvalues.</p>
<pre>julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A, -1, 2)
1-element Array{Float64,1}:
 1.0000000000000009

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/symmetric.jl#L604-L627">source</a><h3 id="LinearAlgebra.eigvals!">
<code>LinearAlgebra.eigvals!</code><span class="docstring-category">Function</span>
</h3>
<pre>eigvals!(A; permute::Bool=true, scale::Bool=true) -&gt; values</pre>
<p>Same as <a href="#LinearAlgebra.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>The input matrix <code>A</code> will not contain its eigenvalues after <code>eigvals!</code> is called on it - <code>A</code> is used as a workspace.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; eigvals!(A)
2-element Array{Float64,1}:
 -0.3722813232690143
  5.372281323269014

julia&gt; A
2×2 Array{Float64,2}:
 -0.372281  -1.0
  0.0        5.37228</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L144-L173">source</a><pre>eigvals!(A, B) -&gt; values</pre>
<p>Same as <a href="#LinearAlgebra.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code> (and <code>B</code>), instead of creating copies.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>The input matrices <code>A</code> and <code>B</code> will not contain their eigenvalues after <code>eigvals!</code> is called. They are used as workspaces.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; eigvals!(A, B)
2-element Array{Complex{Float64},1}:
 0.0 + 1.0im
 0.0 - 1.0im

julia&gt; A
2×2 Array{Float64,2}:
 -0.0  -1.0
  1.0  -0.0

julia&gt; B
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L388-L425">source</a><pre>eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values</pre>
<p>Same as <a href="#LinearAlgebra.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. <code>irange</code> is a range of eigenvalue <em>indices</em> to search for - for instance, the 2nd to 8th eigenvalues.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/symmetric.jl#L555-L560">source</a><pre>eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values</pre>
<p>Same as <a href="#LinearAlgebra.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. <code>vl</code> is the lower bound of the interval to search for eigenvalues, and <code>vu</code> is the upper bound.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/symmetric.jl#L595-L600">source</a><h3 id="LinearAlgebra.eigmax">
<code>LinearAlgebra.eigmax</code><span class="docstring-category">Function</span>
</h3>
<pre>eigmax(A; permute::Bool=true, scale::Bool=true)</pre>
<p>Return the largest eigenvalue of <code>A</code>. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code>A</code> are complex, this method will fail, since complex numbers cannot be sorted.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmax(A)
1.0

julia&gt; A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmax(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L225-L257">source</a><h3 id="LinearAlgebra.eigmin">
<code>LinearAlgebra.eigmin</code><span class="docstring-category">Function</span>
</h3>
<pre>eigmin(A; permute::Bool=true, scale::Bool=true)</pre>
<p>Return the smallest eigenvalue of <code>A</code>. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code>A</code> are complex, this method will fail, since complex numbers cannot be sorted.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmin(A)
-1.0

julia&gt; A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmin(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L266-L298">source</a><h3 id="LinearAlgebra.eigvecs">
<code>LinearAlgebra.eigvecs</code><span class="docstring-category">Function</span>
</h3>
<pre>eigvecs(A::SymTridiagonal[, eigvals]) -&gt; Matrix</pre>
<p>Return a matrix <code>M</code> whose columns are the eigenvectors of <code>A</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.)</p>
<p>If the optional vector of eigenvalues <code>eigvals</code> is specified, <code>eigvecs</code> returns the specific corresponding eigenvectors.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259

julia&gt; eigvecs(A)
3×3 Array{Float64,2}:
  0.418304  -0.83205      0.364299
 -0.656749  -7.39009e-16  0.754109
  0.627457   0.5547       0.546448

julia&gt; eigvecs(A, [1.])
3×1 Array{Float64,2}:
  0.8320502943378438
  4.263514128092366e-17
 -0.5547001962252291</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/tridiag.jl#L233-L268">source</a><pre>eigvecs(A; permute::Bool=true, scale::Bool=true) -&gt; Matrix</pre>
<p>Return a matrix <code>M</code> whose columns are the eigenvectors of <code>A</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.) The <code>permute</code> and <code>scale</code> keywords are the same as for <a href="#LinearAlgebra.eigen"><code>eigen</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L122-L137">source</a><pre>eigvecs(A, B) -&gt; Matrix</pre>
<p>Return a matrix <code>M</code> whose columns are the generalized eigenvectors of <code>A</code> and <code>B</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.)</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eigvecs(A, B)
2×2 Array{Complex{Float64},2}:
  0.0-1.0im   0.0+1.0im
 -1.0-0.0im  -1.0+0.0im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L465-L488">source</a><h3 id="LinearAlgebra.eigen">
<code>LinearAlgebra.eigen</code><span class="docstring-category">Function</span>
</h3>
<pre>eigen(A; permute::Bool=true, scale::Bool=true) -&gt; Eigen</pre>
<p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F.values</code> and the eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p>
<p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p>
<p>The following functions are available for <code>Eigen</code> objects: <a href="#"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, and <a href="#LinearAlgebra.isposdef"><code>isposdef</code></a>.</p>
<p>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is <code>true</code> for both options.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}
eigenvalues:
3-element Array{Float64,1}:
  1.0
  3.0
 18.0
eigenvectors:
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; F.values
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia&gt; F.vectors
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; vals, vecs = F; # destructuring via iteration

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L66-L114">source</a><pre>eigen(A, B) -&gt; GeneralizedEigen</pre>
<p>Computes the generalized eigenvalue decomposition of <code>A</code> and <code>B</code>, returning a <code>GeneralizedEigen</code> factorization object <code>F</code> which contains the generalized eigenvalues in <code>F.values</code> and the generalized eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th generalized eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p>
<p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; F = eigen(A, B);

julia&gt; F.values
2-element Array{Complex{Float64},1}:
 0.0 + 1.0im
 0.0 - 1.0im

julia&gt; F.vectors
2×2 Array{Complex{Float64},2}:
  0.0-1.0im   0.0+1.0im
 -1.0-0.0im  -1.0+0.0im

julia&gt; vals, vecs = F; # destructuring via iteration

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L341-L380">source</a><pre>eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; Eigen</pre>
<p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F.values</code> and the eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p>
<p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p>
<p>The following functions are available for <code>Eigen</code> objects: <a href="#"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, and <a href="#LinearAlgebra.isposdef"><code>isposdef</code></a>.</p>
<p>The <code>UnitRange</code> <code>irange</code> specifies indices of the sorted eigenvalues to search for.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>If <code>irange</code> is not <code>1:n</code>, where <code>n</code> is the dimension of <code>A</code>, then the returned factorization will be a <em>truncated</em> factorization.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/symmetric.jl#L497-L513">source</a><pre>eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; Eigen</pre>
<p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F.values</code> and the eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p>
<p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p>
<p>The following functions are available for <code>Eigen</code> objects: <a href="#"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, and <a href="#LinearAlgebra.isposdef"><code>isposdef</code></a>.</p>
<p><code>vl</code> is the lower bound of the window of eigenvalues to search for, and <code>vu</code> is the upper bound.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>If [<code>vl</code>, <code>vu</code>] does not contain all eigenvalues of <code>A</code>, then the returned factorization will be a <em>truncated</em> factorization.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/symmetric.jl#L523-L539">source</a><h3 id="LinearAlgebra.eigen!">
<code>LinearAlgebra.eigen!</code><span class="docstring-category">Function</span>
</h3>
<pre>eigen!(A, [B])</pre>
<p>Same as <a href="#LinearAlgebra.eigen"><code>eigen</code></a>, but saves space by overwriting the input <code>A</code> (and <code>B</code>), instead of creating a copy.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/eigen.jl#L30-L35">source</a><h3 id="LinearAlgebra.hessenberg">
<code>LinearAlgebra.hessenberg</code><span class="docstring-category">Function</span>
</h3>
<pre>hessenberg(A) -&gt; Hessenberg</pre>
<p>Compute the Hessenberg decomposition of <code>A</code> and return a <code>Hessenberg</code> object. If <code>F</code> is the factorization object, the unitary matrix can be accessed with <code>F.Q</code> and the Hessenberg matrix with <code>F.H</code>. When <code>Q</code> is extracted, the resulting type is the <code>HessenbergQ</code> object, and may be converted to a regular matrix with <a href="https://docs.julialang.org/en/v1.0.1/base/base/#Base.convert" target="_blank"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short).</p>
<p>Iterating the decomposition produces the factors <code>F.Q</code> and <code>F.H</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia&gt; F = hessenberg(A);

julia&gt; F.Q * F.H * F.Q'
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia&gt; q, h = F; # destructuring via iteration

julia&gt; q == F.Q &amp;&amp; h == F.H
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/hessenberg.jl#L34-L66">source</a><h3 id="LinearAlgebra.hessenberg!">
<code>LinearAlgebra.hessenberg!</code><span class="docstring-category">Function</span>
</h3>
<pre>hessenberg!(A) -&gt; Hessenberg</pre>
<p><code>hessenberg!</code> is the same as <a href="#LinearAlgebra.hessenberg"><code>hessenberg</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/hessenberg.jl#L24-L29">source</a><h3 id="LinearAlgebra.schur!">
<code>LinearAlgebra.schur!</code><span class="docstring-category">Function</span>
</h3>
<pre>schur!(A::StridedMatrix) -&gt; F::Schur</pre>
<p>Same as <a href="#LinearAlgebra.schur"><code>schur</code></a> but uses the input argument <code>A</code> as workspace.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schur!(A)
Schur{Float64,Array{Float64,2}}
T factor:
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2×2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia&gt; A
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/schur.jl#L18-L50">source</a><pre>schur!(A::StridedMatrix, B::StridedMatrix) -&gt; F::GeneralizedSchur</pre>
<p>Same as <a href="#LinearAlgebra.schur"><code>schur</code></a> but uses the input matrices <code>A</code> and <code>B</code> as workspace.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/schur.jl#L184-L188">source</a><h3 id="LinearAlgebra.schur">
<code>LinearAlgebra.schur</code><span class="docstring-category">Function</span>
</h3>
<pre>schur(A::StridedMatrix) -&gt; F::Schur</pre>
<p>Computes the Schur factorization of the matrix <code>A</code>. The (quasi) triangular Schur factor can be obtained from the <code>Schur</code> object <code>F</code> with either <code>F.Schur</code> or <code>F.T</code> and the orthogonal/unitary Schur vectors can be obtained with <code>F.vectors</code> or <code>F.Z</code> such that <code>A = F.vectors * F.Schur * F.vectors'</code>. The eigenvalues of <code>A</code> can be obtained with <code>F.values</code>.</p>
<p>Iterating the decomposition produces the components <code>F.T</code>, <code>F.Z</code>, and <code>F.values</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schur(A)
Schur{Float64,Array{Float64,2}}
T factor:
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2×2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia&gt; F.vectors * F.Schur * F.vectors'
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; t, z, vals = F; # destructuring via iteration

julia&gt; t == F.T &amp;&amp; z == F.Z &amp;&amp; vals == F.values
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/schur.jl#L53-L95">source</a><pre>schur(A::StridedMatrix, B::StridedMatrix) -&gt; F::GeneralizedSchur</pre>
<p>Computes the Generalized Schur (or QZ) factorization of the matrices <code>A</code> and <code>B</code>. The (quasi) triangular Schur factors can be obtained from the <code>Schur</code> object <code>F</code> with <code>F.S</code> and <code>F.T</code>, the left unitary/orthogonal Schur vectors can be obtained with <code>F.left</code> or <code>F.Q</code> and the right unitary/orthogonal Schur vectors can be obtained with <code>F.right</code> or <code>F.Z</code> such that <code>A=F.left*F.S*F.right'</code> and <code>B=F.left*F.T*F.right'</code>. The generalized eigenvalues of <code>A</code> and <code>B</code> can be obtained with <code>F.α./F.β</code>.</p>
<p>Iterating the decomposition produces the components <code>F.S</code>, <code>F.T</code>, <code>F.Q</code>, <code>F.Z</code>, <code>F.α</code>, and <code>F.β</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/schur.jl#L192-L204">source</a><h3 id="LinearAlgebra.ordschur">
<code>LinearAlgebra.ordschur</code><span class="docstring-category">Function</span>
</h3>
<pre>ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur</pre>
<p>Reorders the Schur factorization <code>F</code> of a matrix <code>A = Z*T*Z'</code> according to the logical array <code>select</code> returning the reordered factorization <code>F</code> object. The selected eigenvalues appear in the leading diagonal of <code>F.Schur</code> and the corresponding leading columns of <code>F.vectors</code> form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via <code>select</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/schur.jl#L145-L154">source</a><pre>ordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur</pre>
<p>Reorders the Generalized Schur factorization <code>F</code> of a matrix pair <code>(A, B) = (Q*S*Z', Q*T*Z')</code> according to the logical array <code>select</code> and returns a GeneralizedSchur object <code>F</code>. The selected eigenvalues appear in the leading diagonal of both <code>F.S</code> and <code>F.T</code>, and the left and right orthogonal/unitary Schur vectors are also reordered such that <code>(A, B) = F.Q*(F.S, F.T)*F.Z'</code> still holds and the generalized eigenvalues of <code>A</code> and <code>B</code> can still be obtained with <code>F.α./F.β</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/schur.jl#L231-L240">source</a><h3 id="LinearAlgebra.ordschur!">
<code>LinearAlgebra.ordschur!</code><span class="docstring-category">Function</span>
</h3>
<pre>ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur</pre>
<p>Same as <a href="#LinearAlgebra.ordschur"><code>ordschur</code></a> but overwrites the factorization <code>F</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/schur.jl#L128-L132">source</a><pre>ordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur</pre>
<p>Same as <code>ordschur</code> but overwrites the factorization <code>F</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/schur.jl#L211-L215">source</a><h3 id="LinearAlgebra.svd">
<code>LinearAlgebra.svd</code><span class="docstring-category">Function</span>
</h3>
<pre>svd(A; full::Bool = false) -&gt; SVD</pre>
<p>Compute the singular value decomposition (SVD) of <code>A</code> and return an <code>SVD</code> object.</p>
<p><code>U</code>, <code>S</code>, <code>V</code> and <code>Vt</code> can be obtained from the factorization <code>F</code> with <code>F.U</code>, <code>F.S</code>, <code>F.V</code> and <code>F.Vt</code>, such that <code>A = U * Diagonal(S) * Vt</code>. The algorithm produces <code>Vt</code> and hence <code>Vt</code> is more efficient to extract than <code>V</code>. The singular values in <code>S</code> are sorted in descending order.</p>
<p>Iterating the decomposition produces the components <code>U</code>, <code>S</code>, and <code>V</code>.</p>
<p>If <code>full = false</code> (default), a "thin" SVD is returned. For a <span>$M \times N$</span> matrix <code>A</code>, in the full factorization <code>U</code> is <code>M \times M</code> and <code>V</code> is <code>N \times N</code>, while in the thin factorization <code>U</code> is <code>M \times K</code> and <code>V</code> is <code>N \times K</code>, where <code>K = \min(M,N)</code> is the number of singular values.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; F = svd(A);

julia&gt; F.U * Diagonal(F.S) * F.Vt
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/svd.jl#L68-L104">source</a><pre>svd(A, B) -&gt; GeneralizedSVD</pre>
<p>Compute the generalized SVD of <code>A</code> and <code>B</code>, returning a <code>GeneralizedSVD</code> factorization object <code>F</code>, such that <code>A = F.U*F.D1*F.R0*F.Q'</code> and <code>B = F.V*F.D2*F.R0*F.Q'</code>.</p>
<p>For an M-by-N matrix <code>A</code> and P-by-N matrix <code>B</code>,</p>
<ul>
<li>
<code>U</code> is a M-by-M orthogonal matrix,</li>
<li>
<code>V</code> is a P-by-P orthogonal matrix,</li>
<li>
<code>Q</code> is a N-by-N orthogonal matrix,</li>
<li>
<code>D1</code> is a M-by-(K+L) diagonal matrix with 1s in the first K entries,</li>
<li>
<code>D2</code> is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,</li>
<li>
<code>R0</code> is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is nonsingular upper block triangular,</li>
</ul>
<p><code>K+L</code> is the effective numerical rank of the matrix <code>[A; B]</code>.</p>
<p>Iterating the decomposition produces the components <code>U</code>, <code>V</code>, <code>Q</code>, <code>D1</code>, <code>D2</code>, and <code>R0</code>.</p>
<p>The entries of <code>F.D1</code> and <code>F.D2</code> are related, as explained in the LAPACK documentation for the <a href="http://www.netlib.org/lapack/lug/node36.html" target="_blank">generalized SVD</a> and the <a href="http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html" target="_blank">xGGSVD3</a> routine which is called underneath (in LAPACK 3.6.0 and newer).</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; F = svd(A, B);

julia&gt; F.U*F.D1*F.R0*F.Q'
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; F.V*F.D2*F.R0*F.Q'
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/svd.jl#L283-L333">source</a><h3 id="LinearAlgebra.svd!">
<code>LinearAlgebra.svd!</code><span class="docstring-category">Function</span>
</h3>
<pre>svd!(A; full::Bool = false) -&gt; SVD</pre>
<p><code>svd!</code> is the same as <a href="#LinearAlgebra.svd"><code>svd</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; F = svd!(A);

julia&gt; F.U * Diagonal(F.S) * F.Vt
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; A
4×5 Array{Float64,2}:
 -2.23607   0.0   0.0  0.0  0.618034
  0.0      -3.0   1.0  0.0  0.0
  0.0       0.0   0.0  0.0  0.0
  0.0       0.0  -2.0  0.0  0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/svd.jl#L26-L57">source</a><pre>svd!(A, B) -&gt; GeneralizedSVD</pre>
<p><code>svd!</code> is the same as <a href="#LinearAlgebra.svd"><code>svd</code></a>, but modifies the arguments <code>A</code> and <code>B</code> in-place, instead of making copies.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; F = svd!(A, B);

julia&gt; F.U*F.D1*F.R0*F.Q'
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; F.V*F.D2*F.R0*F.Q'
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; A
2×2 Array{Float64,2}:
 1.41421   0.0
 0.0      -1.41421

julia&gt; B
2×2 Array{Float64,2}:
 1.0  -0.0
 0.0  -1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/svd.jl#L231-L271">source</a><h3 id="LinearAlgebra.svdvals">
<code>LinearAlgebra.svdvals</code><span class="docstring-category">Function</span>
</h3>
<pre>svdvals(A)</pre>
<p>Return the singular values of <code>A</code> in descending order.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; svdvals(A)
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/svd.jl#L167-L188">source</a><pre>svdvals(A, B)</pre>
<p>Return the generalized singular values from the generalized singular value decomposition of <code>A</code> and <code>B</code>. See also <a href="#LinearAlgebra.svd"><code>svd</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; svdvals(A, B)
2-element Array{Float64,1}:
 1.0
 1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/svd.jl#L432-L455">source</a><h3 id="LinearAlgebra.svdvals!">
<code>LinearAlgebra.svdvals!</code><span class="docstring-category">Function</span>
</h3>
<pre>svdvals!(A)</pre>
<p>Return the singular values of <code>A</code>, saving space by overwriting the input. See also <a href="#LinearAlgebra.svdvals"><code>svdvals</code></a> and <a href="#LinearAlgebra.svd"><code>svd</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; svdvals!(A)
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0

julia&gt; A
4×5 Array{Float64,2}:
 -2.23607   0.0   0.0  0.0  0.618034
  0.0      -3.0   1.0  0.0  0.0
  0.0       0.0   0.0  0.0  0.0
  0.0       0.0  -2.0  0.0  0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/svd.jl#L134-L163">source</a><pre>svdvals!(A, B)</pre>
<p>Return the generalized singular values from the generalized singular value decomposition of <code>A</code> and <code>B</code>, saving space by overwriting <code>A</code> and <code>B</code>. See also <a href="#LinearAlgebra.svd"><code>svd</code></a> and <a href="#LinearAlgebra.svdvals"><code>svdvals</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; svdvals!(A, B)
2-element Array{Float64,1}:
 1.0
 1.0

julia&gt; A
2×2 Array{Float64,2}:
 1.41421   0.0
 0.0      -1.41421

julia&gt; B
2×2 Array{Float64,2}:
 1.0  -0.0
 0.0  -1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/svd.jl#L386-L420">source</a><h3 id="LinearAlgebra.Givens">
<code>LinearAlgebra.Givens</code><span class="docstring-category">Type</span>
</h3>
<pre>LinearAlgebra.Givens(i1,i2,c,s) -&gt; G</pre>
<p>A Givens rotation linear operator. The fields <code>c</code> and <code>s</code> represent the cosine and sine of the rotation angle, respectively. The <code>Givens</code> type supports left multiplication <code>G*A</code> and conjugated transpose right multiplication <code>A*G'</code>. The type doesn't have a <code>size</code> and can therefore be multiplied with matrices of arbitrary size as long as <code>i2&lt;=size(A,2)</code> for <code>G*A</code> or <code>i2&lt;=size(A,1)</code> for <code>A*G'</code>.</p>
<p>See also: <a href="#LinearAlgebra.givens"><code>givens</code></a></p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/givens.jl#L25-L35">source</a><h3 id="LinearAlgebra.givens">
<code>LinearAlgebra.givens</code><span class="docstring-category">Function</span>
</h3>
<pre>givens(f::T, g::T, i1::Integer, i2::Integer) where {T} -&gt; (G::Givens, r::T)</pre>
<p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that for any vector <code>x</code> where</p>
<pre>x[i1] = f
x[i2] = g</pre>
<p>the result of the multiplication</p>
<pre>y = G*x</pre>
<p>has the property that</p>
<pre>y[i1] = r
y[i2] = 0</pre>
<p>See also: <a href="#LinearAlgebra.Givens"><code>LinearAlgebra.Givens</code></a></p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/givens.jl#L251-L271">source</a><pre>givens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -&gt; (G::Givens, r)</pre>
<p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that the result of the multiplication</p>
<pre>B = G*A</pre>
<p>has the property that</p>
<pre>B[i1,j] = r
B[i2,j] = 0</pre>
<p>See also: <a href="#LinearAlgebra.Givens"><code>LinearAlgebra.Givens</code></a></p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/givens.jl#L283-L297">source</a><pre>givens(x::AbstractVector, i1::Integer, i2::Integer) -&gt; (G::Givens, r)</pre>
<p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that the result of the multiplication</p>
<pre>B = G*x</pre>
<p>has the property that</p>
<pre>B[i1] = r
B[i2] = 0</pre>
<p>See also: <a href="#LinearAlgebra.Givens"><code>LinearAlgebra.Givens</code></a></p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/givens.jl#L302-L316">source</a><h3 id="LinearAlgebra.triu">
<code>LinearAlgebra.triu</code><span class="docstring-category">Function</span>
</h3>
<pre>triu(M)</pre>
<p>Upper triangle of a matrix.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0
 0.0  0.0  0.0  1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L121-L142">source</a><pre>triu(M, k::Integer)</pre>
<p>Returns the upper triangle of <code>M</code> starting from the <code>k</code>th superdiagonal.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a,3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia&gt; triu(a,-3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L169-L197">source</a><h3 id="LinearAlgebra.triu!">
<code>LinearAlgebra.triu!</code><span class="docstring-category">Function</span>
</h3>
<pre>triu!(M)</pre>
<p>Upper triangle of a matrix, overwriting <code>M</code> in the process. See also <a href="#LinearAlgebra.triu"><code>triu</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L231-L236">source</a><pre>triu!(M, k::Integer)</pre>
<p>Return the upper triangle of <code>M</code> starting from the <code>k</code>th superdiagonal, overwriting <code>M</code> in the process.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; triu!(M, 1)
5×5 Array{Int64,2}:
 0  2  3  4  5
 0  0  3  4  5
 0  0  0  4  5
 0  0  0  0  5
 0  0  0  0  0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L146-L170">source</a><h3 id="LinearAlgebra.tril">
<code>LinearAlgebra.tril</code><span class="docstring-category">Function</span>
</h3>
<pre>tril(M)</pre>
<p>Lower triangle of a matrix.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a)
4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 1.0  1.0  0.0  0.0
 1.0  1.0  1.0  0.0
 1.0  1.0  1.0  1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L145-L166">source</a><pre>tril(M, k::Integer)</pre>
<p>Returns the lower triangle of <code>M</code> starting from the <code>k</code>th superdiagonal.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,-3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L200-L228">source</a><h3 id="LinearAlgebra.tril!">
<code>LinearAlgebra.tril!</code><span class="docstring-category">Function</span>
</h3>
<pre>tril!(M)</pre>
<p>Lower triangle of a matrix, overwriting <code>M</code> in the process. See also <a href="#LinearAlgebra.tril"><code>tril</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L239-L244">source</a><pre>tril!(M, k::Integer)</pre>
<p>Return the lower triangle of <code>M</code> starting from the <code>k</code>th superdiagonal, overwriting <code>M</code> in the process.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; tril!(M, 2)
5×5 Array{Int64,2}:
 1  2  3  0  0
 1  2  3  4  0
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L184-L208">source</a><h3 id="LinearAlgebra.diagind">
<code>LinearAlgebra.diagind</code><span class="docstring-category">Function</span>
</h3>
<pre>diagind(M, k::Integer=0)</pre>
<p>An <code>AbstractRange</code> giving the indices of the <code>k</code>th diagonal of the matrix <code>M</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diagind(A,-1)
2:4:6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L241-L257">source</a><h3 id="LinearAlgebra.diag">
<code>LinearAlgebra.diag</code><span class="docstring-category">Function</span>
</h3>
<pre>diag(M, k::Integer=0)</pre>
<p>The <code>k</code>th diagonal of a matrix, as a vector.</p>
<p>See also: <a href="#LinearAlgebra.diagm"><code>diagm</code></a></p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diag(A,1)
2-element Array{Int64,1}:
 2
 6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L263-L283">source</a><h3 id="LinearAlgebra.diagm">
<code>LinearAlgebra.diagm</code><span class="docstring-category">Function</span>
</h3>
<pre>diagm(kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)</pre>
<p>Construct a square matrix from <code>Pair</code>s of diagonals and vectors. Vector <code>kv.second</code> will be placed on the <code>kv.first</code> diagonal. <code>diagm</code> constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see <a href="#LinearAlgebra.Diagonal"><code>Diagonal</code></a>, <a href="#LinearAlgebra.Bidiagonal"><code>Bidiagonal</code></a> <a href="#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a> and <a href="#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; diagm(1 =&gt; [1,2,3])
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  2  0
 0  0  0  3
 0  0  0  0

julia&gt; diagm(1 =&gt; [1,2,3], -1 =&gt; [4,5])
4×4 Array{Int64,2}:
 0  1  0  0
 4  0  2  0
 0  5  0  3
 0  0  0  0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L286-L311">source</a><h3 id="LinearAlgebra.rank">
<code>LinearAlgebra.rank</code><span class="docstring-category">Function</span>
</h3>
<pre>rank(A[, tol::Real])</pre>
<p>Compute the rank of a matrix by counting how many singular values of <code>A</code> have magnitude greater than <code>tol*σ₁</code> where <code>σ₁</code> is <code>A</code>'s largest singular values. By default, the value of <code>tol</code> is the smallest dimension of <code>A</code> multiplied by the <a href="../dates/#Base.eps"><code>eps</code></a> of the <a href="https://docs.julialang.org/en/v1.0.1/base/collections/#Base.eltype" target="_blank"><code>eltype</code></a> of <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; rank(Matrix(I, 3, 3))
3

julia&gt; rank(diagm(0 =&gt; [1, 0, 2]))
2

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), 0.1)
2

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), 0.00001)
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L717-L740">source</a><h3 id="LinearAlgebra.norm">
<code>LinearAlgebra.norm</code><span class="docstring-category">Function</span>
</h3>
<pre>norm(A, p::Real=2)</pre>
<p>For any iterable container <code>A</code> (including arrays of any dimension) of numbers (or any element type for which <code>norm</code> is defined), compute the <code>p</code>-norm (defaulting to <code>p=2</code>) as if <code>A</code> were a vector of the corresponding length.</p>
<p>The <code>p</code>-norm is defined as</p>\[\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\]<p>with <span>$a_i$</span> the entries of <span>$A$</span>, <span>$| a_i |$</span> the <a href="#LinearAlgebra.norm"><code>norm</code></a> of <span>$a_i$</span>, and <span>$n$</span> the length of <span>$A$</span>. Since the <code>p</code>-norm is computed using the <a href="#LinearAlgebra.norm"><code>norm</code></a>s of the entries of <code>A</code>, the <code>p</code>-norm of a vector of vectors is not compatible with the interpretation of it as a block vector in general if <code>p != 2</code>.</p>
<p><code>p</code> can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, <code>norm(A, Inf)</code> returns the largest value in <code>abs.(A)</code>, whereas <code>norm(A, -Inf)</code> returns the smallest. If <code>A</code> is a matrix and <code>p=2</code>, then this is equivalent to the Frobenius norm.</p>
<p>The second argument <code>p</code> is not necessarily a part of the interface for <code>norm</code>, i.e. a custom type may only implement <code>norm(A)</code> without second argument.</p>
<p>Use <a href="#LinearAlgebra.opnorm"><code>opnorm</code></a> to compute the operator norm of a matrix.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; v = [3, -2, 6]
3-element Array{Int64,1}:
  3
 -2
  6

julia&gt; norm(v)
7.0

julia&gt; norm(v, 1)
11.0

julia&gt; norm(v, Inf)
6.0

julia&gt; norm([1 2 3; 4 5 6; 7 8 9])
16.881943016134134

julia&gt; norm([1 2 3 4 5 6 7 8 9])
16.881943016134134

julia&gt; norm(1:9)
16.881943016134134

julia&gt; norm(hcat(v,v), 1) == norm(vcat(v,v), 1) != norm([v,v], 1)
true

julia&gt; norm(hcat(v,v), 2) == norm(vcat(v,v), 2) == norm([v,v], 2)
true

julia&gt; norm(hcat(v,v), Inf) == norm(vcat(v,v), Inf) != norm([v,v], Inf)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L364-L425">source</a><pre>norm(x::Number, p::Real=2)</pre>
<p>For numbers, return <span>$\left( |x|^p \right)^{1/p}$</span>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; norm(2, 1)
2

julia&gt; norm(-2, 1)
2

julia&gt; norm(2, 2)
2

julia&gt; norm(-2, 2)
2

julia&gt; norm(2, Inf)
2

julia&gt; norm(-2, Inf)
2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L443-L468">source</a><h3 id="LinearAlgebra.opnorm">
<code>LinearAlgebra.opnorm</code><span class="docstring-category">Function</span>
</h3>
<pre>opnorm(A::AbstractMatrix, p::Real=2)</pre>
<p>Compute the operator norm (or matrix norm) induced by the vector <code>p</code>-norm, where valid values of <code>p</code> are <code>1</code>, <code>2</code>, or <code>Inf</code>. (Note that for sparse matrices, <code>p=2</code> is currently not implemented.) Use <a href="#LinearAlgebra.norm"><code>norm</code></a> to compute the Frobenius norm.</p>
<p>When <code>p=1</code>, the operator norm is the maximum absolute column sum of <code>A</code>:</p>\[\|A\|_1 = \max_{1 ≤ j ≤ n} \sum_{i=1}^m | a_{ij} |\]<p>with <span>$a_{ij}$</span> the entries of <span>$A$</span>, and <span>$m$</span> and <span>$n$</span> its dimensions.</p>
<p>When <code>p=2</code>, the operator norm is the spectral norm, equal to the largest singular value of <code>A</code>.</p>
<p>When <code>p=Inf</code>, the operator norm is the maximum absolute row sum of <code>A</code>:</p>\[\|A\|_\infty = \max_{1 ≤ i ≤ m} \sum _{j=1}^n | a_{ij} |\]<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 -2 -3; 2 3 -1]
2×3 Array{Int64,2}:
 1  -2  -3
 2   3  -1

julia&gt; opnorm(A, Inf)
6.0

julia&gt; opnorm(A, 1)
5.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L518-L553">source</a><pre>opnorm(x::Number, p::Real=2)</pre>
<p>For numbers, return <span>$\left( |x|^p \right)^{1/p}$</span>. This is equivalent to <a href="#LinearAlgebra.norm"><code>norm</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L566-L571">source</a><pre>opnorm(A::Adjoint{&lt;:Any,&lt;:AbstracVector}, q::Real=2)
opnorm(A::Transpose{&lt;:Any,&lt;:AbstracVector}, q::Real=2)</pre>
<p>For Adjoint/Transpose-wrapped vectors, return the operator <span>$q$</span>-norm of <code>A</code>, which is equivalent to the <code>p</code>-norm with value <code>p = q/(q-1)</code>. They coincide at <code>p = q = 2</code>. Use <a href="#LinearAlgebra.norm"><code>norm</code></a> to compute the <code>p</code> norm of <code>A</code> as a vector.</p>
<p>The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator <code>p</code>-norm of a <code>1 × n</code> matrix.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; v = [1; im];

julia&gt; vc = v';

julia&gt; opnorm(vc, 1)
1.0

julia&gt; norm(vc, 1)
2.0

julia&gt; norm(v, 1)
2.0

julia&gt; opnorm(vc, 2)
1.4142135623730951

julia&gt; norm(vc, 2)
1.4142135623730951

julia&gt; norm(v, 2)
1.4142135623730951

julia&gt; opnorm(vc, Inf)
2.0

julia&gt; norm(vc, Inf)
1.0

julia&gt; norm(v, Inf)
1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L574-L619">source</a><h3 id="LinearAlgebra.normalize!">
<code>LinearAlgebra.normalize!</code><span class="docstring-category">Function</span>
</h3>
<pre>normalize!(v::AbstractVector, p::Real=2)</pre>
<p>Normalize the vector <code>v</code> in-place so that its <code>p</code>-norm equals unity, i.e. <code>norm(v, p) == 1</code>. See also <a href="#LinearAlgebra.normalize"><code>normalize</code></a> and <a href="#LinearAlgebra.norm"><code>norm</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L1348-L1354">source</a><h3 id="LinearAlgebra.normalize">
<code>LinearAlgebra.normalize</code><span class="docstring-category">Function</span>
</h3>
<pre>normalize(v::AbstractVector, p::Real=2)</pre>
<p>Normalize the vector <code>v</code> so that its <code>p</code>-norm equals unity, i.e. <code>norm(v, p) == vecnorm(v, p) == 1</code>. See also <a href="#LinearAlgebra.normalize!"><code>normalize!</code></a> and <a href="#LinearAlgebra.norm"><code>norm</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = [1,2,4];

julia&gt; b = normalize(a)
3-element Array{Float64,1}:
 0.2182178902359924
 0.4364357804719848
 0.8728715609439696

julia&gt; norm(b)
1.0

julia&gt; c = normalize(a, 1)
3-element Array{Float64,1}:
 0.14285714285714285
 0.2857142857142857
 0.5714285714285714

julia&gt; norm(c, 1)
1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L1377-L1406">source</a><h3 id="LinearAlgebra.cond">
<code>LinearAlgebra.cond</code><span class="docstring-category">Function</span>
</h3>
<pre>cond(M, p::Real=2)</pre>
<p>Condition number of the matrix <code>M</code>, computed using the operator <code>p</code>-norm. Valid values for <code>p</code> are <code>1</code>, <code>2</code> (default), or <code>Inf</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1344-L1349">source</a><h3 id="LinearAlgebra.condskeel">
<code>LinearAlgebra.condskeel</code><span class="docstring-category">Function</span>
</h3>
<pre>condskeel(M, [x, p::Real=Inf])</pre>\[\kappa_S(M, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \right\Vert_p \\ \kappa_S(M, x, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p\]<p>Skeel condition number <span>$\kappa_S$</span> of the matrix <code>M</code>, optionally with respect to the vector <code>x</code>, as computed using the operator <code>p</code>-norm. <span>$\left\vert M \right\vert$</span> denotes the matrix of (entry wise) absolute values of <span>$M$</span>; <span>$\left\vert M \right\vert_{ij} = \left\vert M_{ij} \right\vert$</span>. Valid values for <code>p</code> are <code>1</code>, <code>2</code> and <code>Inf</code> (default).</p>
<p>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L887-L903">source</a><h3 id="LinearAlgebra.tr">
<code>LinearAlgebra.tr</code><span class="docstring-category">Function</span>
</h3>
<pre>tr(M)</pre>
<p>Matrix trace. Sums the diagonal elements of <code>M</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; tr(A)
5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L747-L762">source</a><h3 id="LinearAlgebra.det">
<code>LinearAlgebra.det</code><span class="docstring-category">Function</span>
</h3>
<pre>det(M)</pre>
<p>Matrix determinant.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia&gt; det(M)
2.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L1221-L1236">source</a><h3 id="LinearAlgebra.logdet">
<code>LinearAlgebra.logdet</code><span class="docstring-category">Function</span>
</h3>
<pre>logdet(M)</pre>
<p>Log of matrix determinant. Equivalent to <code>log(det(M))</code>, but may provide increased accuracy and/or speed.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia&gt; logdet(M)
0.6931471805599453

julia&gt; logdet(Matrix(I, 3, 3))
0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L1279-L1298">source</a><h3 id="LinearAlgebra.logabsdet">
<code>LinearAlgebra.logabsdet</code><span class="docstring-category">Function</span>
</h3>
<pre>logabsdet(M)</pre>
<p>Log of absolute value of matrix determinant. Equivalent to <code>(log(abs(det(M))), sign(det(M)))</code>, but may provide increased accuracy and/or speed.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [-1. 0.; 0. 1.]
2×2 Array{Float64,2}:
 -1.0  0.0
  0.0  1.0

julia&gt; det(A)
-1.0

julia&gt; logabsdet(A)
(0.0, -1.0)

julia&gt; B = [2. 0.; 0. 1.]
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  1.0

julia&gt; det(B)
2.0

julia&gt; logabsdet(B)
(0.6931471805599453, 1.0)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L1246-L1276">source</a><h3 id="Base.inv-Tuple{AbstractArray{T,2} where T}">
<code>Base.inv</code><span class="docstring-category">Method</span>
</h3>
<pre>inv(M)</pre>
<p>Matrix inverse. Computes matrix <code>N</code> such that <code>M * N = I</code>, where <code>I</code> is the identity matrix. Computed by solving the left-division <code>N = M \ I</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; M = [2 5; 1 3]
2×2 Array{Int64,2}:
 2  5
 1  3

julia&gt; N = inv(M)
2×2 Array{Float64,2}:
  3.0  -5.0
 -1.0   2.0

julia&gt; M*N == N*M == Matrix(I, 2, 2)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L774-L797">source</a><h3 id="LinearAlgebra.pinv">
<code>LinearAlgebra.pinv</code><span class="docstring-category">Function</span>
</h3>
<pre>pinv(M[, tol::Real])</pre>
<p>Computes the Moore-Penrose pseudoinverse.</p>
<p>For matrices <code>M</code> with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values above a given threshold, <code>tol</code>.</p>
<p>The optimal choice of <code>tol</code> varies both with the value of <code>M</code> and the intended application of the pseudoinverse. The default value of <code>tol</code> is <code>eps(real(float(one(eltype(M)))))*minimum(size(M))</code>, which is essentially machine epsilon for the real part of a matrix element multiplied by the larger matrix dimension. For inverting dense ill-conditioned matrices in a least-squares sense, <code>tol = sqrt(eps(real(float(one(eltype(M))))))</code> is recommended.</p>
<p>For more information, see <a href="#footnote-issue8859">[issue8859]</a>, <a href="#footnote-B96">[B96]</a>, <a href="#footnote-S84">[S84]</a>, <a href="#footnote-KY88">[KY88]</a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; M = [1.5 1.3; 1.2 1.9]
2×2 Array{Float64,2}:
 1.5  1.3
 1.2  1.9

julia&gt; N = pinv(M)
2×2 Array{Float64,2}:
  1.47287   -1.00775
 -0.930233   1.16279

julia&gt; M * N
2×2 Array{Float64,2}:
 1.0          -2.22045e-16
 4.44089e-16   1.0</pre>
<div class="footnote" id="footnote-issue8859">
<a href="#footnote-issue8859"><strong>[issue8859]</strong></a><p>Issue 8859, "Fix least squares", https://github.com/JuliaLang/julia/pull/8859</p>
</div>
<div class="footnote" id="footnote-B96">
<a href="#footnote-B96"><strong>[B96]</strong></a><p>Åke Björck, "Numerical Methods for Least Squares Problems", SIAM Press, Philadelphia, 1996, "Other Titles in Applied Mathematics", Vol. 51. <a href="http://epubs.siam.org/doi/book/10.1137/1.9781611971484" target="_blank">doi:10.1137/1.9781611971484</a></p>
</div>
<div class="footnote" id="footnote-S84">
<a href="#footnote-S84"><strong>[S84]</strong></a><p>G. W. Stewart, "Rank Degeneracy", SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. <a href="http://epubs.siam.org/doi/abs/10.1137/0905030" target="_blank">doi:10.1137/0905030</a></p>
</div>
<div class="footnote" id="footnote-KY88">
<a href="#footnote-KY88"><strong>[KY88]</strong></a><p>Konstantinos Konstantinides and Kung Yao, "Statistical analysis of effective singular values in matrix rank determination", IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. <a href="https://doi.org/10.1109/29.1585" target="_blank">doi:10.1109/29.1585</a></p>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1221-L1264">source</a><h3 id="LinearAlgebra.nullspace">
<code>LinearAlgebra.nullspace</code><span class="docstring-category">Function</span>
</h3>
<pre>nullspace(M[, tol::Real])</pre>
<p>Computes a basis for the nullspace of <code>M</code> by including the singular vectors of A whose singular have magnitude are greater than <code>tol*σ₁</code>, where <code>σ₁</code> is <code>A</code>'s largest singular values. By default, the value of <code>tol</code> is the smallest dimension of <code>A</code> multiplied by the <a href="../dates/#Base.eps"><code>eps</code></a> of the <a href="https://docs.julialang.org/en/v1.0.1/base/collections/#Base.eltype" target="_blank"><code>eltype</code></a> of <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; M = [1 0 0; 0 1 0; 0 0 0]
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  0

julia&gt; nullspace(M)
3×1 Array{Float64,2}:
 0.0
 0.0
 1.0

julia&gt; nullspace(M, 2)
3×3 Array{Float64,2}:
 0.0  1.0  0.0
 1.0  0.0  0.0
 0.0  0.0  1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1305-L1334">source</a><h3 id="Base.kron">
<code>Base.kron</code><span class="docstring-category">Function</span>
</h3>
<pre>kron(A, B)</pre>
<p>Kronecker tensor product of two vectors or two matrices.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; B = [im 1; 1 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  1+0im
 1+0im  0-1im

julia&gt; kron(A, B)
4×4 Array{Complex{Int64},2}:
 0+1im  1+0im  0+2im  2+0im
 1+0im  0-1im  2+0im  0-2im
 0+3im  3+0im  0+4im  4+0im
 3+0im  0-3im  4+0im  0-4im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L342-L366">source</a><h3 id="Base.exp-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}">
<code>Base.exp</code><span class="docstring-category">Method</span>
</h3>
<pre>exp(A::AbstractMatrix)</pre>
<p>Compute the matrix exponential of <code>A</code>, defined by</p>\[e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\]<p>For symmetric or Hermitian <code>A</code>, an eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used, otherwise the scaling and squaring algorithm (see <a href="#footnote-H05">[H05]</a>) is chosen.</p>
<div class="footnote" id="footnote-H05">
<a href="#footnote-H05"><strong>[H05]</strong></a><p>Nicholas J. Higham, "The squaring and scaling method for the matrix exponential revisited", SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. <a href="https://doi.org/10.1137/090768539" target="_blank">doi:10.1137/090768539</a></p>
</div>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = Matrix(1.0I, 2, 2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia&gt; exp(A)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L462-L488">source</a><h3 id="Base.log-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.log</code><span class="docstring-category">Method</span>
</h3>
<pre>log(A{T}::StridedMatrix{T})</pre>
<p>If <code>A</code> has no negative real eigenvalue, compute the principal matrix logarithm of <code>A</code>, i.e. the unique matrix <span>$X$</span> such that <span>$e^X = A$</span> and <span>$-\pi &lt; Im(\lambda) &lt; \pi$</span> for all the eigenvalues <span>$\lambda$</span> of <span>$X$</span>. If <code>A</code> has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</p>
<p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used, if <code>A</code> is triangular an improved version of the inverse scaling and squaring method is employed (see <a href="#footnote-AH12">[AH12]</a> and <a href="#footnote-AHR13">[AHR13]</a>). For general matrices, the complex Schur form (<a href="#LinearAlgebra.schur"><code>schur</code></a>) is computed and the triangular algorithm is used on the triangular factor.</p>
<div class="footnote" id="footnote-AH12">
<a href="#footnote-AH12"><strong>[AH12]</strong></a><p>Awad H. Al-Mohy and Nicholas J. Higham, "Improved inverse scaling and squaring algorithms for the matrix logarithm", SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. <a href="https://doi.org/10.1137/110852553" target="_blank">doi:10.1137/110852553</a></p>
</div>
<div class="footnote" id="footnote-AHR13">
<a href="#footnote-AHR13"><strong>[AHR13]</strong></a><p>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, "Computing the Fréchet derivative of the matrix logarithm and estimating the condition number", SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. <a href="https://doi.org/10.1137/120885991" target="_blank">doi:10.1137/120885991</a></p>
</div>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = Matrix(2.7182818*I, 2, 2)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828

julia&gt; log(A)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L587-L617">source</a><h3 id="Base.sqrt-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}">
<code>Base.sqrt</code><span class="docstring-category">Method</span>
</h3>
<pre>sqrt(A::AbstractMatrix)</pre>
<p>If <code>A</code> has no negative real eigenvalues, compute the principal matrix square root of <code>A</code>, that is the unique matrix <span>$X$</span> with eigenvalues having positive real part such that <span>$X^2 = A$</span>. Otherwise, a nonprincipal square root is returned.</p>
<p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the square root. Otherwise, the square root is determined by means of the Björck-Hammarling method <a href="#footnote-BH83">[BH83]</a>, which computes the complex Schur form (<a href="#LinearAlgebra.schur"><code>schur</code></a>) and then the complex square root of the triangular factor.</p>
<div class="footnote" id="footnote-BH83">
<a href="#footnote-BH83"><strong>[BH83]</strong></a><p>Åke Björck and Sven Hammarling, "A Schur method for the square root of a matrix", Linear Algebra and its Applications, 52-53, 1983, 127-140. <a href="https://doi.org/10.1016/0024-3795(83)80010-X" target="_blank">doi:10.1016/0024-3795(83)80010-X</a></p>
</div>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [4 0; 0 4]
2×2 Array{Int64,2}:
 4  0
 0  4

julia&gt; sqrt(A)
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  2.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L646-L676">source</a><h3 id="Base.cos-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}">
<code>Base.cos</code><span class="docstring-category">Method</span>
</h3>
<pre>cos(A::AbstractMatrix)</pre>
<p>Compute the matrix cosine of a square matrix <code>A</code>.</p>
<p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the cosine. Otherwise, the cosine is determined by calling <a href="#"><code>exp</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; cos(fill(1.0, (2,2)))
2×2 Array{Float64,2}:
  0.291927  -0.708073
 -0.708073   0.291927</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L720-L735">source</a><h3 id="Base.sin-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}">
<code>Base.sin</code><span class="docstring-category">Method</span>
</h3>
<pre>sin(A::AbstractMatrix)</pre>
<p>Compute the matrix sine of a square matrix <code>A</code>.</p>
<p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the sine. Otherwise, the sine is determined by calling <a href="#"><code>exp</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; sin(fill(1.0, (2,2)))
2×2 Array{Float64,2}:
 0.454649  0.454649
 0.454649  0.454649</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L753-L768">source</a><h3 id="Base.Math.sincos-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}">
<code>Base.Math.sincos</code><span class="docstring-category">Method</span>
</h3>
<pre>sincos(A::AbstractMatrix)</pre>
<p>Compute the matrix sine and cosine of a square matrix <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; S, C = sincos(fill(1.0, (2,2)));

julia&gt; S
2×2 Array{Float64,2}:
 0.454649  0.454649
 0.454649  0.454649

julia&gt; C
2×2 Array{Float64,2}:
  0.291927  -0.708073
 -0.708073   0.291927</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L790-L809">source</a><h3 id="Base.tan-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}">
<code>Base.tan</code><span class="docstring-category">Method</span>
</h3>
<pre>tan(A::AbstractMatrix)</pre>
<p>Compute the matrix tangent of a square matrix <code>A</code>.</p>
<p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the tangent. Otherwise, the tangent is determined by calling <a href="#"><code>exp</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; tan(fill(1.0, (2,2)))
2×2 Array{Float64,2}:
 -1.09252  -1.09252
 -1.09252  -1.09252</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L839-L854">source</a><h3 id="Base.Math.sec-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.sec</code><span class="docstring-category">Method</span>
</h3>
<pre>sec(A::AbstractMatrix)</pre>
<p>Compute the matrix secant of a square matrix <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1065-L1069">source</a><h3 id="Base.Math.csc-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.csc</code><span class="docstring-category">Method</span>
</h3>
<pre>csc(A::AbstractMatrix)</pre>
<p>Compute the matrix cosecant of a square matrix <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1065-L1069">source</a><h3 id="Base.Math.cot-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.cot</code><span class="docstring-category">Method</span>
</h3>
<pre>cot(A::AbstractMatrix)</pre>
<p>Compute the matrix cotangent of a square matrix <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1065-L1069">source</a><h3 id="Base.cosh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.cosh</code><span class="docstring-category">Method</span>
</h3>
<pre>cosh(A::AbstractMatrix)</pre>
<p>Compute the matrix hyperbolic cosine of a square matrix <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L864-L868">source</a><h3 id="Base.sinh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.sinh</code><span class="docstring-category">Method</span>
</h3>
<pre>sinh(A::AbstractMatrix)</pre>
<p>Compute the matrix hyperbolic sine of a square matrix <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L878-L882">source</a><h3 id="Base.tanh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.tanh</code><span class="docstring-category">Method</span>
</h3>
<pre>tanh(A::AbstractMatrix)</pre>
<p>Compute the matrix hyperbolic tangent of a square matrix <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L892-L896">source</a><h3 id="Base.Math.sech-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.sech</code><span class="docstring-category">Method</span>
</h3>
<pre>sech(A::AbstractMatrix)</pre>
<p>Compute the matrix hyperbolic secant of square matrix <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1070-L1074">source</a><h3 id="Base.Math.csch-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.csch</code><span class="docstring-category">Method</span>
</h3>
<pre>csch(A::AbstractMatrix)</pre>
<p>Compute the matrix hyperbolic cosecant of square matrix <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1070-L1074">source</a><h3 id="Base.Math.coth-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.coth</code><span class="docstring-category">Method</span>
</h3>
<pre>coth(A::AbstractMatrix)</pre>
<p>Compute the matrix hyperbolic cotangent of square matrix <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1070-L1074">source</a><h3 id="Base.acos-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.acos</code><span class="docstring-category">Method</span>
</h3>
<pre>acos(A::AbstractMatrix)</pre>
<p>Compute the inverse matrix cosine of a square matrix <code>A</code>.</p>
<p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using <a href="#"><code>log</code></a> and <a href="#"><code>sqrt</code></a>. For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_1">[AH16_1]</a>.</p>
<div class="footnote" id="footnote-AH16_1">
<a href="#footnote-AH16_1"><strong>[AH16_1]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, "Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms", MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577" target="_blank">https://doi.org/10.1137/16M1057577</a></p>
</div>
<p><strong>Examples</strong></p>
<pre>julia&gt; acos(cos([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5-5.55112e-17im  0.1-2.77556e-17im
 -0.2+2.498e-16im    0.3-3.46945e-16im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L912-L931">source</a><h3 id="Base.asin-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.asin</code><span class="docstring-category">Method</span>
</h3>
<pre>asin(A::AbstractMatrix)</pre>
<p>Compute the inverse matrix sine of a square matrix <code>A</code>.</p>
<p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using <a href="#"><code>log</code></a> and <a href="#"><code>sqrt</code></a>. For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_2">[AH16_2]</a>.</p>
<div class="footnote" id="footnote-AH16_2">
<a href="#footnote-AH16_2"><strong>[AH16_2]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, "Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms", MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577" target="_blank">https://doi.org/10.1137/16M1057577</a></p>
</div>
<p><strong>Examples</strong></p>
<pre>julia&gt; asin(sin([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5-4.16334e-17im  0.1-5.55112e-17im
 -0.2+9.71445e-17im  0.3-1.249e-16im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L943-L962">source</a><h3 id="Base.atan-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.atan</code><span class="docstring-category">Method</span>
</h3>
<pre>atan(A::AbstractMatrix)</pre>
<p>Compute the inverse matrix tangent of a square matrix <code>A</code>.</p>
<p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using <a href="#"><code>log</code></a>. For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_3">[AH16_3]</a>.</p>
<div class="footnote" id="footnote-AH16_3">
<a href="#footnote-AH16_3"><strong>[AH16_3]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, "Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms", MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577" target="_blank">https://doi.org/10.1137/16M1057577</a></p>
</div>
<p><strong>Examples</strong></p>
<pre>julia&gt; atan(tan([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5+1.38778e-17im  0.1-2.77556e-17im
 -0.2+6.93889e-17im  0.3-4.16334e-17im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L974-L993">source</a><h3 id="Base.Math.asec-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.asec</code><span class="docstring-category">Method</span>
</h3>
<pre>asec(A::AbstractMatrix)</pre>
<p>Compute the inverse matrix secant of <code>A</code>. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1084-L1086">source</a><h3 id="Base.Math.acsc-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.acsc</code><span class="docstring-category">Method</span>
</h3>
<pre>acsc(A::AbstractMatrix)</pre>
<p>Compute the inverse matrix cosecant of <code>A</code>. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1084-L1086">source</a><h3 id="Base.Math.acot-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.acot</code><span class="docstring-category">Method</span>
</h3>
<pre>acot(A::AbstractMatrix)</pre>
<p>Compute the inverse matrix cotangent of <code>A</code>. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1084-L1086">source</a><h3 id="Base.acosh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.acosh</code><span class="docstring-category">Method</span>
</h3>
<pre>acosh(A::AbstractMatrix)</pre>
<p>Compute the inverse hyperbolic matrix cosine of a square matrix <code>A</code>. For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_4">[AH16_4]</a>.</p>
<div class="footnote" id="footnote-AH16_4">
<a href="#footnote-AH16_4"><strong>[AH16_4]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, "Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms", MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577" target="_blank">https://doi.org/10.1137/16M1057577</a></p>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1004-L1011">source</a><h3 id="Base.asinh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.asinh</code><span class="docstring-category">Method</span>
</h3>
<pre>asinh(A::AbstractMatrix)</pre>
<p>Compute the inverse hyperbolic matrix sine of a square matrix <code>A</code>. For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_5">[AH16_5]</a>.</p>
<div class="footnote" id="footnote-AH16_5">
<a href="#footnote-AH16_5"><strong>[AH16_5]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, "Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms", MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577" target="_blank">https://doi.org/10.1137/16M1057577</a></p>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1023-L1030">source</a><h3 id="Base.atanh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.atanh</code><span class="docstring-category">Method</span>
</h3>
<pre>atanh(A::AbstractMatrix)</pre>
<p>Compute the inverse hyperbolic matrix tangent of a square matrix <code>A</code>. For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_6">[AH16_6]</a>.</p>
<div class="footnote" id="footnote-AH16_6">
<a href="#footnote-AH16_6"><strong>[AH16_6]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, "Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms", MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577" target="_blank">https://doi.org/10.1137/16M1057577</a></p>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1041-L1048">source</a><h3 id="Base.Math.asech-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.asech</code><span class="docstring-category">Method</span>
</h3>
<pre>asech(A::AbstractMatrix)</pre>
<p>Compute the inverse matrix hyperbolic secant of <code>A</code>. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1087-L1089">source</a><h3 id="Base.Math.acsch-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.acsch</code><span class="docstring-category">Method</span>
</h3>
<pre>acsch(A::AbstractMatrix)</pre>
<p>Compute the inverse matrix hyperbolic cosecant of <code>A</code>. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1087-L1089">source</a><h3 id="Base.Math.acoth-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}">
<code>Base.Math.acoth</code><span class="docstring-category">Method</span>
</h3>
<pre>acoth(A::AbstractMatrix)</pre>
<p>Compute the inverse matrix hyperbolic cotangent of <code>A</code>. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1087-L1089">source</a><h3 id="LinearAlgebra.lyap">
<code>LinearAlgebra.lyap</code><span class="docstring-category">Function</span>
</h3>
<pre>lyap(A, C)</pre>
<p>Computes the solution <code>X</code> to the continuous Lyapunov equation <code>AX + XA' + C = 0</code>, where no eigenvalue of <code>A</code> has a zero real part and no two eigenvalues are negative complex conjugates of each other.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [3. 4.; 5. 6]
2×2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia&gt; B = [1. 1.; 1. 2.]
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia&gt; X = lyap(A, B)
2×2 Array{Float64,2}:
  0.5  -0.5
 -0.5   0.25

julia&gt; A*X + X*A' + B
2×2 Array{Float64,2}:
 0.0          6.66134e-16
 6.66134e-16  8.88178e-16</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1416-L1445">source</a><h3 id="LinearAlgebra.sylvester">
<code>LinearAlgebra.sylvester</code><span class="docstring-category">Function</span>
</h3>
<pre>sylvester(A, B, C)</pre>
<p>Computes the solution <code>X</code> to the Sylvester equation <code>AX + XB + C = 0</code>, where <code>A</code>, <code>B</code> and <code>C</code> have compatible dimensions and <code>A</code> and <code>-B</code> have no eigenvalues with equal real part.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [3. 4.; 5. 6]
2×2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia&gt; B = [1. 1.; 1. 2.]
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia&gt; C = [1. 2.; -2. 1]
2×2 Array{Float64,2}:
  1.0  2.0
 -2.0  1.0

julia&gt; X = sylvester(A, B, C)
2×2 Array{Float64,2}:
 -4.46667   1.93333
  3.73333  -1.8

julia&gt; A*X + X*B + C
2×2 Array{Float64,2}:
  2.66454e-15  1.77636e-15
 -3.77476e-15  4.44089e-16</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L1368-L1401">source</a><h3 id="LinearAlgebra.issuccess">
<code>LinearAlgebra.issuccess</code><span class="docstring-category">Function</span>
</h3>
<pre>issuccess(F::Factorization)</pre>
<p>Test that a factorization of a matrix succeeded.</p>
<pre>julia&gt; F = cholesky([1 0; 0 1]);

julia&gt; LinearAlgebra.issuccess(F)
true

julia&gt; F = lu([1 0; 0 0]; check = false);

julia&gt; LinearAlgebra.issuccess(F)
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/factorization.jl#L14-L30">source</a><h3 id="LinearAlgebra.issymmetric">
<code>LinearAlgebra.issymmetric</code><span class="docstring-category">Function</span>
</h3>
<pre>issymmetric(A) -&gt; Bool</pre>
<p>Test whether a matrix is symmetric.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; issymmetric(a)
true

julia&gt; b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; issymmetric(b)
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L908-L931">source</a><h3 id="LinearAlgebra.isposdef">
<code>LinearAlgebra.isposdef</code><span class="docstring-category">Function</span>
</h3>
<pre>isposdef(A) -&gt; Bool</pre>
<p>Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of <code>A</code>. See also <a href="#LinearAlgebra.isposdef!"><code>isposdef!</code></a></p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia&gt; isposdef(A)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L95-L112">source</a><h3 id="LinearAlgebra.isposdef!">
<code>LinearAlgebra.isposdef!</code><span class="docstring-category">Function</span>
</h3>
<pre>isposdef!(A) -&gt; Bool</pre>
<p>Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of <code>A</code>, overwriting <code>A</code> in the process. See also <a href="#LinearAlgebra.isposdef"><code>isposdef</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1. 2.; 2. 50.];

julia&gt; isposdef!(A)
true

julia&gt; A
2×2 Array{Float64,2}:
 1.0  2.0
 2.0  6.78233</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/dense.jl#L72-L91">source</a><h3 id="LinearAlgebra.istril">
<code>LinearAlgebra.istril</code><span class="docstring-category">Function</span>
</h3>
<pre>istril(A::AbstractMatrix, k::Integer = 0) -&gt; Bool</pre>
<p>Test whether <code>A</code> is lower triangular starting from the <code>k</code>th superdiagonal.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; istril(a)
false

julia&gt; istril(a, 1)
true

julia&gt; b = [1 0; -im -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+0im
 0-1im  -1+0im

julia&gt; istril(b)
true

julia&gt; istril(b, -1)
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L1028-L1057">source</a><h3 id="LinearAlgebra.istriu">
<code>LinearAlgebra.istriu</code><span class="docstring-category">Function</span>
</h3>
<pre>istriu(A::AbstractMatrix, k::Integer = 0) -&gt; Bool</pre>
<p>Test whether <code>A</code> is upper triangular starting from the <code>k</code>th superdiagonal.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; istriu(a)
false

julia&gt; istriu(a, -1)
true

julia&gt; b = [1 im; 0 -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+1im
 0+0im  -1+0im

julia&gt; istriu(b)
true

julia&gt; istriu(b, 1)
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L986-L1015">source</a><h3 id="LinearAlgebra.isdiag">
<code>LinearAlgebra.isdiag</code><span class="docstring-category">Function</span>
</h3>
<pre>isdiag(A) -&gt; Bool</pre>
<p>Test whether a matrix is diagonal.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; isdiag(a)
false

julia&gt; b = [im 0; 0 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  0+0im
 0+0im  0-1im

julia&gt; isdiag(b)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L1103-L1126">source</a><h3 id="LinearAlgebra.ishermitian">
<code>LinearAlgebra.ishermitian</code><span class="docstring-category">Function</span>
</h3>
<pre>ishermitian(A) -&gt; Bool</pre>
<p>Test whether a matrix is Hermitian.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; ishermitian(a)
true

julia&gt; b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; ishermitian(b)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L947-L970">source</a><h3 id="Base.transpose">
<code>Base.transpose</code><span class="docstring-category">Function</span>
</h3>
<pre>transpose(A)</pre>
<p>Lazy transpose. Mutating the returned object should appropriately mutate <code>A</code>. Often, but not always, yields <code>Transpose(A)</code>, where <code>Transpose</code> is a lazy transpose wrapper. Note that this operation is recursive.</p>
<p>This operation is intended for linear algebra usage - for general data manipulation see <a href="https://docs.julialang.org/en/v1.0.1/base/arrays/#Base.permutedims" target="_blank"><code>permutedims</code></a>, which is non-recursive.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; transpose(A)
2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 3+2im  8+7im
 9+2im  4+6im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/adjtrans.jl#L78-L100">source</a><h3 id="LinearAlgebra.transpose!">
<code>LinearAlgebra.transpose!</code><span class="docstring-category">Function</span>
</h3>
<pre>transpose!(dest,src)</pre>
<p>Transpose array <code>src</code> and store the result in the preallocated array <code>dest</code>, which should have a size corresponding to <code>(size(src,2),size(src,1))</code>. No in-place transposition is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; B = zeros(Complex{Int64}, 2, 2)
2×2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia&gt; transpose!(B, A);

julia&gt; B
2×2 Array{Complex{Int64},2}:
 3+2im  8+7im
 9+2im  4+6im

julia&gt; A
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/transpose.jl#L8-L40">source</a><h3 id="Base.adjoint">
<code>Base.adjoint</code><span class="docstring-category">Function</span>
</h3>
<pre>adjoint(A)</pre>
<p>Lazy adjoint (conjugate transposition) (also postfix <code>'</code>). Note that <code>adjoint</code> is applied recursively to elements.</p>
<p>This operation is intended for linear algebra usage - for general data manipulation see <a href="https://docs.julialang.org/en/v1.0.1/base/arrays/#Base.permutedims" target="_blank"><code>permutedims</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; adjoint(A)
2×2 Adjoint{Complex{Int64},Array{Complex{Int64},2}}:
 3-2im  8-7im
 9-2im  4-6im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/adjtrans.jl#L54-L75">source</a><h3 id="LinearAlgebra.adjoint!">
<code>LinearAlgebra.adjoint!</code><span class="docstring-category">Function</span>
</h3>
<pre>adjoint!(dest,src)</pre>
<p>Conjugate transpose array <code>src</code> and store the result in the preallocated array <code>dest</code>, which should have a size corresponding to <code>(size(src,2),size(src,1))</code>. No in-place transposition is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; B = zeros(Complex{Int64}, 2, 2)
2×2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia&gt; adjoint!(B, A);

julia&gt; B
2×2 Array{Complex{Int64},2}:
 3-2im  8-7im
 9-2im  4-6im

julia&gt; A
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/transpose.jl#L43-L75">source</a><h3 id="Base.copy-Tuple{Union{Adjoint, Transpose}}">
<code>Base.copy</code><span class="docstring-category">Method</span>
</h3>
<pre>copy(A::Transpose)
copy(A::Adjoint)</pre>
<p>Eagerly evaluate the lazy matrix transpose/adjoint. Note that the transposition is applied recursively to elements.</p>
<p>This operation is intended for linear algebra usage - for general data manipulation see <a href="https://docs.julialang.org/en/v1.0.1/base/arrays/#Base.permutedims" target="_blank"><code>permutedims</code></a>, which is non-recursive.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2im; -3im 4]
2×2 Array{Complex{Int64},2}:
 1+0im  0+2im
 0-3im  4+0im

julia&gt; T = transpose(A)
2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0-3im
 0+2im  4+0im

julia&gt; copy(T)
2×2 Array{Complex{Int64},2}:
 1+0im  0-3im
 0+2im  4+0im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/transpose.jl#L148-L175">source</a><h3 id="LinearAlgebra.stride1">
<code>LinearAlgebra.stride1</code><span class="docstring-category">Function</span>
</h3>
<pre>stride1(A) -&gt; Int</pre>
<p>Return the distance between successive array elements in dimension 1 in units of element size.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; LinearAlgebra.stride1(A)
1

julia&gt; B = view(A, 2:2:4)
2-element view(::Array{Int64,1}, 2:2:4) with eltype Int64:
 2
 4

julia&gt; LinearAlgebra.stride1(B)
2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L161-L187">source</a><h3 id="LinearAlgebra.checksquare">
<code>LinearAlgebra.checksquare</code><span class="docstring-category">Function</span>
</h3>
<pre>LinearAlgebra.checksquare(A)</pre>
<p>Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = fill(1, (4,4)); B = fill(1, (5,5));

julia&gt; LinearAlgebra.checksquare(A, B)
2-element Array{Int64,1}:
 4
 5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L196-L211">source</a><h2 id="Low-level-matrix-operations-1">Low-level matrix operations</h2>
<p>In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix. This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with <code>!</code> below (e.g. <code>mul!</code>) according to the usual Julia convention.</p>
<h3 id="LinearAlgebra.mul!">
<code>LinearAlgebra.mul!</code><span class="docstring-category">Function</span>
</h3>
<pre>mul!(Y, A, B) -&gt; Y</pre>
<p>Calculates the matrix-matrix or matrix-vector product <span>$AB$</span> and stores the result in <code>Y</code>, overwriting the existing value of <code>Y</code>. Note that <code>Y</code> must not be aliased with either <code>A</code> or <code>B</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); mul!(Y, A, B);

julia&gt; Y
2×2 Array{Float64,2}:
 3.0  3.0
 7.0  7.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/matmul.jl#L155-L171">source</a><h3 id="LinearAlgebra.lmul!">
<code>LinearAlgebra.lmul!</code><span class="docstring-category">Function</span>
</h3>
<pre>lmul!(a::Number, B::AbstractArray)</pre>
<p>Scale an array <code>B</code> by a scalar <code>a</code> overwriting <code>B</code> in-place.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; B = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; lmul!(2, B)
2×2 Array{Int64,2}:
 2  4
 6  8</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L65-L82">source</a><pre>lmul!(A, B)</pre>
<p>Calculate the matrix-matrix product <span>$AB$</span>, overwriting <code>B</code>, and return the result.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; B = [0 1; 1 0];

julia&gt; A = LinearAlgebra.UpperTriangular([1 2; 0 3]);

julia&gt; LinearAlgebra.lmul!(A, B);

julia&gt; B
2×2 Array{Int64,2}:
 2  1
 3  0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/matmul.jl#L195-L213">source</a><h3 id="LinearAlgebra.rmul!">
<code>LinearAlgebra.rmul!</code><span class="docstring-category">Function</span>
</h3>
<pre>rmul!(A::AbstractArray, b::Number)</pre>
<p>Scale an array <code>A</code> by a scalar <code>b</code> overwriting <code>A</code> in-place.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rmul!(A, 2)
2×2 Array{Int64,2}:
 2  4
 6  8</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/generic.jl#L45-L62">source</a><pre>rmul!(A, B)</pre>
<p>Calculate the matrix-matrix product <span>$AB$</span>, overwriting <code>A</code>, and return the result.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [0 1; 1 0];

julia&gt; B = LinearAlgebra.UpperTriangular([1 2; 0 3]);

julia&gt; LinearAlgebra.rmul!(A, B);

julia&gt; A
2×2 Array{Int64,2}:
 0  3
 1  2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/matmul.jl#L174-L192">source</a><h3 id="LinearAlgebra.ldiv!">
<code>LinearAlgebra.ldiv!</code><span class="docstring-category">Function</span>
</h3>
<pre>ldiv!(Y, A, B) -&gt; Y</pre>
<p>Compute <code>A \ B</code> in-place and store the result in <code>Y</code>, returning the result.</p>
<p>The argument <code>A</code> should <em>not</em> be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by <a href="#LinearAlgebra.factorize"><code>factorize</code></a> or <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a href="#LinearAlgebra.lu!"><code>lu!</code></a>), and performance-critical situations requiring <code>ldiv!</code> usually also require fine-grained control over the factorization of <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia&gt; X = [1; 2.5; 3];

julia&gt; Y = zero(X);

julia&gt; ldiv!(Y, qr(A), X);

julia&gt; Y
3-element Array{Float64,1}:
  0.7128099173553719
 -0.051652892561983674
  0.10020661157024757

julia&gt; A\X
3-element Array{Float64,1}:
  0.7128099173553719
 -0.05165289256198333
  0.10020661157024785</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L237-L271">source</a><pre>ldiv!(A, B)</pre>
<p>Compute <code>A \ B</code> in-place and overwriting <code>B</code> to store the result.</p>
<p>The argument <code>A</code> should <em>not</em> be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by <a href="#LinearAlgebra.factorize"><code>factorize</code></a> or <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a href="#LinearAlgebra.lu!"><code>lu!</code></a>), and performance-critical situations requiring <code>ldiv!</code> usually also require fine-grained control over the factorization of <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia&gt; X = [1; 2.5; 3];

julia&gt; Y = copy(X);

julia&gt; ldiv!(qr(A), X);

julia&gt; X
3-element Array{Float64,1}:
  0.7128099173553719
 -0.051652892561983674
  0.10020661157024757

julia&gt; A\Y
3-element Array{Float64,1}:
  0.7128099173553719
 -0.05165289256198333
  0.10020661157024785</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L274-L308">source</a><h3 id="LinearAlgebra.rdiv!">
<code>LinearAlgebra.rdiv!</code><span class="docstring-category">Function</span>
</h3>
<pre>rdiv!(A, B)</pre>
<p>Compute <code>A / B</code> in-place and overwriting <code>A</code> to store the result.</p>
<p>The argument <code>B</code> should <em>not</em> be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by <a href="#LinearAlgebra.factorize"><code>factorize</code></a> or <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a href="#LinearAlgebra.lu!"><code>lu!</code></a>), and performance-critical situations requiring <code>rdiv!</code> usually also require fine-grained control over the factorization of <code>B</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L312-L323">source</a><h2 id="BLAS-Functions-1">BLAS Functions</h2>
<p>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the <a href="http://www.netlib.org/lapack/" target="_blank">LAPACK library</a>, which in turn is built on top of basic linear-algebra building-blocks known as the <a href="http://www.netlib.org/blas/" target="_blank">BLAS</a>. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</p>
<p><code>LinearAlgebra.BLAS</code> provides wrappers for some of the BLAS functions. Those BLAS functions that overwrite one of the input arrays have names ending in <code>'!'</code>. Usually, a BLAS function has four methods defined, for <a href="https://docs.julialang.org/en/v1.0.1/base/numbers/#Core.Float64" target="_blank"><code>Float64</code></a>, <a href="https://docs.julialang.org/en/v1.0.1/base/numbers/#Core.Float32" target="_blank"><code>Float32</code></a>, <code>ComplexF64</code>, and <code>ComplexF32</code> arrays.</p>
<h3 id="stdlib-blas-chars-1">BLAS Character Arguments</h3>
<p>Many BLAS functions accept arguments that determine whether to transpose an argument (<code>trans</code>), which triangle of a matrix to reference (<code>uplo</code> or <code>ul</code>), whether the diagonal of a triangular matrix can be assumed to be all ones (<code>dA</code>) or which side of a matrix multiplication the input argument belongs on (<code>side</code>). The possibilities are:</p>
<h4 id="stdlib-blas-side-1">Multplication Order</h4>
<table>
<tr>
<th><code>side</code></th>
<th>Meaning</th>
</tr>
<tr>
<td><code>'L'</code></td>
<td>The argument goes on the <em>left</em> side of a matrix-matrix operation.</td>
</tr>
<tr>
<td><code>'R'</code></td>
<td>The argument goes on the <em>right</em> side of a matrix-matrix operation.</td>
</tr>
</table>
<h4 id="stdlib-blas-uplo-1">Triangle Referencing</h4>
<table>
<tr>
<th>
<code>uplo</code>/<code>ul</code>
</th>
<th>Meaning</th>
</tr>
<tr>
<td><code>'U'</code></td>
<td>Only the <em>upper</em> triangle of the matrix will be used.</td>
</tr>
<tr>
<td><code>'L'</code></td>
<td>Only the <em>lower</em> triangle of the matrix will be used.</td>
</tr>
</table>
<h4 id="stdlib-blas-trans-1">Transposition Operation</h4>
<table>
<tr>
<th>
<code>trans</code>/<code>tX</code>
</th>
<th>Meaning</th>
</tr>
<tr>
<td><code>'N'</code></td>
<td>The input matrix <code>X</code> is not transposed or conjugated.</td>
</tr>
<tr>
<td><code>'T'</code></td>
<td>The input matrix <code>X</code> will be transposed.</td>
</tr>
<tr>
<td><code>'C'</code></td>
<td>The input matrix <code>X</code> will be conjugated and transposed.</td>
</tr>
</table>
<h4 id="stdlib-blas-diag-1">Unit Diagonal</h4>
<table>
<tr>
<th>
<code>diag</code>/<code>dX</code>
</th>
<th>Meaning</th>
</tr>
<tr>
<td><code>'N'</code></td>
<td>The diagonal values of the matrix <code>X</code> will be read.</td>
</tr>
<tr>
<td><code>'U'</code></td>
<td>The diagonal of the matrix <code>X</code> is assumed to be all ones.</td>
</tr>
</table>
<h3 id="LinearAlgebra.BLAS">
<code>LinearAlgebra.BLAS</code><span class="docstring-category">Module</span>
</h3>
<p>Interface to BLAS subroutines.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L4-L6">source</a><h3 id="LinearAlgebra.BLAS.dotu">
<code>LinearAlgebra.BLAS.dotu</code><span class="docstring-category">Function</span>
</h3>
<pre>dotu(n, X, incx, Y, incy)</pre>
<p>Dot function for two complex vectors consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code> and <code>n</code> elements of array <code>Y</code> with stride <code>incy</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)
-10.0 + 10.0im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L261-L272">source</a><h3 id="LinearAlgebra.BLAS.dotc">
<code>LinearAlgebra.BLAS.dotc</code><span class="docstring-category">Function</span>
</h3>
<pre>dotc(n, X, incx, U, incy)</pre>
<p>Dot function for two complex vectors, consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code> and <code>n</code> elements of array <code>U</code> with stride <code>incy</code>, conjugating the first vector.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)
10.0 - 10.0im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L246-L258">source</a><h3 id="LinearAlgebra.BLAS.blascopy!">
<code>LinearAlgebra.BLAS.blascopy!</code><span class="docstring-category">Function</span>
</h3>
<pre>blascopy!(n, X, incx, Y, incy)</pre>
<p>Copy <code>n</code> elements of array <code>X</code> with stride <code>incx</code> to array <code>Y</code> with stride <code>incy</code>. Returns <code>Y</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L176-L180">source</a><h3 id="LinearAlgebra.BLAS.nrm2">
<code>LinearAlgebra.BLAS.nrm2</code><span class="docstring-category">Function</span>
</h3>
<pre>nrm2(n, X, incx)</pre>
<p>2-norm of a vector consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; BLAS.nrm2(4, fill(1.0, 8), 2)
2.0

julia&gt; BLAS.nrm2(1, fill(1.0, 8), 2)
1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L355-L368">source</a><h3 id="LinearAlgebra.BLAS.asum">
<code>LinearAlgebra.BLAS.asum</code><span class="docstring-category">Function</span>
</h3>
<pre>asum(n, X, incx)</pre>
<p>Sum of the absolute values of the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; BLAS.asum(5, fill(1.0im, 10), 2)
5.0

julia&gt; BLAS.asum(2, fill(1.0im, 10), 5)
2.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L388-L401">source</a><h3 id="LinearAlgebra.axpy!">
<code>LinearAlgebra.axpy!</code><span class="docstring-category">Function</span>
</h3>
<pre>axpy!(a, X, Y)</pre>
<p>Overwrite <code>Y</code> with <code>a*X + Y</code>, where <code>a</code> is a scalar. Return <code>Y</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; x = [1; 2; 3];

julia&gt; y = [4; 5; 6];

julia&gt; BLAS.axpy!(2, x, y)
3-element Array{Int64,1}:
  6
  9
 12</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L421-L438">source</a><h3 id="LinearAlgebra.BLAS.scal!">
<code>LinearAlgebra.BLAS.scal!</code><span class="docstring-category">Function</span>
</h3>
<pre>scal!(n, a, X, incx)</pre>
<p>Overwrite <code>X</code> with <code>a*X</code> for the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>. Returns <code>X</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L200-L204">source</a><h3 id="LinearAlgebra.BLAS.scal">
<code>LinearAlgebra.BLAS.scal</code><span class="docstring-category">Function</span>
</h3>
<pre>scal(n, a, X, incx)</pre>
<p>Return <code>X</code> scaled by <code>a</code> for the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L207-L211">source</a><h3 id="LinearAlgebra.BLAS.ger!">
<code>LinearAlgebra.BLAS.ger!</code><span class="docstring-category">Function</span>
</h3>
<pre>ger!(alpha, x, y, A)</pre>
<p>Rank-1 update of the matrix <code>A</code> with vectors <code>x</code> and <code>y</code> as <code>alpha*x*y' + A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L990-L994">source</a><h3 id="LinearAlgebra.BLAS.syr!">
<code>LinearAlgebra.BLAS.syr!</code><span class="docstring-category">Function</span>
</h3>
<pre>syr!(uplo, alpha, x, A)</pre>
<p>Rank-1 update of the symmetric matrix <code>A</code> with vector <code>x</code> as <code>alpha*x*transpose(x) + A</code>. <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> controls which triangle of <code>A</code> is updated. Returns <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1022-L1027">source</a><h3 id="LinearAlgebra.BLAS.syrk!">
<code>LinearAlgebra.BLAS.syrk!</code><span class="docstring-category">Function</span>
</h3>
<pre>syrk!(uplo, trans, alpha, A, beta, C)</pre>
<p>Rank-k update of the symmetric matrix <code>C</code> as <code>alpha*A*transpose(A) + beta*C</code> or <code>alpha*transpose(A)*A + beta*C</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>C</code> is used. Returns <code>C</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1270-L1276">source</a><h3 id="LinearAlgebra.BLAS.syrk">
<code>LinearAlgebra.BLAS.syrk</code><span class="docstring-category">Function</span>
</h3>
<pre>syrk(uplo, trans, alpha, A)</pre>
<p>Returns either the upper triangle or the lower triangle of <code>A</code>, according to <a href="#stdlib-blas-uplo-1"><code>uplo</code></a>, of <code>alpha*A*transpose(A)</code> or <code>alpha*transpose(A)*A</code>, according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1279-L1286">source</a><h3 id="LinearAlgebra.BLAS.her!">
<code>LinearAlgebra.BLAS.her!</code><span class="docstring-category">Function</span>
</h3>
<pre>her!(uplo, alpha, x, A)</pre>
<p>Methods for complex arrays only. Rank-1 update of the Hermitian matrix <code>A</code> with vector <code>x</code> as <code>alpha*x*x' + A</code>. <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> controls which triangle of <code>A</code> is updated. Returns <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1053-L1059">source</a><h3 id="LinearAlgebra.BLAS.herk!">
<code>LinearAlgebra.BLAS.herk!</code><span class="docstring-category">Function</span>
</h3>
<pre>herk!(uplo, trans, alpha, A, beta, C)</pre>
<p>Methods for complex arrays only. Rank-k update of the Hermitian matrix <code>C</code> as <code>alpha*A*A' + beta*C</code> or <code>alpha*A'*A + beta*C</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>C</code> is updated. Returns <code>C</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1329-L1336">source</a><h3 id="LinearAlgebra.BLAS.herk">
<code>LinearAlgebra.BLAS.herk</code><span class="docstring-category">Function</span>
</h3>
<pre>herk(uplo, trans, alpha, A)</pre>
<p>Methods for complex arrays only. Returns the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>alpha*A*A'</code> or <code>alpha*A'*A</code>, according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1339-L1345">source</a><h3 id="LinearAlgebra.BLAS.gbmv!">
<code>LinearAlgebra.BLAS.gbmv!</code><span class="docstring-category">Function</span>
</h3>
<pre>gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)</pre>
<p>Update vector <code>y</code> as <code>alpha*A*x + beta*y</code> or <code>alpha*A'*x + beta*y</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. The matrix <code>A</code> is a general band matrix of dimension <code>m</code> by <code>size(A,2)</code> with <code>kl</code> sub-diagonals and <code>ku</code> super-diagonals. <code>alpha</code> and <code>beta</code> are scalars. Return the updated <code>y</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L619-L625">source</a><h3 id="LinearAlgebra.BLAS.gbmv">
<code>LinearAlgebra.BLAS.gbmv</code><span class="docstring-category">Function</span>
</h3>
<pre>gbmv(trans, m, kl, ku, alpha, A, x)</pre>
<p>Return <code>alpha*A*x</code> or <code>alpha*A'*x</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. The matrix <code>A</code> is a general band matrix of dimension <code>m</code> by <code>size(A,2)</code> with <code>kl</code> sub-diagonals and <code>ku</code> super-diagonals, and <code>alpha</code> is a scalar.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L628-L634">source</a><h3 id="LinearAlgebra.BLAS.sbmv!">
<code>LinearAlgebra.BLAS.sbmv!</code><span class="docstring-category">Function</span>
</h3>
<pre>sbmv!(uplo, k, alpha, A, x, beta, y)</pre>
<p>Update vector <code>y</code> as <code>alpha*A*x + beta*y</code> where <code>A</code> is a a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. The storage layout for <code>A</code> is described the reference BLAS module, level-2 BLAS at <a href="http://www.netlib.org/lapack/explore-html/" target="_blank">http://www.netlib.org/lapack/explore-html/</a>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p>
<p>Return the updated <code>y</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L834-L844">source</a><h3 id="LinearAlgebra.BLAS.sbmv-NTuple{5,Any}">
<code>LinearAlgebra.BLAS.sbmv</code><span class="docstring-category">Method</span>
</h3>
<pre>sbmv(uplo, k, alpha, A, x)</pre>
<p>Return <code>alpha*A*x</code> where <code>A</code> is a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L816-L822">source</a><h3 id="LinearAlgebra.BLAS.sbmv-NTuple{4,Any}">
<code>LinearAlgebra.BLAS.sbmv</code><span class="docstring-category">Method</span>
</h3>
<pre>sbmv(uplo, k, A, x)</pre>
<p>Return <code>A*x</code> where <code>A</code> is a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L825-L831">source</a><h3 id="LinearAlgebra.BLAS.gemm!">
<code>LinearAlgebra.BLAS.gemm!</code><span class="docstring-category">Function</span>
</h3>
<pre>gemm!(tA, tB, alpha, A, B, beta, C)</pre>
<p>Update <code>C</code> as <code>alpha*A*B + beta*C</code> or the other three variants according to <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>. Return the updated <code>C</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1084-L1089">source</a><h3 id="LinearAlgebra.BLAS.gemm-NTuple{5,Any}">
<code>LinearAlgebra.BLAS.gemm</code><span class="docstring-category">Method</span>
</h3>
<pre>gemm(tA, tB, alpha, A, B)</pre>
<p>Return <code>alpha*A*B</code> or the other three variants according to <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1140-L1144">source</a><h3 id="LinearAlgebra.BLAS.gemm-NTuple{4,Any}">
<code>LinearAlgebra.BLAS.gemm</code><span class="docstring-category">Method</span>
</h3>
<pre>gemm(tA, tB, A, B)</pre>
<p>Return <code>A*B</code> or the other three variants according to <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1147-L1151">source</a><h3 id="LinearAlgebra.BLAS.gemv!">
<code>LinearAlgebra.BLAS.gemv!</code><span class="docstring-category">Function</span>
</h3>
<pre>gemv!(tA, alpha, A, x, beta, y)</pre>
<p>Update the vector <code>y</code> as <code>alpha*A*x + beta*y</code> or <code>alpha*A'x + beta*y</code> according to <a href="#stdlib-blas-trans-1"><code>tA</code></a>. <code>alpha</code> and <code>beta</code> are scalars. Return the updated <code>y</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L593-L599">source</a><h3 id="LinearAlgebra.BLAS.gemv-NTuple{4,Any}">
<code>LinearAlgebra.BLAS.gemv</code><span class="docstring-category">Method</span>
</h3>
<pre>gemv(tA, alpha, A, x)</pre>
<p>Return <code>alpha*A*x</code> or <code>alpha*A'x</code> according to <a href="#stdlib-blas-trans-1"><code>tA</code></a>. <code>alpha</code> is a scalar.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L602-L607">source</a><h3 id="LinearAlgebra.BLAS.gemv-Tuple{Any,Any,Any}">
<code>LinearAlgebra.BLAS.gemv</code><span class="docstring-category">Method</span>
</h3>
<pre>gemv(tA, A, x)</pre>
<p>Return <code>A*x</code> or <code>A'x</code> according to <a href="#stdlib-blas-trans-1"><code>tA</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L610-L614">source</a><h3 id="LinearAlgebra.BLAS.symm!">
<code>LinearAlgebra.BLAS.symm!</code><span class="docstring-category">Function</span>
</h3>
<pre>symm!(side, ul, alpha, A, B, beta, C)</pre>
<p>Update <code>C</code> as <code>alpha*A*B + beta*C</code> or <code>alpha*B*A + beta*C</code> according to <a href="#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. Return the updated <code>C</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1217-L1223">source</a><h3 id="LinearAlgebra.BLAS.symm-NTuple{5,Any}">
<code>LinearAlgebra.BLAS.symm</code><span class="docstring-category">Method</span>
</h3>
<pre>symm(side, ul, alpha, A, B)</pre>
<p>Return <code>alpha*A*B</code> or <code>alpha*B*A</code> according to <a href="#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1199-L1205">source</a><h3 id="LinearAlgebra.BLAS.symm-NTuple{4,Any}">
<code>LinearAlgebra.BLAS.symm</code><span class="docstring-category">Method</span>
</h3>
<pre>symm(side, ul, A, B)</pre>
<p>Return <code>A*B</code> or <code>B*A</code> according to <a href="#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1208-L1214">source</a><h3 id="LinearAlgebra.BLAS.symv!">
<code>LinearAlgebra.BLAS.symv!</code><span class="docstring-category">Function</span>
</h3>
<pre>symv!(ul, alpha, A, x, beta, y)</pre>
<p>Update the vector <code>y</code> as <code>alpha*A*x + beta*y</code>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <code>alpha</code> and <code>beta</code> are scalars. Return the updated <code>y</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L675-L681">source</a><h3 id="LinearAlgebra.BLAS.symv-NTuple{4,Any}">
<code>LinearAlgebra.BLAS.symv</code><span class="docstring-category">Method</span>
</h3>
<pre>symv(ul, alpha, A, x)</pre>
<p>Return <code>alpha*A*x</code>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <code>alpha</code> is a scalar.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L728-L734">source</a><h3 id="LinearAlgebra.BLAS.symv-Tuple{Any,Any,Any}">
<code>LinearAlgebra.BLAS.symv</code><span class="docstring-category">Method</span>
</h3>
<pre>symv(ul, A, x)</pre>
<p>Return <code>A*x</code>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L737-L742">source</a><h3 id="LinearAlgebra.BLAS.trmm!">
<code>LinearAlgebra.BLAS.trmm!</code><span class="docstring-category">Function</span>
</h3>
<pre>trmm!(side, ul, tA, dA, alpha, A, B)</pre>
<p>Update <code>B</code> as <code>alpha*A*B</code> or one of the other three variants determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Returns the updated <code>B</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1473-L1482">source</a><h3 id="LinearAlgebra.BLAS.trmm">
<code>LinearAlgebra.BLAS.trmm</code><span class="docstring-category">Function</span>
</h3>
<pre>trmm(side, ul, tA, dA, alpha, A, B)</pre>
<p>Returns <code>alpha*A*B</code> or one of the other three variants determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1485-L1493">source</a><h3 id="LinearAlgebra.BLAS.trsm!">
<code>LinearAlgebra.BLAS.trsm!</code><span class="docstring-category">Function</span>
</h3>
<pre>trsm!(side, ul, tA, dA, alpha, A, B)</pre>
<p>Overwrite <code>B</code> with the solution to <code>A*X = alpha*B</code> or one of the other three variants determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Returns the updated <code>B</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1496-L1505">source</a><h3 id="LinearAlgebra.BLAS.trsm">
<code>LinearAlgebra.BLAS.trsm</code><span class="docstring-category">Function</span>
</h3>
<pre>trsm(side, ul, tA, dA, alpha, A, B)</pre>
<p>Return the solution to <code>A*X = alpha*B</code> or one of the other three variants determined by determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L1508-L1516">source</a><h3 id="LinearAlgebra.BLAS.trmv!">
<code>LinearAlgebra.BLAS.trmv!</code><span class="docstring-category">Function</span>
</h3>
<pre>trmv!(ul, tA, dA, A, b)</pre>
<p>Return <code>op(A)*b</code>, where <code>op</code> is determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. The multiplication occurs in-place on <code>b</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L892-L900">source</a><h3 id="LinearAlgebra.BLAS.trmv">
<code>LinearAlgebra.BLAS.trmv</code><span class="docstring-category">Function</span>
</h3>
<pre>trmv(ul, tA, dA, A, b)</pre>
<p>Return <code>op(A)*b</code>, where <code>op</code> is determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L882-L889">source</a><h3 id="LinearAlgebra.BLAS.trsv!">
<code>LinearAlgebra.BLAS.trsv!</code><span class="docstring-category">Function</span>
</h3>
<pre>trsv!(ul, tA, dA, A, b)</pre>
<p>Overwrite <code>b</code> with the solution to <code>A*x = b</code> or one of the other two variants determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <a href="#stdlib-blas-uplo-1"><code>ul</code></a>. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Return the updated <code>b</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L936-L944">source</a><h3 id="LinearAlgebra.BLAS.trsv">
<code>LinearAlgebra.BLAS.trsv</code><span class="docstring-category">Function</span>
</h3>
<pre>trsv(ul, tA, dA, A, b)</pre>
<p>Return the solution to <code>A*x = b</code> or one of the other two variants determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <a href="#stdlib-blas-uplo-1"><code>ul</code></a>. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L947-L954">source</a><h3 id="LinearAlgebra.BLAS.set_num_threads">
<code>LinearAlgebra.BLAS.set_num_threads</code><span class="docstring-category">Function</span>
</h3>
<pre>set_num_threads(n)</pre>
<p>Set the number of threads the BLAS library should use.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/blas.jl#L105-L109">source</a><h3 id="LinearAlgebra.I">
<code>LinearAlgebra.I</code><span class="docstring-category">Constant</span>
</h3>
<pre>I</pre>
<p>An object of type <a href="#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a>, representing an identity matrix of any size.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; fill(1, (5,6)) * I == fill(1, (5,6))
true

julia&gt; [1 2im 3; 1im 2 3] * I
2×3 Array{Complex{Int64},2}:
 1+0im  0+2im  3+0im
 0+1im  2+0im  3+0im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/uniformscaling.jl#L33-L48">source</a><h2 id="LAPACK-Functions-1">LAPACK Functions</h2>
<p><code>LinearAlgebra.LAPACK</code> provides wrappers for some of the LAPACK functions for linear algebra. Those functions that overwrite one of the input arrays have names ending in <code>'!'</code>.</p>
<p>Usually a function has 4 methods defined, one each for <a href="https://docs.julialang.org/en/v1.0.1/base/numbers/#Core.Float64" target="_blank"><code>Float64</code></a>, <a href="https://docs.julialang.org/en/v1.0.1/base/numbers/#Core.Float32" target="_blank"><code>Float32</code></a>, <code>ComplexF64</code> and <code>ComplexF32</code> arrays.</p>
<p>Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing, there is no commitment to support/deprecate this specific set of functions in future releases.</p>
<h3 id="LinearAlgebra.LAPACK">
<code>LinearAlgebra.LAPACK</code><span class="docstring-category">Module</span>
</h3>
<p>Interfaces to LAPACK subroutines.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L4-L6">source</a><h3 id="LinearAlgebra.LAPACK.gbtrf!">
<code>LinearAlgebra.LAPACK.gbtrf!</code><span class="docstring-category">Function</span>
</h3>
<pre>gbtrf!(kl, ku, m, AB) -&gt; (AB, ipiv)</pre>
<p>Compute the LU factorization of a banded matrix <code>AB</code>. <code>kl</code> is the first subdiagonal containing a nonzero band, <code>ku</code> is the last superdiagonal containing one, and <code>m</code> is the first dimension of the matrix <code>AB</code>. Returns the LU factorization in-place and <code>ipiv</code>, the vector of pivots used.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L167-L174">source</a><h3 id="LinearAlgebra.LAPACK.gbtrs!">
<code>LinearAlgebra.LAPACK.gbtrs!</code><span class="docstring-category">Function</span>
</h3>
<pre>gbtrs!(trans, kl, ku, m, AB, ipiv, B)</pre>
<p>Solve the equation <code>AB * X = B</code>. <code>trans</code> determines the orientation of <code>AB</code>. It may be <code>N</code> (no transpose), <code>T</code> (transpose), or <code>C</code> (conjugate transpose). <code>kl</code> is the first subdiagonal containing a nonzero band, <code>ku</code> is the last superdiagonal containing one, and <code>m</code> is the first dimension of the matrix <code>AB</code>. <code>ipiv</code> is the vector of pivots returned from <code>gbtrf!</code>. Returns the vector or matrix <code>X</code>, overwriting <code>B</code> in-place.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L177-L185">source</a><h3 id="LinearAlgebra.LAPACK.gebal!">
<code>LinearAlgebra.LAPACK.gebal!</code><span class="docstring-category">Function</span>
</h3>
<pre>gebal!(job, A) -&gt; (ilo, ihi, scale)</pre>
<p>Balance the matrix <code>A</code> before computing its eigensystem or Schur factorization. <code>job</code> can be one of <code>N</code> (<code>A</code> will not be permuted or scaled), <code>P</code> (<code>A</code> will only be permuted), <code>S</code> (<code>A</code> will only be scaled), or <code>B</code> (<code>A</code> will be both permuted and scaled). Modifies <code>A</code> in-place and returns <code>ilo</code>, <code>ihi</code>, and <code>scale</code>. If permuting was turned on, <code>A[i,j] = 0</code> if <code>j &gt; i</code> and <code>1 &lt; j &lt; ilo</code> or <code>j &gt; ihi</code>. <code>scale</code> contains information about the scaling/permutations performed.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L242-L251">source</a><h3 id="LinearAlgebra.LAPACK.gebak!">
<code>LinearAlgebra.LAPACK.gebak!</code><span class="docstring-category">Function</span>
</h3>
<pre>gebak!(job, side, ilo, ihi, scale, V)</pre>
<p>Transform the eigenvectors <code>V</code> of a matrix balanced using <code>gebal!</code> to the unscaled/unpermuted eigenvectors of the original matrix. Modifies <code>V</code> in-place. <code>side</code> can be <code>L</code> (left eigenvectors are transformed) or <code>R</code> (right eigenvectors are transformed).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L254-L261">source</a><h3 id="LinearAlgebra.LAPACK.gebrd!">
<code>LinearAlgebra.LAPACK.gebrd!</code><span class="docstring-category">Function</span>
</h3>
<pre>gebrd!(A) -&gt; (A, d, e, tauq, taup)</pre>
<p>Reduce <code>A</code> in-place to bidiagonal form <code>A = QBP'</code>. Returns <code>A</code>, containing the bidiagonal matrix <code>B</code>; <code>d</code>, containing the diagonal elements of <code>B</code>; <code>e</code>, containing the off-diagonal elements of <code>B</code>; <code>tauq</code>, containing the elementary reflectors representing <code>Q</code>; and <code>taup</code>, containing the elementary reflectors representing <code>P</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L560-L568">source</a><h3 id="LinearAlgebra.LAPACK.gelqf!">
<code>LinearAlgebra.LAPACK.gelqf!</code><span class="docstring-category">Function</span>
</h3>
<pre>gelqf!(A, tau)</pre>
<p>Compute the <code>LQ</code> factorization of <code>A</code>, <code>A = LQ</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p>
<p>Returns <code>A</code> and <code>tau</code> modified in-place.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L571-L580">source</a><pre>gelqf!(A) -&gt; (A, tau)</pre>
<p>Compute the <code>LQ</code> factorization of <code>A</code>, <code>A = LQ</code>.</p>
<p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L666-L673">source</a><h3 id="LinearAlgebra.LAPACK.geqlf!">
<code>LinearAlgebra.LAPACK.geqlf!</code><span class="docstring-category">Function</span>
</h3>
<pre>geqlf!(A, tau)</pre>
<p>Compute the <code>QL</code> factorization of <code>A</code>, <code>A = QL</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p>
<p>Returns <code>A</code> and <code>tau</code> modified in-place.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L583-L591">source</a><pre>geqlf!(A) -&gt; (A, tau)</pre>
<p>Compute the <code>QL</code> factorization of <code>A</code>, <code>A = QL</code>.</p>
<p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L676-L683">source</a><h3 id="LinearAlgebra.LAPACK.geqrf!">
<code>LinearAlgebra.LAPACK.geqrf!</code><span class="docstring-category">Function</span>
</h3>
<pre>geqrf!(A, tau)</pre>
<p>Compute the <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p>
<p>Returns <code>A</code> and <code>tau</code> modified in-place.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L633-L641">source</a><pre>geqrf!(A) -&gt; (A, tau)</pre>
<p>Compute the <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>.</p>
<p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L708-L715">source</a><h3 id="LinearAlgebra.LAPACK.geqp3!">
<code>LinearAlgebra.LAPACK.geqp3!</code><span class="docstring-category">Function</span>
</h3>
<pre>geqp3!(A, jpvt, tau)</pre>
<p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3. <code>P</code> is a pivoting matrix, represented by <code>jpvt</code>. <code>tau</code> stores the elementary reflectors. <code>jpvt</code> must have length length greater than or equal to <code>n</code> if <code>A</code> is an <code>(m x n)</code> matrix. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p>
<p><code>A</code>, <code>jpvt</code>, and <code>tau</code> are modified in-place.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L594-L604">source</a><pre>geqp3!(A, jpvt) -&gt; (A, jpvt, tau)</pre>
<p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3. <code>P</code> is a pivoting matrix, represented by <code>jpvt</code>. <code>jpvt</code> must have length greater than or equal to <code>n</code> if <code>A</code> is an <code>(m x n)</code> matrix.</p>
<p>Returns <code>A</code> and <code>jpvt</code>, modified in-place, and <code>tau</code>, which stores the elementary reflectors.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L728-L737">source</a><pre>geqp3!(A) -&gt; (A, jpvt, tau)</pre>
<p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3.</p>
<p>Returns <code>A</code>, modified in-place, <code>jpvt</code>, which represents the pivoting matrix <code>P</code>, and <code>tau</code>, which stores the elementary reflectors.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L743-L750">source</a><h3 id="LinearAlgebra.LAPACK.gerqf!">
<code>LinearAlgebra.LAPACK.gerqf!</code><span class="docstring-category">Function</span>
</h3>
<pre>gerqf!(A, tau)</pre>
<p>Compute the <code>RQ</code> factorization of <code>A</code>, <code>A = RQ</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p>
<p>Returns <code>A</code> and <code>tau</code> modified in-place.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L644-L652">source</a><pre>gerqf!(A) -&gt; (A, tau)</pre>
<p>Compute the <code>RQ</code> factorization of <code>A</code>, <code>A = RQ</code>.</p>
<p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L718-L725">source</a><h3 id="LinearAlgebra.LAPACK.geqrt!">
<code>LinearAlgebra.LAPACK.geqrt!</code><span class="docstring-category">Function</span>
</h3>
<pre>geqrt!(A, T)</pre>
<p>Compute the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>T</code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of <code>T</code> sets the block size and it must be between 1 and <code>n</code>. The second dimension of <code>T</code> must equal the smallest dimension of <code>A</code>.</p>
<p>Returns <code>A</code> and <code>T</code> modified in-place.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L607-L617">source</a><pre>geqrt!(A, nb) -&gt; (A, T)</pre>
<p>Compute the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>nb</code> sets the block size and it must be between 1 and <code>n</code>, the second dimension of <code>A</code>.</p>
<p>Returns <code>A</code>, modified in-place, and <code>T</code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L686-L695">source</a><h3 id="LinearAlgebra.LAPACK.geqrt3!">
<code>LinearAlgebra.LAPACK.geqrt3!</code><span class="docstring-category">Function</span>
</h3>
<pre>geqrt3!(A, T)</pre>
<p>Recursively computes the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>T</code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of <code>T</code> sets the block size and it must be between 1 and <code>n</code>. The second dimension of <code>T</code> must equal the smallest dimension of <code>A</code>.</p>
<p>Returns <code>A</code> and <code>T</code> modified in-place.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L620-L630">source</a><pre>geqrt3!(A) -&gt; (A, T)</pre>
<p>Recursively computes the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>.</p>
<p>Returns <code>A</code>, modified in-place, and <code>T</code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L698-L705">source</a><h3 id="LinearAlgebra.LAPACK.getrf!">
<code>LinearAlgebra.LAPACK.getrf!</code><span class="docstring-category">Function</span>
</h3>
<pre>getrf!(A) -&gt; (A, ipiv, info)</pre>
<p>Compute the pivoted <code>LU</code> factorization of <code>A</code>, <code>A = LU</code>.</p>
<p>Returns <code>A</code>, modified in-place, <code>ipiv</code>, the pivoting information, and an <code>info</code> code which indicates success (<code>info = 0</code>), a singular value in <code>U</code> (<code>info = i</code>, in which case <code>U[i,i]</code> is singular), or an error code (<code>info &lt; 0</code>).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L655-L663">source</a><h3 id="LinearAlgebra.LAPACK.tzrzf!">
<code>LinearAlgebra.LAPACK.tzrzf!</code><span class="docstring-category">Function</span>
</h3>
<pre>tzrzf!(A) -&gt; (A, tau)</pre>
<p>Transforms the upper trapezoidal matrix <code>A</code> to upper triangular form in-place. Returns <code>A</code> and <code>tau</code>, the scalar parameters for the elementary reflectors of the transformation.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L853-L859">source</a><h3 id="LinearAlgebra.LAPACK.ormrz!">
<code>LinearAlgebra.LAPACK.ormrz!</code><span class="docstring-category">Function</span>
</h3>
<pre>ormrz!(side, trans, A, tau, C)</pre>
<p>Multiplies the matrix <code>C</code> by <code>Q</code> from the transformation supplied by <code>tzrzf!</code>. Depending on <code>side</code> or <code>trans</code> the multiplication can be left-sided (<code>side = L, Q*C</code>) or right-sided (<code>side = R, C*Q</code>) and <code>Q</code> can be unmodified (<code>trans = N</code>), transposed (<code>trans = T</code>), or conjugate transposed (<code>trans = C</code>). Returns matrix <code>C</code> which is modified in-place with the result of the multiplication.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L841-L850">source</a><h3 id="LinearAlgebra.LAPACK.gels!">
<code>LinearAlgebra.LAPACK.gels!</code><span class="docstring-category">Function</span>
</h3>
<pre>gels!(trans, A, B) -&gt; (F, B, ssr)</pre>
<p>Solves the linear equation <code>A * X = B</code>, <code>transpose(A) * X = B</code>, or <code>adjoint(A) * X = B</code> using a QR or LQ factorization. Modifies the matrix/vector <code>B</code> in place with the solution. <code>A</code> is overwritten with its <code>QR</code> or <code>LQ</code> factorization. <code>trans</code> may be one of <code>N</code> (no modification), <code>T</code> (transpose), or <code>C</code> (conjugate transpose). <code>gels!</code> searches for the minimum norm/least squares solution. <code>A</code> may be under or over determined. The solution is returned in <code>B</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L993-L1002">source</a><h3 id="LinearAlgebra.LAPACK.gesv!">
<code>LinearAlgebra.LAPACK.gesv!</code><span class="docstring-category">Function</span>
</h3>
<pre>gesv!(A, B) -&gt; (B, A, ipiv)</pre>
<p>Solves the linear equation <code>A * X = B</code> where <code>A</code> is a square matrix using the <code>LU</code> factorization of <code>A</code>. <code>A</code> is overwritten with its <code>LU</code> factorization and <code>B</code> is overwritten with the solution <code>X</code>. <code>ipiv</code> contains the pivoting information for the <code>LU</code> factorization of <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1005-L1012">source</a><h3 id="LinearAlgebra.LAPACK.getrs!">
<code>LinearAlgebra.LAPACK.getrs!</code><span class="docstring-category">Function</span>
</h3>
<pre>getrs!(trans, A, ipiv, B)</pre>
<p>Solves the linear equation <code>A * X = B</code>, <code>transpose(A) * X = B</code>, or <code>adjoint(A) * X = B</code> for square <code>A</code>. Modifies the matrix/vector <code>B</code> in place with the solution. <code>A</code> is the <code>LU</code> factorization from <code>getrf!</code>, with <code>ipiv</code> the pivoting information. <code>trans</code> may be one of <code>N</code> (no modification), <code>T</code> (transpose), or <code>C</code> (conjugate transpose).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1015-L1023">source</a><h3 id="LinearAlgebra.LAPACK.getri!">
<code>LinearAlgebra.LAPACK.getri!</code><span class="docstring-category">Function</span>
</h3>
<pre>getri!(A, ipiv)</pre>
<p>Computes the inverse of <code>A</code>, using its <code>LU</code> factorization found by <code>getrf!</code>. <code>ipiv</code> is the pivot information output and <code>A</code> contains the <code>LU</code> factorization of <code>getrf!</code>. <code>A</code> is overwritten with its inverse.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1026-L1033">source</a><h3 id="LinearAlgebra.LAPACK.gesvx!">
<code>LinearAlgebra.LAPACK.gesvx!</code><span class="docstring-category">Function</span>
</h3>
<pre>gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -&gt; (X, equed, R, C, B, rcond, ferr, berr, work)</pre>
<p>Solves the linear equation <code>A * X = B</code> (<code>trans = N</code>), <code>transpose(A) * X = B</code> (<code>trans = T</code>), or <code>adjoint(A) * X = B</code> (<code>trans = C</code>) using the <code>LU</code> factorization of <code>A</code>. <code>fact</code> may be <code>E</code>, in which case <code>A</code> will be equilibrated and copied to <code>AF</code>; <code>F</code>, in which case <code>AF</code> and <code>ipiv</code> from a previous <code>LU</code> factorization are inputs; or <code>N</code>, in which case <code>A</code> will be copied to <code>AF</code> and then factored. If <code>fact = F</code>, <code>equed</code> may be <code>N</code>, meaning <code>A</code> has not been equilibrated; <code>R</code>, meaning <code>A</code> was multiplied by <code>Diagonal(R)</code> from the left; <code>C</code>, meaning <code>A</code> was multiplied by <code>Diagonal(C)</code> from the right; or <code>B</code>, meaning <code>A</code> was multiplied by <code>Diagonal(R)</code> from the left and <code>Diagonal(C)</code> from the right. If <code>fact = F</code> and <code>equed = R</code> or <code>B</code> the elements of <code>R</code> must all be positive. If <code>fact = F</code> and <code>equed = C</code> or <code>B</code> the elements of <code>C</code> must all be positive.</p>
<p>Returns the solution <code>X</code>; <code>equed</code>, which is an output if <code>fact</code> is not <code>N</code>, and describes the equilibration that was performed; <code>R</code>, the row equilibration diagonal; <code>C</code>, the column equilibration diagonal; <code>B</code>, which may be overwritten with its equilibrated form <code>Diagonal(R)*B</code> (if <code>trans = N</code> and <code>equed = R,B</code>) or <code>Diagonal(C)*B</code> (if <code>trans = T,C</code> and <code>equed = C,B</code>); <code>rcond</code>, the reciprocal condition number of <code>A</code> after equilbrating; <code>ferr</code>, the forward error bound for each solution vector in <code>X</code>; <code>berr</code>, the forward error bound for each solution vector in <code>X</code>; and <code>work</code>, the reciprocal pivot growth factor.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1178-L1201">source</a><pre>gesvx!(A, B)</pre>
<p>The no-equilibration, no-transpose simplification of <code>gesvx!</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1205-L1209">source</a><h3 id="LinearAlgebra.LAPACK.gelsd!">
<code>LinearAlgebra.LAPACK.gelsd!</code><span class="docstring-category">Function</span>
</h3>
<pre>gelsd!(A, B, rcond) -&gt; (B, rnk)</pre>
<p>Computes the least norm solution of <code>A * X = B</code> by finding the <code>SVD</code> factorization of <code>A</code>, then dividing-and-conquering the problem. <code>B</code> is overwritten with the solution <code>X</code>. Singular values below <code>rcond</code> will be treated as zero. Returns the solution in <code>B</code> and the effective rank of <code>A</code> in <code>rnk</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1404-L1412">source</a><h3 id="LinearAlgebra.LAPACK.gelsy!">
<code>LinearAlgebra.LAPACK.gelsy!</code><span class="docstring-category">Function</span>
</h3>
<pre>gelsy!(A, B, rcond) -&gt; (B, rnk)</pre>
<p>Computes the least norm solution of <code>A * X = B</code> by finding the full <code>QR</code> factorization of <code>A</code>, then dividing-and-conquering the problem. <code>B</code> is overwritten with the solution <code>X</code>. Singular values below <code>rcond</code> will be treated as zero. Returns the solution in <code>B</code> and the effective rank of <code>A</code> in <code>rnk</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1415-L1423">source</a><h3 id="LinearAlgebra.LAPACK.gglse!">
<code>LinearAlgebra.LAPACK.gglse!</code><span class="docstring-category">Function</span>
</h3>
<pre>gglse!(A, c, B, d) -&gt; (X,res)</pre>
<p>Solves the equation <code>A * x = c</code> where <code>x</code> is subject to the equality constraint <code>B * x = d</code>. Uses the formula <code>||c - A*x||^2 = 0</code> to solve. Returns <code>X</code> and the residual sum-of-squares.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1477-L1483">source</a><h3 id="LinearAlgebra.LAPACK.geev!">
<code>LinearAlgebra.LAPACK.geev!</code><span class="docstring-category">Function</span>
</h3>
<pre>geev!(jobvl, jobvr, A) -&gt; (W, VL, VR)</pre>
<p>Finds the eigensystem of <code>A</code>. If <code>jobvl = N</code>, the left eigenvectors of <code>A</code> aren't computed. If <code>jobvr = N</code>, the right eigenvectors of <code>A</code> aren't computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed. Returns the eigenvalues in <code>W</code>, the right eigenvectors in <code>VR</code>, and the left eigenvectors in <code>VL</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1774-L1782">source</a><h3 id="LinearAlgebra.LAPACK.gesdd!">
<code>LinearAlgebra.LAPACK.gesdd!</code><span class="docstring-category">Function</span>
</h3>
<pre>gesdd!(job, A) -&gt; (U, S, VT)</pre>
<p>Finds the singular value decomposition of <code>A</code>, <code>A = U * S * V'</code>, using a divide and conquer approach. If <code>job = A</code>, all the columns of <code>U</code> and the rows of <code>V'</code> are computed. If <code>job = N</code>, no columns of <code>U</code> or rows of <code>V'</code> are computed. If <code>job = O</code>, <code>A</code> is overwritten with the columns of (thin) <code>U</code> and the rows of (thin) <code>V'</code>. If <code>job = S</code>, the columns of (thin) <code>U</code> and the rows of (thin) <code>V'</code> are computed and returned separately.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1785-L1794">source</a><h3 id="LinearAlgebra.LAPACK.gesvd!">
<code>LinearAlgebra.LAPACK.gesvd!</code><span class="docstring-category">Function</span>
</h3>
<pre>gesvd!(jobu, jobvt, A) -&gt; (U, S, VT)</pre>
<p>Finds the singular value decomposition of <code>A</code>, <code>A = U * S * V'</code>. If <code>jobu = A</code>, all the columns of <code>U</code> are computed. If <code>jobvt = A</code> all the rows of <code>V'</code> are computed. If <code>jobu = N</code>, no columns of <code>U</code> are computed. If <code>jobvt = N</code> no rows of <code>V'</code> are computed. If <code>jobu = O</code>, <code>A</code> is overwritten with the columns of (thin) <code>U</code>. If <code>jobvt = O</code>, <code>A</code> is overwritten with the rows of (thin) <code>V'</code>. If <code>jobu = S</code>, the columns of (thin) <code>U</code> are computed and returned separately. If <code>jobvt = S</code> the rows of (thin) <code>V'</code> are computed and returned separately. <code>jobu</code> and <code>jobvt</code> can't both be <code>O</code>.</p>
<p>Returns <code>U</code>, <code>S</code>, and <code>Vt</code>, where <code>S</code> are the singular values of <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1797-L1810">source</a><h3 id="LinearAlgebra.LAPACK.ggsvd!">
<code>LinearAlgebra.LAPACK.ggsvd!</code><span class="docstring-category">Function</span>
</h3>
<pre>ggsvd!(jobu, jobv, jobq, A, B) -&gt; (U, V, Q, alpha, beta, k, l, R)</pre>
<p>Finds the generalized singular value decomposition of <code>A</code> and <code>B</code>, <code>U'*A*Q = D1*R</code> and <code>V'*B*Q = D2*R</code>. <code>D1</code> has <code>alpha</code> on its diagonal and <code>D2</code> has <code>beta</code> on its diagonal. If <code>jobu = U</code>, the orthogonal/unitary matrix <code>U</code> is computed. If <code>jobv = V</code> the orthogonal/unitary matrix <code>V</code> is computed. If <code>jobq = Q</code>, the orthogonal/unitary matrix <code>Q</code> is computed. If <code>jobu</code>, <code>jobv</code> or <code>jobq</code> is <code>N</code>, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1813-L1823">source</a><h3 id="LinearAlgebra.LAPACK.ggsvd3!">
<code>LinearAlgebra.LAPACK.ggsvd3!</code><span class="docstring-category">Function</span>
</h3>
<pre>ggsvd3!(jobu, jobv, jobq, A, B) -&gt; (U, V, Q, alpha, beta, k, l, R)</pre>
<p>Finds the generalized singular value decomposition of <code>A</code> and <code>B</code>, <code>U'*A*Q = D1*R</code> and <code>V'*B*Q = D2*R</code>. <code>D1</code> has <code>alpha</code> on its diagonal and <code>D2</code> has <code>beta</code> on its diagonal. If <code>jobu = U</code>, the orthogonal/unitary matrix <code>U</code> is computed. If <code>jobv = V</code> the orthogonal/unitary matrix <code>V</code> is computed. If <code>jobq = Q</code>, the orthogonal/unitary matrix <code>Q</code> is computed. If <code>jobu</code>, <code>jobv</code>, or <code>jobq</code> is <code>N</code>, that matrix is not computed. This function requires LAPACK 3.6.0.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L1944-L1953">source</a><h3 id="LinearAlgebra.LAPACK.geevx!">
<code>LinearAlgebra.LAPACK.geevx!</code><span class="docstring-category">Function</span>
</h3>
<pre>geevx!(balanc, jobvl, jobvr, sense, A) -&gt; (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)</pre>
<p>Finds the eigensystem of <code>A</code> with matrix balancing. If <code>jobvl = N</code>, the left eigenvectors of <code>A</code> aren't computed. If <code>jobvr = N</code>, the right eigenvectors of <code>A</code> aren't computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed. If <code>balanc = N</code>, no balancing is performed. If <code>balanc = P</code>, <code>A</code> is permuted but not scaled. If <code>balanc = S</code>, <code>A</code> is scaled but not permuted. If <code>balanc = B</code>, <code>A</code> is permuted and scaled. If <code>sense = N</code>, no reciprocal condition numbers are computed. If <code>sense = E</code>, reciprocal condition numbers are computed for the eigenvalues only. If <code>sense = V</code>, reciprocal condition numbers are computed for the right eigenvectors only. If <code>sense = B</code>, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If <code>sense = E,B</code>, the right and left eigenvectors must be computed.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2256-L2272">source</a><h3 id="LinearAlgebra.LAPACK.ggev!">
<code>LinearAlgebra.LAPACK.ggev!</code><span class="docstring-category">Function</span>
</h3>
<pre>ggev!(jobvl, jobvr, A, B) -&gt; (alpha, beta, vl, vr)</pre>
<p>Finds the generalized eigendecomposition of <code>A</code> and <code>B</code>. If <code>jobvl = N</code>, the left eigenvectors aren't computed. If <code>jobvr = N</code>, the right eigenvectors aren't computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2275-L2282">source</a><h3 id="LinearAlgebra.LAPACK.gtsv!">
<code>LinearAlgebra.LAPACK.gtsv!</code><span class="docstring-category">Function</span>
</h3>
<pre>gtsv!(dl, d, du, B)</pre>
<p>Solves the equation <code>A * X = B</code> where <code>A</code> is a tridiagonal matrix with <code>dl</code> on the subdiagonal, <code>d</code> on the diagonal, and <code>du</code> on the superdiagonal.</p>
<p>Overwrites <code>B</code> with the solution <code>X</code> and returns it.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2454-L2462">source</a><h3 id="LinearAlgebra.LAPACK.gttrf!">
<code>LinearAlgebra.LAPACK.gttrf!</code><span class="docstring-category">Function</span>
</h3>
<pre>gttrf!(dl, d, du) -&gt; (dl, d, du, du2, ipiv)</pre>
<p>Finds the <code>LU</code> factorization of a tridiagonal matrix with <code>dl</code> on the subdiagonal, <code>d</code> on the diagonal, and <code>du</code> on the superdiagonal.</p>
<p>Modifies <code>dl</code>, <code>d</code>, and <code>du</code> in-place and returns them and the second superdiagonal <code>du2</code> and the pivoting vector <code>ipiv</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2465-L2473">source</a><h3 id="LinearAlgebra.LAPACK.gttrs!">
<code>LinearAlgebra.LAPACK.gttrs!</code><span class="docstring-category">Function</span>
</h3>
<pre>gttrs!(trans, dl, d, du, du2, ipiv, B)</pre>
<p>Solves the equation <code>A * X = B</code> (<code>trans = N</code>), <code>transpose(A) * X = B</code> (<code>trans = T</code>), or <code>adjoint(A) * X = B</code> (<code>trans = C</code>) using the <code>LU</code> factorization computed by <code>gttrf!</code>. <code>B</code> is overwritten with the solution <code>X</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2476-L2482">source</a><h3 id="LinearAlgebra.LAPACK.orglq!">
<code>LinearAlgebra.LAPACK.orglq!</code><span class="docstring-category">Function</span>
</h3>
<pre>orglq!(A, tau, k = length(tau))</pre>
<p>Explicitly finds the matrix <code>Q</code> of a <code>LQ</code> factorization after calling <code>gelqf!</code> on <code>A</code>. Uses the output of <code>gelqf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2883-L2888">source</a><h3 id="LinearAlgebra.LAPACK.orgqr!">
<code>LinearAlgebra.LAPACK.orgqr!</code><span class="docstring-category">Function</span>
</h3>
<pre>orgqr!(A, tau, k = length(tau))</pre>
<p>Explicitly finds the matrix <code>Q</code> of a <code>QR</code> factorization after calling <code>geqrf!</code> on <code>A</code>. Uses the output of <code>geqrf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2891-L2896">source</a><h3 id="LinearAlgebra.LAPACK.orgql!">
<code>LinearAlgebra.LAPACK.orgql!</code><span class="docstring-category">Function</span>
</h3>
<pre>orgql!(A, tau, k = length(tau))</pre>
<p>Explicitly finds the matrix <code>Q</code> of a <code>QL</code> factorization after calling <code>geqlf!</code> on <code>A</code>. Uses the output of <code>geqlf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2899-L2904">source</a><h3 id="LinearAlgebra.LAPACK.orgrq!">
<code>LinearAlgebra.LAPACK.orgrq!</code><span class="docstring-category">Function</span>
</h3>
<pre>orgrq!(A, tau, k = length(tau))</pre>
<p>Explicitly finds the matrix <code>Q</code> of a <code>RQ</code> factorization after calling <code>gerqf!</code> on <code>A</code>. Uses the output of <code>gerqf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2907-L2912">source</a><h3 id="LinearAlgebra.LAPACK.ormlq!">
<code>LinearAlgebra.LAPACK.ormlq!</code><span class="docstring-category">Function</span>
</h3>
<pre>ormlq!(side, trans, A, tau, C)</pre>
<p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>transpose(Q) * C</code> (<code>trans = T</code>), <code>adjoint(Q) * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>LQ</code> factorization of <code>A</code> computed using <code>gelqf!</code>. <code>C</code> is overwritten.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2915-L2922">source</a><h3 id="LinearAlgebra.LAPACK.ormqr!">
<code>LinearAlgebra.LAPACK.ormqr!</code><span class="docstring-category">Function</span>
</h3>
<pre>ormqr!(side, trans, A, tau, C)</pre>
<p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>transpose(Q) * C</code> (<code>trans = T</code>), <code>adjoint(Q) * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QR</code> factorization of <code>A</code> computed using <code>geqrf!</code>. <code>C</code> is overwritten.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2925-L2932">source</a><h3 id="LinearAlgebra.LAPACK.ormql!">
<code>LinearAlgebra.LAPACK.ormql!</code><span class="docstring-category">Function</span>
</h3>
<pre>ormql!(side, trans, A, tau, C)</pre>
<p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>transpose(Q) * C</code> (<code>trans = T</code>), <code>adjoint(Q) * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QL</code> factorization of <code>A</code> computed using <code>geqlf!</code>. <code>C</code> is overwritten.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2935-L2942">source</a><h3 id="LinearAlgebra.LAPACK.ormrq!">
<code>LinearAlgebra.LAPACK.ormrq!</code><span class="docstring-category">Function</span>
</h3>
<pre>ormrq!(side, trans, A, tau, C)</pre>
<p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>transpose(Q) * C</code> (<code>trans = T</code>), <code>adjoint(Q) * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>RQ</code> factorization of <code>A</code> computed using <code>gerqf!</code>. <code>C</code> is overwritten.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2945-L2952">source</a><h3 id="LinearAlgebra.LAPACK.gemqrt!">
<code>LinearAlgebra.LAPACK.gemqrt!</code><span class="docstring-category">Function</span>
</h3>
<pre>gemqrt!(side, trans, V, T, C)</pre>
<p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>transpose(Q) * C</code> (<code>trans = T</code>), <code>adjoint(Q) * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QR</code> factorization of <code>A</code> computed using <code>geqrt!</code>. <code>C</code> is overwritten.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L2955-L2962">source</a><h3 id="LinearAlgebra.LAPACK.posv!">
<code>LinearAlgebra.LAPACK.posv!</code><span class="docstring-category">Function</span>
</h3>
<pre>posv!(uplo, A, B) -&gt; (A, B)</pre>
<p>Finds the solution to <code>A * X = B</code> where <code>A</code> is a symmetric or Hermitian positive definite matrix. If <code>uplo = U</code> the upper Cholesky decomposition of <code>A</code> is computed. If <code>uplo = L</code> the lower Cholesky decomposition of <code>A</code> is computed. <code>A</code> is overwritten by its Cholesky decomposition. <code>B</code> is overwritten with the solution <code>X</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3097-L3105">source</a><h3 id="LinearAlgebra.LAPACK.potrf!">
<code>LinearAlgebra.LAPACK.potrf!</code><span class="docstring-category">Function</span>
</h3>
<pre>potrf!(uplo, A)</pre>
<p>Computes the Cholesky (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) decomposition of positive-definite matrix <code>A</code>. <code>A</code> is overwritten and returned with an info code.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3108-L3114">source</a><h3 id="LinearAlgebra.LAPACK.potri!">
<code>LinearAlgebra.LAPACK.potri!</code><span class="docstring-category">Function</span>
</h3>
<pre>potri!(uplo, A)</pre>
<p>Computes the inverse of positive-definite matrix <code>A</code> after calling <code>potrf!</code> to find its (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) Cholesky decomposition.</p>
<p><code>A</code> is overwritten by its inverse and returned.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3117-L3125">source</a><h3 id="LinearAlgebra.LAPACK.potrs!">
<code>LinearAlgebra.LAPACK.potrs!</code><span class="docstring-category">Function</span>
</h3>
<pre>potrs!(uplo, A, B)</pre>
<p>Finds the solution to <code>A * X = B</code> where <code>A</code> is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by <code>potrf!</code>. If <code>uplo = U</code> the upper Cholesky decomposition of <code>A</code> was computed. If <code>uplo = L</code> the lower Cholesky decomposition of <code>A</code> was computed. <code>B</code> is overwritten with the solution <code>X</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3128-L3136">source</a><h3 id="LinearAlgebra.LAPACK.pstrf!">
<code>LinearAlgebra.LAPACK.pstrf!</code><span class="docstring-category">Function</span>
</h3>
<pre>pstrf!(uplo, A, tol) -&gt; (A, piv, rank, info)</pre>
<p>Computes the (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) pivoted Cholesky decomposition of positive-definite matrix <code>A</code> with a user-set tolerance <code>tol</code>. <code>A</code> is overwritten by its Cholesky decomposition.</p>
<p>Returns <code>A</code>, the pivots <code>piv</code>, the rank of <code>A</code>, and an <code>info</code> code. If <code>info = 0</code>, the factorization succeeded. If <code>info = i &gt; 0</code>, then <code>A</code> is indefinite or rank-deficient.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3139-L3149">source</a><h3 id="LinearAlgebra.LAPACK.ptsv!">
<code>LinearAlgebra.LAPACK.ptsv!</code><span class="docstring-category">Function</span>
</h3>
<pre>ptsv!(D, E, B)</pre>
<p>Solves <code>A * X = B</code> for positive-definite tridiagonal <code>A</code>. <code>D</code> is the diagonal of <code>A</code> and <code>E</code> is the off-diagonal. <code>B</code> is overwritten with the solution <code>X</code> and returned.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3206-L3212">source</a><h3 id="LinearAlgebra.LAPACK.pttrf!">
<code>LinearAlgebra.LAPACK.pttrf!</code><span class="docstring-category">Function</span>
</h3>
<pre>pttrf!(D, E)</pre>
<p>Computes the LDLt factorization of a positive-definite tridiagonal matrix with <code>D</code> as diagonal and <code>E</code> as off-diagonal. <code>D</code> and <code>E</code> are overwritten and returned.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3215-L3221">source</a><h3 id="LinearAlgebra.LAPACK.pttrs!">
<code>LinearAlgebra.LAPACK.pttrs!</code><span class="docstring-category">Function</span>
</h3>
<pre>pttrs!(D, E, B)</pre>
<p>Solves <code>A * X = B</code> for positive-definite tridiagonal <code>A</code> with diagonal <code>D</code> and off-diagonal <code>E</code> after computing <code>A</code>'s LDLt factorization using <code>pttrf!</code>. <code>B</code> is overwritten with the solution <code>X</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3288-L3294">source</a><h3 id="LinearAlgebra.LAPACK.trtri!">
<code>LinearAlgebra.LAPACK.trtri!</code><span class="docstring-category">Function</span>
</h3>
<pre>trtri!(uplo, diag, A)</pre>
<p>Finds the inverse of (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>A</code> is overwritten with its inverse.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3354-L3361">source</a><h3 id="LinearAlgebra.LAPACK.trtrs!">
<code>LinearAlgebra.LAPACK.trtrs!</code><span class="docstring-category">Function</span>
</h3>
<pre>trtrs!(uplo, trans, diag, A, B)</pre>
<p>Solves <code>A * X = B</code> (<code>trans = N</code>), <code>transpose(A) * X = B</code> (<code>trans = T</code>), or <code>adjoint(A) * X = B</code> (<code>trans = C</code>) for (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>B</code> is overwritten with the solution <code>X</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3364-L3372">source</a><h3 id="LinearAlgebra.LAPACK.trcon!">
<code>LinearAlgebra.LAPACK.trcon!</code><span class="docstring-category">Function</span>
</h3>
<pre>trcon!(norm, uplo, diag, A)</pre>
<p>Finds the reciprocal condition number of (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. If <code>norm = I</code>, the condition number is found in the infinity norm. If <code>norm = O</code> or <code>1</code>, the condition number is found in the one norm.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3639-L3647">source</a><h3 id="LinearAlgebra.LAPACK.trevc!">
<code>LinearAlgebra.LAPACK.trevc!</code><span class="docstring-category">Function</span>
</h3>
<pre>trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))</pre>
<p>Finds the eigensystem of an upper triangular matrix <code>T</code>. If <code>side = R</code>, the right eigenvectors are computed. If <code>side = L</code>, the left eigenvectors are computed. If <code>side = B</code>, both sets are computed. If <code>howmny = A</code>, all eigenvectors are found. If <code>howmny = B</code>, all eigenvectors are found and backtransformed using <code>VL</code> and <code>VR</code>. If <code>howmny = S</code>, only the eigenvectors corresponding to the values in <code>select</code> are computed.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3650-L3660">source</a><h3 id="LinearAlgebra.LAPACK.trrfs!">
<code>LinearAlgebra.LAPACK.trrfs!</code><span class="docstring-category">Function</span>
</h3>
<pre>trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -&gt; (Ferr, Berr)</pre>
<p>Estimates the error in the solution to <code>A * X = B</code> (<code>trans = N</code>), <code>transpose(A) * X = B</code> (<code>trans = T</code>), <code>adjoint(A) * X = B</code> (<code>trans = C</code>) for <code>side = L</code>, or the equivalent equations a right-handed <code>side = R</code> <code>X * A</code> after computing <code>X</code> using <code>trtrs!</code>. If <code>uplo = U</code>, <code>A</code> is upper triangular. If <code>uplo = L</code>, <code>A</code> is lower triangular. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>Ferr</code> and <code>Berr</code> are optional inputs. <code>Ferr</code> is the forward error and <code>Berr</code> is the backward error, each component-wise.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3664-L3675">source</a><h3 id="LinearAlgebra.LAPACK.stev!">
<code>LinearAlgebra.LAPACK.stev!</code><span class="docstring-category">Function</span>
</h3>
<pre>stev!(job, dv, ev) -&gt; (dv, Zmat)</pre>
<p>Computes the eigensystem for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>job = N</code> only the eigenvalues are found and returned in <code>dv</code>. If <code>job = V</code> then the eigenvectors are also found and returned in <code>Zmat</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3840-L3847">source</a><h3 id="LinearAlgebra.LAPACK.stebz!">
<code>LinearAlgebra.LAPACK.stebz!</code><span class="docstring-category">Function</span>
</h3>
<pre>stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -&gt; (dv, iblock, isplit)</pre>
<p>Computes the eigenvalues for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. If <code>order = B</code>, eigvalues are ordered within a block. If <code>order = E</code>, they are ordered across all the blocks. <code>abstol</code> can be set as a tolerance for convergence.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3850-L3860">source</a><h3 id="LinearAlgebra.LAPACK.stegr!">
<code>LinearAlgebra.LAPACK.stegr!</code><span class="docstring-category">Function</span>
</h3>
<pre>stegr!(jobz, range, dv, ev, vl, vu, il, iu) -&gt; (w, Z)</pre>
<p>Computes the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. The eigenvalues are returned in <code>w</code> and the eigenvectors in <code>Z</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3863-L3873">source</a><h3 id="LinearAlgebra.LAPACK.stein!">
<code>LinearAlgebra.LAPACK.stein!</code><span class="docstring-category">Function</span>
</h3>
<pre>stein!(dv, ev_in, w_in, iblock_in, isplit_in)</pre>
<p>Computes the eigenvectors for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev_in</code> as off-diagonal. <code>w_in</code> specifies the input eigenvalues for which to find corresponding eigenvectors. <code>iblock_in</code> specifies the submatrices corresponding to the eigenvalues in <code>w_in</code>. <code>isplit_in</code> specifies the splitting points between the submatrix blocks.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L3876-L3884">source</a><h3 id="LinearAlgebra.LAPACK.syconv!">
<code>LinearAlgebra.LAPACK.syconv!</code><span class="docstring-category">Function</span>
</h3>
<pre>syconv!(uplo, A, ipiv) -&gt; (A, work)</pre>
<p>Converts a symmetric matrix <code>A</code> (which has been factorized into a triangular matrix) into two matrices <code>L</code> and <code>D</code>. If <code>uplo = U</code>, <code>A</code> is upper triangular. If <code>uplo = L</code>, it is lower triangular. <code>ipiv</code> is the pivot vector from the triangular factorization. <code>A</code> is overwritten by <code>L</code> and <code>D</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L4838-L4846">source</a><h3 id="LinearAlgebra.LAPACK.sysv!">
<code>LinearAlgebra.LAPACK.sysv!</code><span class="docstring-category">Function</span>
</h3>
<pre>sysv!(uplo, A, B) -&gt; (B, A, ipiv)</pre>
<p>Finds the solution to <code>A * X = B</code> for symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>. <code>A</code> is overwritten by its Bunch-Kaufman factorization. <code>ipiv</code> contains pivoting information about the factorization.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L4849-L4857">source</a><h3 id="LinearAlgebra.LAPACK.sytrf!">
<code>LinearAlgebra.LAPACK.sytrf!</code><span class="docstring-category">Function</span>
</h3>
<pre>sytrf!(uplo, A) -&gt; (A, ipiv, info)</pre>
<p>Computes the Bunch-Kaufman factorization of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored.</p>
<p>Returns <code>A</code>, overwritten by the factorization, a pivot vector <code>ipiv</code>, and the error code <code>info</code> which is a non-negative integer. If <code>info</code> is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position <code>info</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L4860-L4871">source</a><h3 id="LinearAlgebra.LAPACK.sytri!">
<code>LinearAlgebra.LAPACK.sytri!</code><span class="docstring-category">Function</span>
</h3>
<pre>sytri!(uplo, A, ipiv)</pre>
<p>Computes the inverse of a symmetric matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>A</code> is overwritten by its inverse.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L4874-L4880">source</a><h3 id="LinearAlgebra.LAPACK.sytrs!">
<code>LinearAlgebra.LAPACK.sytrs!</code><span class="docstring-category">Function</span>
</h3>
<pre>sytrs!(uplo, A, ipiv, B)</pre>
<p>Solves the equation <code>A * X = B</code> for a symmetric matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L4883-L4890">source</a><h3 id="LinearAlgebra.LAPACK.hesv!">
<code>LinearAlgebra.LAPACK.hesv!</code><span class="docstring-category">Function</span>
</h3>
<pre>hesv!(uplo, A, B) -&gt; (B, A, ipiv)</pre>
<p>Finds the solution to <code>A * X = B</code> for Hermitian matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>. <code>A</code> is overwritten by its Bunch-Kaufman factorization. <code>ipiv</code> contains pivoting information about the factorization.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L4894-L4902">source</a><h3 id="LinearAlgebra.LAPACK.hetrf!">
<code>LinearAlgebra.LAPACK.hetrf!</code><span class="docstring-category">Function</span>
</h3>
<pre>hetrf!(uplo, A) -&gt; (A, ipiv, info)</pre>
<p>Computes the Bunch-Kaufman factorization of a Hermitian matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored.</p>
<p>Returns <code>A</code>, overwritten by the factorization, a pivot vector <code>ipiv</code>, and the error code <code>info</code> which is a non-negative integer. If <code>info</code> is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position <code>info</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L4905-L4916">source</a><h3 id="LinearAlgebra.LAPACK.hetri!">
<code>LinearAlgebra.LAPACK.hetri!</code><span class="docstring-category">Function</span>
</h3>
<pre>hetri!(uplo, A, ipiv)</pre>
<p>Computes the inverse of a Hermitian matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>A</code> is overwritten by its inverse.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L4919-L4925">source</a><h3 id="LinearAlgebra.LAPACK.hetrs!">
<code>LinearAlgebra.LAPACK.hetrs!</code><span class="docstring-category">Function</span>
</h3>
<pre>hetrs!(uplo, A, ipiv, B)</pre>
<p>Solves the equation <code>A * X = B</code> for a Hermitian matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L4928-L4935">source</a><h3 id="LinearAlgebra.LAPACK.syev!">
<code>LinearAlgebra.LAPACK.syev!</code><span class="docstring-category">Function</span>
</h3>
<pre>syev!(jobz, uplo, A)</pre>
<p>Finds the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper triangle of <code>A</code> is used. If <code>uplo = L</code>, the lower triangle of <code>A</code> is used.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L5237-L5243">source</a><h3 id="LinearAlgebra.LAPACK.syevr!">
<code>LinearAlgebra.LAPACK.syevr!</code><span class="docstring-category">Function</span>
</h3>
<pre>syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -&gt; (W, Z)</pre>
<p>Finds the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper triangle of <code>A</code> is used. If <code>uplo = L</code>, the lower triangle of <code>A</code> is used. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. <code>abstol</code> can be set as a tolerance for convergence.</p>
<p>The eigenvalues are returned in <code>W</code> and the eigenvectors in <code>Z</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L5246-L5258">source</a><h3 id="LinearAlgebra.LAPACK.sygvd!">
<code>LinearAlgebra.LAPACK.sygvd!</code><span class="docstring-category">Function</span>
</h3>
<pre>sygvd!(itype, jobz, uplo, A, B) -&gt; (w, A, B)</pre>
<p>Finds the generalized eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code> and symmetric positive-definite matrix <code>B</code>. If <code>uplo = U</code>, the upper triangles of <code>A</code> and <code>B</code> are used. If <code>uplo = L</code>, the lower triangles of <code>A</code> and <code>B</code> are used. If <code>itype = 1</code>, the problem to solve is <code>A * x = lambda * B * x</code>. If <code>itype = 2</code>, the problem to solve is <code>A * B * x = lambda * x</code>. If <code>itype = 3</code>, the problem to solve is <code>B * A * x = lambda * x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L5262-L5273">source</a><h3 id="LinearAlgebra.LAPACK.bdsqr!">
<code>LinearAlgebra.LAPACK.bdsqr!</code><span class="docstring-category">Function</span>
</h3>
<pre>bdsqr!(uplo, d, e_, Vt, U, C) -&gt; (d, Vt, U, C)</pre>
<p>Computes the singular value decomposition of a bidiagonal matrix with <code>d</code> on the diagonal and <code>e_</code> on the off-diagonal. If <code>uplo = U</code>, <code>e_</code> is the superdiagonal. If <code>uplo = L</code>, <code>e_</code> is the subdiagonal. Can optionally also compute the product <code>Q' * C</code>.</p>
<p>Returns the singular values in <code>d</code>, and the matrix <code>C</code> overwritten with <code>Q' * C</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L5326-L5335">source</a><h3 id="LinearAlgebra.LAPACK.bdsdc!">
<code>LinearAlgebra.LAPACK.bdsdc!</code><span class="docstring-category">Function</span>
</h3>
<pre>bdsdc!(uplo, compq, d, e_) -&gt; (d, e, u, vt, q, iq)</pre>
<p>Computes the singular value decomposition of a bidiagonal matrix with <code>d</code> on the diagonal and <code>e_</code> on the off-diagonal using a divide and conqueq method. If <code>uplo = U</code>, <code>e_</code> is the superdiagonal. If <code>uplo = L</code>, <code>e_</code> is the subdiagonal. If <code>compq = N</code>, only the singular values are found. If <code>compq = I</code>, the singular values and vectors are found. If <code>compq = P</code>, the singular values and vectors are found in compact form. Only works for real types.</p>
<p>Returns the singular values in <code>d</code>, and if <code>compq = P</code>, the compact singular vectors in <code>iq</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L5395-L5407">source</a><h3 id="LinearAlgebra.LAPACK.gecon!">
<code>LinearAlgebra.LAPACK.gecon!</code><span class="docstring-category">Function</span>
</h3>
<pre>gecon!(normtype, A, anorm)</pre>
<p>Finds the reciprocal condition number of matrix <code>A</code>. If <code>normtype = I</code>, the condition number is found in the infinity norm. If <code>normtype = O</code> or <code>1</code>, the condition number is found in the one norm. <code>A</code> must be the result of <code>getrf!</code> and <code>anorm</code> is the norm of <code>A</code> in the relevant norm.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L5478-L5485">source</a><h3 id="LinearAlgebra.LAPACK.gehrd!">
<code>LinearAlgebra.LAPACK.gehrd!</code><span class="docstring-category">Function</span>
</h3>
<pre>gehrd!(ilo, ihi, A) -&gt; (A, tau)</pre>
<p>Converts a matrix <code>A</code> to Hessenberg form. If <code>A</code> is balanced with <code>gebal!</code> then <code>ilo</code> and <code>ihi</code> are the outputs of <code>gebal!</code>. Otherwise they should be <code>ilo = 1</code> and <code>ihi = size(A,2)</code>. <code>tau</code> contains the elementary reflectors of the factorization.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L5528-L5535">source</a><h3 id="LinearAlgebra.LAPACK.orghr!">
<code>LinearAlgebra.LAPACK.orghr!</code><span class="docstring-category">Function</span>
</h3>
<pre>orghr!(ilo, ihi, A, tau)</pre>
<p>Explicitly finds <code>Q</code>, the orthogonal/unitary matrix from <code>gehrd!</code>. <code>ilo</code>, <code>ihi</code>, <code>A</code>, and <code>tau</code> must correspond to the input/output to <code>gehrd!</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L5578-L5583">source</a><h3 id="LinearAlgebra.LAPACK.gees!">
<code>LinearAlgebra.LAPACK.gees!</code><span class="docstring-category">Function</span>
</h3>
<pre>gees!(jobvs, A) -&gt; (A, vs, w)</pre>
<p>Computes the eigenvalues (<code>jobvs = N</code>) or the eigenvalues and Schur vectors (<code>jobvs = V</code>) of matrix <code>A</code>. <code>A</code> is overwritten by its Schur form.</p>
<p>Returns <code>A</code>, <code>vs</code> containing the Schur vectors, and <code>w</code>, containing the eigenvalues.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L5827-L5835">source</a><h3 id="LinearAlgebra.LAPACK.gges!">
<code>LinearAlgebra.LAPACK.gges!</code><span class="docstring-category">Function</span>
</h3>
<pre>gges!(jobvsl, jobvsr, A, B) -&gt; (A, B, alpha, beta, vsl, vsr)</pre>
<p>Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (<code>jobsvl = V</code>), or right Schur vectors (<code>jobvsr = V</code>) of <code>A</code> and <code>B</code>.</p>
<p>The generalized eigenvalues are returned in <code>alpha</code> and <code>beta</code>. The left Schur vectors are returned in <code>vsl</code> and the right Schur vectors are returned in <code>vsr</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L5839-L5848">source</a><h3 id="LinearAlgebra.LAPACK.trexc!">
<code>LinearAlgebra.LAPACK.trexc!</code><span class="docstring-category">Function</span>
</h3>
<pre>trexc!(compq, ifst, ilst, T, Q) -&gt; (T, Q)</pre>
<p>Reorder the Schur factorization of a matrix. If <code>compq = V</code>, the Schur vectors <code>Q</code> are reordered. If <code>compq = N</code> they are not modified. <code>ifst</code> and <code>ilst</code> specify the reordering of the vectors.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L6147-L6153">source</a><h3 id="LinearAlgebra.LAPACK.trsen!">
<code>LinearAlgebra.LAPACK.trsen!</code><span class="docstring-category">Function</span>
</h3>
<pre>trsen!(compq, job, select, T, Q) -&gt; (T, Q, w, s, sep)</pre>
<p>Reorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If <code>job = N</code>, no condition numbers are found. If <code>job = E</code>, only the condition number for this cluster of eigenvalues is found. If <code>job = V</code>, only the condition number for the invariant subspace is found. If <code>job = B</code> then the condition numbers for the cluster and subspace are found. If <code>compq = V</code> the Schur vectors <code>Q</code> are updated. If <code>compq = N</code> the Schur vectors are not modified. <code>select</code> determines which eigenvalues are in the cluster.</p>
<p>Returns <code>T</code>, <code>Q</code>, reordered eigenvalues in <code>w</code>, the condition number of the cluster of eigenvalues <code>s</code>, and the condition number of the invariant subspace <code>sep</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L6156-L6171">source</a><h3 id="LinearAlgebra.LAPACK.tgsen!">
<code>LinearAlgebra.LAPACK.tgsen!</code><span class="docstring-category">Function</span>
</h3>
<pre>tgsen!(select, S, T, Q, Z) -&gt; (S, T, alpha, beta, Q, Z)</pre>
<p>Reorders the vectors of a generalized Schur decomposition. <code>select</code> specifies the eigenvalues in each cluster.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L6174-L6179">source</a><h3 id="LinearAlgebra.LAPACK.trsyl!">
<code>LinearAlgebra.LAPACK.trsyl!</code><span class="docstring-category">Function</span>
</h3>
<pre>trsyl!(transa, transb, A, B, C, isgn=1) -&gt; (C, scale)</pre>
<p>Solves the Sylvester matrix equation <code>A * X +/- X * B = scale*C</code> where <code>A</code> and <code>B</code> are both quasi-upper triangular. If <code>transa = N</code>, <code>A</code> is not modified. If <code>transa = T</code>, <code>A</code> is transposed. If <code>transa = C</code>, <code>A</code> is conjugate transposed. Similarly for <code>transb</code> and <code>B</code>. If <code>isgn = 1</code>, the equation <code>A * X + X * B = scale * C</code> is solved. If <code>isgn = -1</code>, the equation <code>A * X - X * B = scale * C</code> is solved.</p>
<p>Returns <code>X</code> (overwriting <code>C</code>) and <code>scale</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/stdlib/LinearAlgebra/src/lapack.jl#L6214-L6225">source</a><div class="_attribution">
  <p class="_attribution-p">
    © 2009–2018 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/v1.0.1/stdlib/LinearAlgebra/" class="_attribution-link" target="_blank">https://docs.julialang.org/en/v1.0.1/stdlib/LinearAlgebra/</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
