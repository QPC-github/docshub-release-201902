
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>backends.backend_pdf - Matplotlib 2.1 - W3cubDocs</title>
  
  <meta name="description" content=" A PDF matplotlib backend Author&#58; Jouni K Seppänen &#60;jks&#64;iki.fi&#62; ">
  <meta name="keywords" content="matplotlib, backends, backend, pdf, -, matplotlib~2.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~2.1/backend_pdf_api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/matplotlib~2.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~2.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 2.1</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
				
<h1 id="matplotlib-backends-backend-pdf">matplotlib.backends.backend_pdf</h1> <p id="module-matplotlib.backends.backend_pdf">A PDF matplotlib backend Author: Jouni K Seppänen &lt;<a class="reference external" href="http://matplotlib.org/cdn-cgi/l/email-protection#88e2e3fbaeabbbbfb3aeabbdbab3aeabbcb0b3e1e3e1aeabbcbeb3eee1" target="_blank">jks<span>@</span>iki<span>.</span>fi</a>&gt;</p> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.FigureCanvas">
<code>matplotlib.backends.backend_pdf.FigureCanvas</code> </dt> <dd>
<p>alias of <a class="reference internal" href="#matplotlib.backends.backend_pdf.FigureCanvasPdf" title="matplotlib.backends.backend_pdf.FigureCanvasPdf"><code>FigureCanvasPdf</code></a></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf">
<code>class matplotlib.backends.backend_pdf.FigureCanvasPdf(figure)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../backend_bases_api/#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><code>matplotlib.backend_bases.FigureCanvasBase</code></a></p> <p>The canvas the figure renders into. Calls the draw and print fig methods, creates the renderers, etc…</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>figure</strong></td> <td>(<a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a>) A high-level Figure instance</td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf.draw">
<code>draw()</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf.filetypes">
<code>filetypes = {'pdf': 'Portable Document Format'}</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf.fixed_dpi">
<code>fixed_dpi = 72</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf.get_default_filetype">
<code>get_default_filetype()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf">
<code>print_pdf(filename, **kwargs)</code> </dt> 
</dl> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.FigureManager">
<code>matplotlib.backends.backend_pdf.FigureManager</code> </dt> <dd>
<p>alias of <a class="reference internal" href="#matplotlib.backends.backend_pdf.FigureManagerPdf" title="matplotlib.backends.backend_pdf.FigureManagerPdf"><code>FigureManagerPdf</code></a></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.FigureManagerPdf">
<code>class matplotlib.backends.backend_pdf.FigureManagerPdf(canvas, num)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../backend_bases_api/#matplotlib.backend_bases.FigureManagerBase" title="matplotlib.backend_bases.FigureManagerBase"><code>matplotlib.backend_bases.FigureManagerBase</code></a></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf">
<code>class matplotlib.backends.backend_pdf.GraphicsContextPdf(file)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../backend_bases_api/#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><code>matplotlib.backend_bases.GraphicsContextBase</code></a></p> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd">
<code>alpha_cmd(alpha, forced, effective_alphas)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd">
<code>capstyle_cmd(style)</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyles">
<code>capstyles = {'butt': 0, 'round': 1, 'projecting': 2}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd">
<code>clip_cmd(cliprect, clippath)</code> </dt> <dd>
<p>Set clip rectangle. Calls self.pop() and self.push().</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.commands">
<code>commands = ((('_cliprect', '_clippath'), &lt;function GraphicsContextPdf.clip_cmd&gt;), (('_alpha', '_forced_alpha', '_effective_alphas'), &lt;function GraphicsContextPdf.alpha_cmd&gt;), (('_capstyle',), &lt;function GraphicsContextPdf.capstyle_cmd&gt;), (('_fillcolor',), &lt;function GraphicsContextPdf.fillcolor_cmd&gt;), (('_joinstyle',), &lt;function GraphicsContextPdf.joinstyle_cmd&gt;), (('_linewidth',), &lt;function GraphicsContextPdf.linewidth_cmd&gt;), (('_dashes',), &lt;function GraphicsContextPdf.dash_cmd&gt;), (('_rgb',), &lt;function GraphicsContextPdf.rgb_cmd&gt;), (('_hatch', '_hatch_color'), &lt;function GraphicsContextPdf.hatch_cmd&gt;))</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties">
<code>copy_properties(other)</code> </dt> <dd>
<p>Copy properties of other into self.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.dash_cmd">
<code>dash_cmd(dashes)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.delta">
<code>delta(other)</code> </dt> <dd>
<p>Copy properties of other into self and return PDF commands needed to transform self into other.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.fill">
<code>fill(*args)</code> </dt> <dd>
<p>Predicate: does the path need to be filled?</p> <p>An optional argument can be used to specify an alternative _fillcolor, as needed by RendererPdf.draw_markers.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd">
<code>fillcolor_cmd(rgb)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize">
<code>finalize()</code> </dt> <dd>
<p>Make sure every pushed graphics state is popped.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd">
<code>hatch_cmd(hatch, hatch_color)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd">
<code>joinstyle_cmd(style)</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyles">
<code>joinstyles = {'miter': 0, 'round': 1, 'bevel': 2}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.linewidth_cmd">
<code>linewidth_cmd(width)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.paint">
<code>paint()</code> </dt> <dd>
<p>Return the appropriate pdf operator to cause the path to be stroked, filled, or both.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.pop">
<code>pop()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.push">
<code>push()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd">
<code>rgb_cmd(rgb)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.stroke">
<code>stroke()</code> </dt> <dd>
<p>Predicate: does the path need to be stroked (its outline drawn)? This tests for the various conditions that disable stroking the path, in which case it would presumably be filled.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.Name">
<code>class matplotlib.backends.backend_pdf.Name(name)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>PDF name object.</p> <dl class="staticmethod"> <dt id="matplotlib.backends.backend_pdf.Name.hexify">
<code>static hexify(match)</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Name.name">
<code>name</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Name.pdfRepr">
<code>pdfRepr()</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.Operator">
<code>class matplotlib.backends.backend_pdf.Operator(op)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>PDF operator object.</p> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Operator.op">
<code>op</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Operator.pdfRepr">
<code>pdfRepr()</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.PdfFile">
<code>class matplotlib.backends.backend_pdf.PdfFile(filename, metadata=None)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>PDF file object.</p> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles">
<code>addGouraudTriangles(points, colors)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.alphaState">
<code>alphaState(alpha)</code> </dt> <dd>
<p>Return name of an ExtGState that sets alpha to the given value</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.beginStream">
<code>beginStream(id, len, extra=None, png=None)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.close">
<code>close()</code> </dt> <dd>
<p>Flush all buffers and free all resources.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor">
<code>createType1Descriptor(t1font, fontfile)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.dviFontName">
<code>dviFontName(dvifont)</code> </dt> <dd>
<p>Given a dvi font object, return a name suitable for Op.selectfont. This registers the font information in self.dviFontInfo if not yet registered.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.embedTTF">
<code>embedTTF(filename, characters)</code> </dt> <dd>
<p>Embed the TTF font from the named file into the document.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.endStream">
<code>endStream()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.finalize">
<code>finalize()</code> </dt> <dd>
<p>Write out the various deferred objects and the pdf end matter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.fontName">
<code>fontName(fontprop)</code> </dt> <dd>
<p>Select a font based on fontprop and return a name suitable for Op.selectfont. If fontprop is a string, it will be interpreted as the filename of the font.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.hatchPattern">
<code>hatchPattern(hatch_style)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.imageObject">
<code>imageObject(image)</code> </dt> <dd>
<p>Return name of an image XObject representing the given image.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.markerObject">
<code>markerObject(path, trans, fill, stroke, lw, joinstyle, capstyle)</code> </dt> <dd>
<p>Return name of a marker XObject representing the given path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.newPage">
<code>newPage(width, height)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.newTextnote">
<code>newTextnote(text, positionRect=[-100, -100, 0, 0])</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.output">
<code>output(*data)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject">
<code>pathCollectionObject(gc, path, trans, padding, filled, stroked)</code> </dt> 
</dl> <dl class="staticmethod"> <dt id="matplotlib.backends.backend_pdf.PdfFile.pathOperations">
<code>static pathOperations(path, transform, clip=None, simplify=None, sketch=None)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.recordXref">
<code>recordXref(id)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.reserveObject">
<code>reserveObject(name='')</code> </dt> <dd>
<p>Reserve an ID for an indirect object. The name is used for debugging in case we forget to print out the object with writeObject.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.PdfFile.texFontMap">
<code>texFontMap</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.write">
<code>write(data)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeFonts">
<code>writeFonts()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeGouraudTriangles">
<code>writeGouraudTriangles()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeHatches">
<code>writeHatches()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeImages">
<code>writeImages()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeInfoDict">
<code>writeInfoDict()</code> </dt> <dd>
<p>Write out the info dictionary, checking it for good form</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeMarkers">
<code>writeMarkers()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeObject">
<code>writeObject(object, contents)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writePath">
<code>writePath(path, transform, clip=False, sketch=None)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates">
<code>writePathCollectionTemplates()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeTrailer">
<code>writeTrailer()</code> </dt> <dd>
<p>Write out the PDF trailer.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeXref">
<code>writeXref()</code> </dt> <dd>
<p>Write out the xref table.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.PdfPages">
<code>class matplotlib.backends.backend_pdf.PdfPages(filename, keep_empty=True, metadata=None)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>A multi-page PDF file.</p> <h4 class="rubric">Notes</h4> <p>In reality <a class="reference internal" href="#matplotlib.backends.backend_pdf.PdfPages" title="matplotlib.backends.backend_pdf.PdfPages"><code>PdfPages</code></a> is a thin wrapper around <a class="reference internal" href="#matplotlib.backends.backend_pdf.PdfFile" title="matplotlib.backends.backend_pdf.PdfFile"><code>PdfFile</code></a>, in order to avoid confusion when using <a class="reference internal" href="../_as_gen/matplotlib.pyplot.savefig/#matplotlib.pyplot.savefig" title="matplotlib.pyplot.savefig"><code>savefig()</code></a> and forgetting the format argument.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; # Initialize:
&gt;&gt;&gt; with PdfPages('foo.pdf') as pdf:
...     # As many times as you like, create a figure fig and save it:
...     fig = plt.figure()
...     pdf.savefig(fig)
...     # When no figure is specified the current figure is saved
...     pdf.savefig()
</pre> <p>Create a new PdfPages object.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>filename</strong> : str</p>  <p>Plots using <a class="reference internal" href="#matplotlib.backends.backend_pdf.PdfPages.savefig" title="matplotlib.backends.backend_pdf.PdfPages.savefig"><code>PdfPages.savefig()</code></a> will be written to a file at this location. The file is opened at once and any older file with the same name is overwritten.</p>  <p><strong>keep_empty</strong> : bool, optional</p>  <p>If set to False, then empty pdf files will be deleted automatically when closed.</p>  <p><strong>metadata</strong> : dictionary, optional</p>  <p>Information dictionary object (see PDF reference section 10.2.1 ‘Document Information Dictionary’), e.g.: <code>{'Creator': 'My software', 'Author': 'Me',
'Title': 'Awesome fig'}</code></p> <p>The standard keys are <code>'Title'</code>, <code>'Author'</code>, <code>'Subject'</code>, <code>'Keywords'</code>, <code>'Creator'</code>, <code>'Producer'</code>, <code>'CreationDate'</code>, <code>'ModDate'</code>, and <code>'Trapped'</code>. Values have been predefined for <code>'Creator'</code>, <code>'Producer'</code> and <code>'CreationDate'</code>. They can be removed by setting them to <a class="reference external" href="https://docs.python.org/2/library/constants.html#None" title="(in Python v2.7)" target="_blank"><code>None</code></a>.</p>  </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfPages.attach_note">
<code>attach_note(text, positionRect=[-100, -100, 0, 0])</code> </dt> <dd>
<p>Add a new text note to the page to be saved next. The optional positionRect specifies the position of the new note on the page. It is outside the page per default to make sure it is invisible on printouts.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfPages.close">
<code>close()</code> </dt> <dd>
<p>Finalize this object, making the underlying file a complete PDF file.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfPages.get_pagecount">
<code>get_pagecount()</code> </dt> <dd>
<p>Returns the current number of pages in the multipage pdf file.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfPages.infodict">
<code>infodict()</code> </dt> <dd>
<p>Return a modifiable information dictionary object (see PDF reference section 10.2.1 ‘Document Information Dictionary’).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.PdfPages.keep_empty">
<code>keep_empty</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfPages.savefig">
<code>savefig(figure=None, **kwargs)</code> </dt> <dd>
<p>Saves a <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> to this file as a new page.</p> <p>Any other keyword arguments are passed to <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure.savefig" title="matplotlib.figure.Figure.savefig"><code>savefig()</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>figure</strong> : <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> or int, optional</p>  <p>Specifies what figure is saved to file. If not specified, the active figure is saved. If a <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance is provided, this figure is saved. If an int is specified, the figure instance to save is looked up by number.</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.Reference">
<code>class matplotlib.backends.backend_pdf.Reference(id)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>PDF reference object. Use PdfFile.reserveObject() to create References.</p> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Reference.pdfRepr">
<code>pdfRepr()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Reference.write">
<code>write(contents, file)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.RendererPdf">
<code>class matplotlib.backends.backend_pdf.RendererPdf(file, image_dpi, height, width)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../backend_bases_api/#matplotlib.backend_bases.RendererBase" title="matplotlib.backend_bases.RendererBase"><code>matplotlib.backend_bases.RendererBase</code></a></p> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.afm_font_cache">
<code>afm_font_cache = {}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.check_gc">
<code>check_gc(gc, fillcolor=None)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle">
<code>draw_gouraud_triangle(gc, points, colors, trans)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles">
<code>draw_gouraud_triangles(gc, points, colors, trans)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_image">
<code>draw_image(gc, x, y, im, transform=None)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_markers">
<code>draw_markers(gc, marker_path, marker_trans, path, trans, rgbFace=None)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext">
<code>draw_mathtext(gc, x, y, s, prop, angle)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_path">
<code>draw_path(gc, path, transform, rgbFace=None)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection">
<code>draw_path_collection(gc, master_transform, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_tex">
<code>draw_tex(gc, x, y, s, prop, angle, ismath='TeX!', mtext=None)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_text">
<code>draw_text(gc, x, y, s, prop, angle, ismath=False, mtext=None)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.encode_string">
<code>encode_string(s, fonttype)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.finalize">
<code>finalize()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.flipy">
<code>flipy()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.get_canvas_width_height">
<code>get_canvas_width_height()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.get_image_magnification">
<code>get_image_magnification()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.get_text_width_height_descent">
<code>get_text_width_height_descent(s, prop, ismath)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.merge_used_characters">
<code>merge_used_characters(other)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.new_gc">
<code>new_gc()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.option_image_nocomposite">
<code>option_image_nocomposite()</code> </dt> <dd>
<p>return whether to generate a composite image from multiple images on a set of axes</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.option_scale_image">
<code>option_scale_image()</code> </dt> <dd>
<p>pdf backend support arbitrary scaling of image.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.track_characters">
<code>track_characters(font, s)</code> </dt> <dd>
<p>Keeps track of which characters are required from each font.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.Stream">
<code>class matplotlib.backends.backend_pdf.Stream(id, len, file, extra=None, png=None)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>PDF stream object.</p> <p>This has no pdfRepr method. Instead, call begin(), then output the contents of the stream by calling write(), and finally call end().</p> <p>id: object id of stream; len: an unused Reference object for the length of the stream, or None (to use a memory buffer); file: a PdfFile; extra: a dictionary of extra key-value pairs to include in the stream header; png: if the data is already png compressed, the decode parameters</p> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.compressobj">
<code>compressobj</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Stream.end">
<code>end()</code> </dt> <dd>
<p>Finalize stream.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.extra">
<code>extra</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.file">
<code>file</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.id">
<code>id</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.len">
<code>len</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.pdfFile">
<code>pdfFile</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.pos">
<code>pos</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Stream.write">
<code>write(data)</code> </dt> <dd>
<p>Write some data on the stream.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.Verbatim">
<code>class matplotlib.backends.backend_pdf.Verbatim(x)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Store verbatim PDF command content for later inclusion in the stream.</p> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Verbatim.pdfRepr">
<code>pdfRepr()</code> </dt> 
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backends.backend_pdf.fill">
<code>matplotlib.backends.backend_pdf.fill(strings, linelen=75)</code> </dt> <dd>
<p>Make one string from sequence of strings, with whitespace in between. The whitespace is chosen to form lines of at most linelen characters, if possible.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backends.backend_pdf.pdfRepr">
<code>matplotlib.backends.backend_pdf.pdfRepr(obj)</code> </dt> <dd>
<p>Map Python objects to PDF syntax.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/2.1.0/api/backend_pdf_api.html" class="_attribution-link" target="_blank">http://matplotlib.org/2.1.0/api/backend_pdf_api.html</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
