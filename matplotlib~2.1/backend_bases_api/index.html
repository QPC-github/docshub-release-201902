
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Backend_bases - Matplotlib 2.1 - W3cubDocs</title>
  
  <meta name="description" content=" Abstract base classes define the primitives that renderers and graphics contexts must implement to serve as a matplotlib backend ">
  <meta name="keywords" content="matplotlib, backend, bases, -, matplotlib~2.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~2.1/backend_bases_api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/matplotlib~2.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~2.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 2.1</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
				
<h1 id="matplotlib-backend-bases">matplotlib.backend_bases</h1> <p id="module-matplotlib.backend_bases">Abstract base classes define the primitives that renderers and graphics contexts must implement to serve as a matplotlib backend</p> <dl class="docutils"> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.RendererBase" title="matplotlib.backend_bases.RendererBase"><code>RendererBase</code></a>
</dt> <dd>An abstract base class to handle drawing/rendering operations.</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><code>FigureCanvasBase</code></a>
</dt> <dd>The abstraction layer that separates the <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a> from the backend specific details like a user interface drawing area</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><code>GraphicsContextBase</code></a>
</dt> <dd>An abstract base class that provides color, line styles, etc…</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a>
</dt> <dd>The base class for all of the matplotlib event handling. Derived classes such as <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code>KeyEvent</code></a> and <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> store the meta data like keys and buttons pressed, x and y locations in pixel and <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> coordinates.</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.ShowBase" title="matplotlib.backend_bases.ShowBase"><code>ShowBase</code></a>
</dt> <dd>The base class for the Show class of each interactive backend; the ‘show’ callable is then set to Show.__call__, inherited from ShowBase.</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.ToolContainerBase" title="matplotlib.backend_bases.ToolContainerBase"><code>ToolContainerBase</code></a>
</dt> <dd>The base class for the Toolbar class of each interactive backend.</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.StatusbarBase" title="matplotlib.backend_bases.StatusbarBase"><code>StatusbarBase</code></a>
</dt> <dd>The base class for the messaging area.</dd> </dl> <dl class="class"> <dt id="matplotlib.backend_bases.CloseEvent">
<code>class matplotlib.backend_bases.CloseEvent(name, canvas, guiEvent=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a></p> <p>An event triggered by a figure being closed</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.DrawEvent">
<code>class matplotlib.backend_bases.DrawEvent(name, canvas, renderer)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a></p> <p>An event triggered by a draw operation on the canvas</p> <p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> attributes, the following event attributes are defined:</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>renderer</strong></td> <td>(<a class="reference internal" href="#matplotlib.backend_bases.RendererBase" title="matplotlib.backend_bases.RendererBase"><code>RendererBase</code></a>) the renderer for the draw event</td> </tr>  </table> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.Event">
<code>class matplotlib.backend_bases.Event(name, canvas, guiEvent=None)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>A matplotlib event. Attach additional attributes as defined in <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><code>FigureCanvasBase.mpl_connect()</code></a>. The following attributes are defined and shown with their default values</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>name</strong></td> <td>(str) the event name</td> </tr> <tr>
<td><strong>canvas</strong></td> <td>(<a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><code>FigureCanvasBase</code></a>) the backend-specific canvas instance generating the event</td> </tr> <tr>
<td><strong>guiEvent</strong></td> <td>the GUI event that triggered the matplotlib event</td> </tr>  </table> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.FigureCanvasBase">
<code>class matplotlib.backend_bases.FigureCanvasBase(figure)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>The canvas the figure renders into.</p> <p>Public attributes</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>figure</strong></td> <td>(<a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a>) A high-level figure instance</td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.blit">
<code>blit(bbox=None)</code> </dt> <dd>
<p>Blit the canvas in bbox (default entire canvas).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.button_press_event">
<code>button_press_event(x, y, button, dblclick=False, guiEvent=None)</code> </dt> <dd>
<p>Backend derived classes should call this function on any mouse button press. x,y are the canvas coords: 0,0 is lower, left. button and key are as defined in <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a>.</p> <p>This method will be call all functions connected to the ‘button_press_event’ with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> instance.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.button_release_event">
<code>button_release_event(x, y, button, guiEvent=None)</code> </dt> <dd>
<p>Backend derived classes should call this function on any mouse button release.</p> <p>This method will call all functions connected to the ‘button_release_event’ with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : scalar</p>  <p>the canvas coordinates where 0=left</p>  <p><strong>y</strong> : scalar</p>  <p>the canvas coordinates where 0=bottom</p>  <p><strong>guiEvent</strong></p>  <p>the native UI event that generated the mpl event</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.close_event">
<code>close_event(guiEvent=None)</code> </dt> <dd>
<p>Pass a <a class="reference internal" href="#matplotlib.backend_bases.CloseEvent" title="matplotlib.backend_bases.CloseEvent"><code>CloseEvent</code></a> to all functions connected to <code>close_event</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.draw">
<code>draw(*args, **kwargs)</code> </dt> <dd>
<p>Render the <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.draw_cursor">
<code>draw_cursor(event)</code> </dt> <dd>
<p>Draw a cursor in the event.axes if inaxes is not None. Use native GUI drawing for efficiency if possible</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.draw_event">
<code>draw_event(renderer)</code> </dt> <dd>
<p>Pass a <a class="reference internal" href="#matplotlib.backend_bases.DrawEvent" title="matplotlib.backend_bases.DrawEvent"><code>DrawEvent</code></a> to all functions connected to <code>draw_event</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.draw_idle">
<code>draw_idle(*args, **kwargs)</code> </dt> <dd>
<p><a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.draw" title="matplotlib.backend_bases.FigureCanvasBase.draw"><code>draw()</code></a> only if idle; defaults to draw but backends can override</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.enter_notify_event">
<code>enter_notify_event(guiEvent=None, xy=None)</code> </dt> <dd>
<p>Backend derived classes should call this function when entering canvas</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>guiEvent</strong></p>  <p>the native UI event that generated the mpl event</p>  <p><strong>xy</strong> : tuple of 2 scalars</p>  <p>the coordinate location of the pointer when the canvas is entered</p>  </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.FigureCanvasBase.events">
<code>events = ['resize_event', 'draw_event', 'key_press_event', 'key_release_event', 'button_press_event', 'button_release_event', 'scroll_event', 'motion_notify_event', 'pick_event', 'idle_event', 'figure_enter_event', 'figure_leave_event', 'axes_enter_event', 'axes_leave_event', 'close_event']</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.FigureCanvasBase.filetypes">
<code>filetypes = {'ps': 'Postscript', 'eps': 'Encapsulated Postscript', 'pdf': 'Portable Document Format', 'pgf': 'PGF code for LaTeX', 'png': 'Portable Network Graphics', 'raw': 'Raw RGBA bitmap', 'rgba': 'Raw RGBA bitmap', 'svg': 'Scalable Vector Graphics', 'svgz': 'Scalable Vector Graphics', 'jpg': 'Joint Photographic Experts Group', 'jpeg': 'Joint Photographic Experts Group', 'tif': 'Tagged Image File Format', 'tiff': 'Tagged Image File Format'}</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.FigureCanvasBase.fixed_dpi">
<code>fixed_dpi = None</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.flush_events">
<code>flush_events()</code> </dt> <dd>
<p>Flush the GUI events for the figure.</p> <p>Interactive backends need to reimplement this method.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_default_filename">
<code>get_default_filename()</code> </dt> <dd>
<p>Return a string, which includes extension, suitable for use as a default filename.</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_default_filetype">
<code>classmethod get_default_filetype()</code> </dt> <dd>
<p>Get the default savefig file format as specified in rcParam <code>savefig.format</code>. Returned string excludes period. Overridden in backends that only support a single file type.</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_supported_filetypes">
<code>classmethod get_supported_filetypes()</code> </dt> <dd>
<p>Return dict of savefig file formats supported by this backend</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_supported_filetypes_grouped">
<code>classmethod get_supported_filetypes_grouped()</code> </dt> <dd>
<p>Return a dict of savefig file formats supported by this backend, where the keys are a file type name, such as ‘Joint Photographic Experts Group’, and the values are a list of filename extensions used for that filetype, such as [‘jpg’, ‘jpeg’].</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_width_height">
<code>get_width_height()</code> </dt> <dd>
<p>Return the figure width and height in points or pixels (depending on the backend), truncated to integers</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.get_window_title">
<code>get_window_title()</code> </dt> <dd>
<p>Get the title text of the window containing the figure. Return None if there is no window (e.g., a PS backend).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.grab_mouse">
<code>grab_mouse(ax)</code> </dt> <dd>
<p>Set the child axes which are currently grabbing the mouse events. Usually called by the widgets themselves. It is an error to call this if the mouse is already grabbed by another axes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.idle_event">
<code>idle_event(guiEvent=None)</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified">Deprecated since version 2.1: </span>The idle_event function was deprecated in version 2.1.</p> </div> <p>Called when GUI is idle.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.is_saving">
<code>is_saving()</code> </dt> <dd>
<p>Returns whether the renderer is in the process of saving to a file, rather than rendering for an on-screen buffer.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.key_press_event">
<code>key_press_event(key, guiEvent=None)</code> </dt> <dd>
<p>Pass a <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code>KeyEvent</code></a> to all functions connected to <code>key_press_event</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.key_release_event">
<code>key_release_event(key, guiEvent=None)</code> </dt> <dd>
<p>Pass a <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code>KeyEvent</code></a> to all functions connected to <code>key_release_event</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.leave_notify_event">
<code>leave_notify_event(guiEvent=None)</code> </dt> <dd>
<p>Backend derived classes should call this function when leaving canvas</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>guiEvent</strong></p>  <p>the native UI event that generated the mpl event</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.motion_notify_event">
<code>motion_notify_event(x, y, guiEvent=None)</code> </dt> <dd>
<p>Backend derived classes should call this function on any motion-notify-event.</p> <p>This method will call all functions connected to the ‘motion_notify_event’ with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : scalar</p>  <p>the canvas coordinates where 0=left</p>  <p><strong>y</strong> : scalar</p>  <p>the canvas coordinates where 0=bottom</p>  <p><strong>guiEvent</strong></p>  <p>the native UI event that generated the mpl event</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.mpl_connect">
<code>mpl_connect(s, func)</code> </dt> <dd>
<p>Connect event with string <em>s</em> to <em>func</em>. The signature of <em>func</em> is:</p> <pre data-language="python">def func(event)
</pre> <p>where event is a <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a>. The following events are recognized</p> <ul class="simple"> <li>‘button_press_event’</li> <li>‘button_release_event’</li> <li>‘draw_event’</li> <li>‘key_press_event’</li> <li>‘key_release_event’</li> <li>‘motion_notify_event’</li> <li>‘pick_event’</li> <li>‘resize_event’</li> <li>‘scroll_event’</li> <li>‘figure_enter_event’,</li> <li>‘figure_leave_event’,</li> <li>‘axes_enter_event’,</li> <li>‘axes_leave_event’</li> <li>‘close_event’</li> </ul> <p>For the location events (button and key press/release), if the mouse is over the axes, the variable <code>event.inaxes</code> will be set to the <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> the event occurs is over, and additionally, the variables <code>event.xdata</code> and <code>event.ydata</code> will be defined. This is the mouse location in data coords. See <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code>KeyEvent</code></a> and <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> for more info.</p> <p>Return value is a connection id that can be used with <code>mpl_disconnect()</code>.</p> <h4 class="rubric">Examples</h4> <p>Usage:</p> <pre data-language="python">def on_press(event):
    print('you pressed', event.button, event.xdata, event.ydata)

cid = canvas.mpl_connect('button_press_event', on_press)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.mpl_disconnect">
<code>mpl_disconnect(cid)</code> </dt> <dd>
<p>Disconnect callback id cid</p> <h4 class="rubric">Examples</h4> <p>Usage:</p> <pre data-language="python">cid = canvas.mpl_connect('button_press_event', on_press)
#...later
canvas.mpl_disconnect(cid)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.new_timer">
<code>new_timer(*args, **kwargs)</code> </dt> <dd>
<p>Creates a new backend-specific subclass of <code>backend_bases.Timer</code>. This is useful for getting periodic events through the backend’s native event loop. Implemented only for backends with GUIs.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr>
<td> </td>
<td class="field-body">
<p class="first"><strong>interval</strong> : scalar</p>  <p>Timer interval in milliseconds</p>  <p><strong>callbacks</strong> : list</p>  <p>Sequence of (func, args, kwargs) where <code>func(*args, **kwargs)</code> will be executed by the timer every <em>interval</em>.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.onRemove">
<code>onRemove(ev)</code> </dt> <dd>
<p>Mouse event processor which removes the top artist under the cursor. Connect this to the ‘mouse_press_event’ using:</p> <pre data-language="python">canvas.mpl_connect('mouse_press_event',canvas.onRemove)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.pick">
<code>pick(mouseevent)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.pick_event">
<code>pick_event(mouseevent, artist, **kwargs)</code> </dt> <dd>
<p>This method will be called by artists who are picked and will fire off <a class="reference internal" href="#matplotlib.backend_bases.PickEvent" title="matplotlib.backend_bases.PickEvent"><code>PickEvent</code></a> callbacks registered listeners</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.print_figure">
<code>print_figure(filename, dpi=None, facecolor=None, edgecolor=None, orientation='portrait', format=None, **kwargs)</code> </dt> <dd>
<p>Render the figure to hardcopy. Set the figure patch face and edge colors. This is useful because some of the GUIs have a gray figure face color background and you’ll probably want to override this on hardcopy.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>filename</strong></p>  <p>can also be a file object on image backends</p>  <p><strong>orientation</strong> : {‘landscape’, ‘portrait’}, optional</p>  <p>only currently applies to PostScript printing.</p>  <p><strong>dpi</strong> : scalar, optional</p>  <p>the dots per inch to save the figure in; if None, use savefig.dpi</p>  <p><strong>facecolor</strong> : color spec or None, optional</p>  <p>the facecolor of the figure; if None, defaults to savefig.facecolor</p>  <p><strong>edgecolor</strong> : color spec or None, optional</p>  <p>the edgecolor of the figure; if None, defaults to savefig.edgecolor</p>  <p><strong>format</strong> : str, optional</p>  <p>when set, forcibly set the file format to save to</p>  <p><strong>bbox_inches</strong> : str or <a class="reference internal" href="../transformations/#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>, optional</p>  <p>Bbox in inches. Only the given portion of the figure is saved. If ‘tight’, try to figure out the tight bbox of the figure. If None, use savefig.bbox</p>  <p><strong>pad_inches</strong> : scalar, optional</p>  <p>Amount of padding around the figure when bbox_inches is ‘tight’. If None, use savefig.pad_inches</p>  <p><strong>bbox_extra_artists</strong> : list of <a class="reference internal" href="../artist_api/#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>, optional</p>  <p>A list of extra artists that will be considered when the tight bbox is calculated.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.release_mouse">
<code>release_mouse(ax)</code> </dt> <dd>
<p>Release the mouse grab held by the axes, ax. Usually called by the widgets. It is ok to call this even if you ax doesn’t have the mouse grab currently.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.resize">
<code>resize(w, h)</code> </dt> <dd>
<p>Set the canvas size in pixels.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.resize_event">
<code>resize_event()</code> </dt> <dd>
<p>Pass a <a class="reference internal" href="#matplotlib.backend_bases.ResizeEvent" title="matplotlib.backend_bases.ResizeEvent"><code>ResizeEvent</code></a> to all functions connected to <code>resize_event</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.scroll_event">
<code>scroll_event(x, y, step, guiEvent=None)</code> </dt> <dd>
<p>Backend derived classes should call this function on any scroll wheel event. x,y are the canvas coords: 0,0 is lower, left. button and key are as defined in MouseEvent.</p> <p>This method will be call all functions connected to the ‘scroll_event’ with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a> instance.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.set_window_title">
<code>set_window_title(title)</code> </dt> <dd>
<p>Set the title text of the window containing the figure. Note that this has no effect if there is no window (e.g., a PS backend).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.start_event_loop">
<code>start_event_loop(timeout=0)</code> </dt> <dd>
<p>Start a blocking event loop.</p> <p>Such an event loop is used by interactive functions, such as <code>ginput</code> and <code>waitforbuttonpress</code>, to wait for events.</p> <p>The event loop blocks until a callback function triggers <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.stop_event_loop" title="matplotlib.backend_bases.FigureCanvasBase.stop_event_loop"><code>stop_event_loop</code></a>, or <em>timeout</em> is reached.</p> <p>If <em>timeout</em> is negative, never timeout.</p> <p>Only interactive backends need to reimplement this method and it relies on <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.flush_events" title="matplotlib.backend_bases.FigureCanvasBase.flush_events"><code>flush_events</code></a> being properly implemented.</p> <p>Interactive backends should implement this in a more native way.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.start_event_loop_default">
<code>start_event_loop_default(timeout=0)</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified">Deprecated since version 2.1: </span>The start_event_loop_default function was deprecated in version 2.1.</p> </div> <p>Start a blocking event loop.</p>  <p>Such an event loop is used by interactive functions, such as <code>ginput</code> and <code>waitforbuttonpress</code>, to wait for events.</p> <p>The event loop blocks until a callback function triggers <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.stop_event_loop" title="matplotlib.backend_bases.FigureCanvasBase.stop_event_loop"><code>stop_event_loop</code></a>, or <em>timeout</em> is reached.</p> <p>If <em>timeout</em> is negative, never timeout.</p> <p>Only interactive backends need to reimplement this method and it relies on <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.flush_events" title="matplotlib.backend_bases.FigureCanvasBase.flush_events"><code>flush_events</code></a> being properly implemented.</p> <p>Interactive backends should implement this in a more native way.</p>  </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.stop_event_loop">
<code>stop_event_loop()</code> </dt> <dd>
<p>Stop the current blocking event loop.</p> <p>Interactive backends need to reimplement this to match <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.start_event_loop" title="matplotlib.backend_bases.FigureCanvasBase.start_event_loop"><code>start_event_loop</code></a></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.stop_event_loop_default">
<code>stop_event_loop_default()</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified">Deprecated since version 2.1: </span>The stop_event_loop_default function was deprecated in version 2.1.</p> </div> <p>Stop the current blocking event loop.</p>  Interactive backends need to reimplement this to match <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.start_event_loop" title="matplotlib.backend_bases.FigureCanvasBase.start_event_loop"><code>start_event_loop</code></a> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.FigureCanvasBase.supports_blit">
<code>supports_blit = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureCanvasBase.switch_backends">
<code>switch_backends(FigureCanvasClass)</code> </dt> <dd>
<p>Instantiate an instance of FigureCanvasClass</p> <p>This is used for backend switching, e.g., to instantiate a FigureCanvasPS from a FigureCanvasGTK. Note, deep copying is not done, so any changes to one of the instances (e.g., setting figure size or line props), will be reflected in the other</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.FigureManagerBase">
<code>class matplotlib.backend_bases.FigureManagerBase(canvas, num)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Helper class for pyplot mode, wraps everything up into a neat bundle</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>canvas</strong></td> <td>(<a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><code>FigureCanvasBase</code></a>) The backend-specific canvas instance</td> </tr> <tr>
<td><strong>num</strong></td> <td>(int or str) The figure number</td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.destroy">
<code>destroy()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.full_screen_toggle">
<code>full_screen_toggle()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.get_window_title">
<code>get_window_title()</code> </dt> <dd>
<p>Get the title text of the window containing the figure.</p> <p>Return None for non-GUI (e.g., PS) backends.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.key_press">
<code>key_press(event)</code> </dt> <dd>
<p>Implement the default mpl key bindings defined at <a class="reference internal" href="http://matplotlib.org/2.1.0/users/navigation_toolbar.html#key-event-handling" target="_blank"><span class="std std-ref">Navigation Keyboard Shortcuts</span></a></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.FigureManagerBase.key_press_handler_id">
<code>key_press_handler_id = None</code> </dt> <dd>
<p>The returned id from connecting the default key handler via <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><code>FigureCanvasBase.mpl_connect()</code></a>.</p> <p>To disable default key press handling:</p> <pre data-language="python">manager, canvas = figure.canvas.manager, figure.canvas
canvas.mpl_disconnect(manager.key_press_handler_id)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.resize">
<code>resize(w, h)</code> </dt> <dd>
<p>“For GUI backends, resize the window (in pixels).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.set_window_title">
<code>set_window_title(title)</code> </dt> <dd>
<p>Set the title text of the window containing the figure.</p> <p>This has no effect for non-GUI (e.g., PS) backends.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.show">
<code>show()</code> </dt> <dd>
<p>For GUI backends, show the figure window and redraw. For non-GUI backends, raise an exception to be caught by <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure.show" title="matplotlib.figure.Figure.show"><code>show()</code></a>, for an optional warning.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.FigureManagerBase.show_popup">
<code>show_popup(msg)</code> </dt> <dd>
<p>Display message in a popup – GUI only.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.GraphicsContextBase">
<code>class matplotlib.backend_bases.GraphicsContextBase</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>An abstract base class that provides color, line styles, etc…</p> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.copy_properties">
<code>copy_properties(gc)</code> </dt> <dd>
<p>Copy properties from gc to self</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_alpha">
<code>get_alpha()</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_antialiased">
<code>get_antialiased()</code> </dt> <dd>
<p>Return true if the object should try to do antialiased rendering</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_capstyle">
<code>get_capstyle()</code> </dt> <dd>
<p>Return the capstyle as a string in (‘butt’, ‘round’, ‘projecting’)</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_clip_path">
<code>get_clip_path()</code> </dt> <dd>
<p>Return the clip path in the form (path, transform), where path is a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance, and transform is an affine transform to apply to the path before clipping.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_clip_rectangle">
<code>get_clip_rectangle()</code> </dt> <dd>
<p>Return the clip rectangle as a <a class="reference internal" href="../transformations/#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> instance</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_dashes">
<code>get_dashes()</code> </dt> <dd>
<p>Return the dash information as an offset dashlist tuple.</p> <p>The dash list is a even size list that gives the ink on, ink off in pixels.</p> <p>See p107 of to PostScript <a class="reference external" href="https://www-cdf.fnal.gov/offline/PostScript/BLUEBOOK.PDF" target="_blank">BLUEBOOK</a> for more info.</p> <p>Default value is None</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_forced_alpha">
<code>get_forced_alpha()</code> </dt> <dd>
<p>Return whether the value given by get_alpha() should be used to override any other alpha-channel values.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_gid">
<code>get_gid()</code> </dt> <dd>
<p>Return the object identifier if one is set, None otherwise.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_hatch">
<code>get_hatch()</code> </dt> <dd>
<p>Gets the current hatch style</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_hatch_color">
<code>get_hatch_color()</code> </dt> <dd>
<p>Gets the color to use for hatching.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_hatch_linewidth">
<code>get_hatch_linewidth()</code> </dt> <dd>
<p>Gets the linewidth to use for hatching.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_hatch_path">
<code>get_hatch_path(density=6.0)</code> </dt> <dd>
<p>Returns a Path for the current hatch.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_joinstyle">
<code>get_joinstyle()</code> </dt> <dd>
<p>Return the line join style as one of (‘miter’, ‘round’, ‘bevel’)</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_linestyle">
<code>get_linestyle()</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified">Deprecated since version 2.1: </span>The get_linestyle function was deprecated in version 2.1.</p> </div> <p>Return the linestyle: one of (‘solid’, ‘dashed’, ‘dashdot’, ‘dotted’).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_linewidth">
<code>get_linewidth()</code> </dt> <dd>
<p>Return the line width in points as a scalar</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_rgb">
<code>get_rgb()</code> </dt> <dd>
<p>returns a tuple of three or four floats from 0-1.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_sketch_params">
<code>get_sketch_params()</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>sketch_params</strong> : tuple or <a class="reference external" href="https://docs.python.org/2/library/constants.html#None" title="(in Python v2.7)" target="_blank"><code>None</code></a></p> <p>A 3-tuple with the following elements:</p>  <ul class="simple"> <li>
<code>scale</code>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<code>length</code>: The length of the wiggle along the line.</li> <li>
<code>randomness</code>: The scale factor by which the length is shrunken or expanded.</li> </ul>  <p class="last">May return <a class="reference external" href="https://docs.python.org/2/library/constants.html#None" title="(in Python v2.7)" target="_blank"><code>None</code></a> if no sketch parameters were set.</p> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_snap">
<code>get_snap()</code> </dt> <dd>
<p>returns the snap setting which may be:</p>  <ul class="simple"> <li>True: snap vertices to the nearest pixel center</li> <li>False: leave vertices as-is</li> <li>None: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center</li> </ul>  </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.get_url">
<code>get_url()</code> </dt> <dd>
<p>returns a url if one is set, None otherwise</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.restore">
<code>restore()</code> </dt> <dd>
<p>Restore the graphics context from the stack - needed only for backends that save graphics contexts on a stack</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_alpha">
<code>set_alpha(alpha)</code> </dt> <dd>
<p>Set the alpha value used for blending - not supported on all backends. If <code>alpha=None</code> (the default), the alpha components of the foreground and fill colors will be used to set their respective transparencies (where applicable); otherwise, <code>alpha</code> will override them.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_antialiased">
<code>set_antialiased(b)</code> </dt> <dd>
<p>True if object should be drawn with antialiased rendering</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_capstyle">
<code>set_capstyle(cs)</code> </dt> <dd>
<p>Set the capstyle as a string in (‘butt’, ‘round’, ‘projecting’)</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_clip_path">
<code>set_clip_path(path)</code> </dt> <dd>
<p>Set the clip path and transformation. Path should be a <a class="reference internal" href="../transformations/#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>TransformedPath</code></a> instance.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_clip_rectangle">
<code>set_clip_rectangle(rectangle)</code> </dt> <dd>
<p>Set the clip rectangle with sequence (left, bottom, width, height)</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_dashes">
<code>set_dashes(dash_offset, dash_list)</code> </dt> <dd>
<p>Set the dash style for the gc.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>dash_offset</strong> : float</p>  <p>is the offset (usually 0).</p>  <p><strong>dash_list</strong> : array_like</p>  <p>specifies the on-off sequence as points. <code>(None, None)</code> specifies a solid line</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_foreground">
<code>set_foreground(fg, isRGBA=False)</code> </dt> <dd>
<p>Set the foreground color. fg can be a MATLAB format string, a html hex color string, an rgb or rgba unit tuple, or a float between 0 and 1. In the latter case, grayscale is used.</p> <p>If you know fg is rgba, set <code>isRGBA=True</code> for efficiency.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_gid">
<code>set_gid(id)</code> </dt> <dd>
<p>Sets the id.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_hatch">
<code>set_hatch(hatch)</code> </dt> <dd>
<p>Sets the hatch style for filling</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_hatch_color">
<code>set_hatch_color(hatch_color)</code> </dt> <dd>
<p>sets the color to use for hatching.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_joinstyle">
<code>set_joinstyle(js)</code> </dt> <dd>
<p>Set the join style to be one of (‘miter’, ‘round’, ‘bevel’)</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_linestyle">
<code>set_linestyle(style)</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified">Deprecated since version 2.1: </span>The set_linestyle function was deprecated in version 2.1.</p> </div> <p>Set the linestyle to be one of (‘solid’, ‘dashed’, ‘dashdot’, ‘dotted’). These are defined in the rcParams <code>lines.dashed_pattern</code>, <code>lines.dashdot_pattern</code> and <code>lines.dotted_pattern</code>. One may also specify customized dash styles by providing a tuple of (offset, dash pairs).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_linewidth">
<code>set_linewidth(w)</code> </dt> <dd>
<p>Set the linewidth in points</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_sketch_params">
<code>set_sketch_params(scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>scale</strong> : float, optional</p>  <p>The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <a class="reference external" href="https://docs.python.org/2/library/constants.html#None" title="(in Python v2.7)" target="_blank"><code>None</code></a>, or not provided, no sketch filter will be provided.</p>  <p><strong>length</strong> : float, optional</p>  <p>The length of the wiggle along the line, in pixels (default 128)</p>  <p><strong>randomness</strong> : float, optional</p>  <p>The scale factor by which the length is shrunken or expanded (default 16)</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_snap">
<code>set_snap(snap)</code> </dt> <dd>
<p>Sets the snap setting which may be:</p>  <ul class="simple"> <li>True: snap vertices to the nearest pixel center</li> <li>False: leave vertices as-is</li> <li>None: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center</li> </ul>  </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.GraphicsContextBase.set_url">
<code>set_url(url)</code> </dt> <dd>
<p>Sets the url for links in compatible backends</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.IdleEvent">
<code>class matplotlib.backend_bases.IdleEvent(*args, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a></p> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 2.1: </span>The IdleEvent class was deprecated in version 2.1.</p> </div> <p>An event triggered by the GUI backend when it is idle – useful for passive animation</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.KeyEvent">
<code>class matplotlib.backend_bases.KeyEvent(name, canvas, key, x=0, y=0, guiEvent=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code>matplotlib.backend_bases.LocationEvent</code></a></p> <p>A key event (key press, key release).</p> <p>Attach additional attributes as defined in <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><code>FigureCanvasBase.mpl_connect()</code></a>.</p> <p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> and <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code>LocationEvent</code></a> attributes, the following attributes are defined:</p> <h4 class="rubric">Notes</h4> <p>Modifier keys will be prefixed to the pressed key and will be in the order “ctrl”, “alt”, “super”. The exception to this rule is when the pressed key is itself a modifier key, therefore “ctrl+alt” and “alt+control” can both be valid key values.</p> <h4 class="rubric">Examples</h4> <p>Usage:</p> <pre data-language="python">def on_key(event):
    print('you pressed', event.key, event.xdata, event.ydata)

cid = fig.canvas.mpl_connect('key_press_event', on_key)
</pre> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>key</strong></td> <td>(None or str) the key(s) pressed. Could be <strong>None</strong>, a single case sensitive ascii character (“g”, “G”, “#”, etc.), a special key (“control”, “shift”, “f1”, “up”, etc.) or a combination of the above (e.g., “ctrl+alt+g”, “ctrl+alt+G”).</td> </tr>  </table> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.LocationEvent">
<code>class matplotlib.backend_bases.LocationEvent(name, canvas, x, y, guiEvent=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a></p> <p>An event that has a screen location</p> <p>The following additional attributes are defined and shown with their default values.</p> <p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> attributes, the following event attributes are defined:</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>x</strong></td> <td>(scalar) x position - pixels from left of canvas</td> </tr> <tr>
<td><strong>y</strong></td> <td>(scalar) y position - pixels from bottom of canvas</td> </tr> <tr>
<td><strong>inaxes</strong></td> <td>(bool) the <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance if mouse is over axes</td> </tr> <tr>
<td><strong>xdata</strong></td> <td>(scalar) x coord of mouse in data coords</td> </tr> <tr>
<td><strong>ydata</strong></td> <td>(scalar) y coord of mouse in data coords</td> </tr>  </table> <p><em>x</em>, <em>y</em> in figure coords, 0,0 = bottom, left</p> <dl class="attribute"> <dt id="matplotlib.backend_bases.LocationEvent.inaxes">
<code>inaxes = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.LocationEvent.lastevent">
<code>lastevent = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.LocationEvent.x">
<code>x = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.LocationEvent.xdata">
<code>xdata = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.LocationEvent.y">
<code>y = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.LocationEvent.ydata">
<code>ydata = None</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.MouseEvent">
<code>class matplotlib.backend_bases.MouseEvent(name, canvas, x, y, button=None, key=None, step=0, dblclick=False, guiEvent=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code>matplotlib.backend_bases.LocationEvent</code></a></p> <dl class="docutils"> <dt>A mouse event (‘button_press_event’,</dt> <dd>‘button_release_event’, ‘scroll_event’, ‘motion_notify_event’).</dd> </dl> <p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> and <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code>LocationEvent</code></a> attributes, the following attributes are defined:</p> <h4 class="rubric">Examples</h4> <p>Usage:</p> <pre data-language="python">def on_press(event):
    print('you pressed', event.button, event.xdata, event.ydata)

cid = fig.canvas.mpl_connect('button_press_event', on_press)
</pre> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>button</strong></td> <td>(None, scalar, or str) button pressed None, 1, 2, 3, ‘up’, ‘down’ (up and down are used for scroll events). Note that in the nbagg backend, both the middle and right clicks return 3 since right clicking will bring up the context menu in some browsers.</td> </tr> <tr>
<td><strong>key</strong></td> <td>(None, or str) the key depressed when the mouse event triggered (see <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code>KeyEvent</code></a>)</td> </tr> <tr>
<td><strong>step</strong></td> <td>(scalar) number of scroll steps (positive for ‘up’, negative for ‘down’)</td> </tr>  </table> <p>x, y in figure coords, 0,0 = bottom, left button pressed None, 1, 2, 3, ‘up’, ‘down’</p> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseEvent.button">
<code>button = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseEvent.dblclick">
<code>dblclick = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseEvent.inaxes">
<code>inaxes = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseEvent.step">
<code>step = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseEvent.x">
<code>x = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseEvent.xdata">
<code>xdata = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseEvent.y">
<code>y = None</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.MouseEvent.ydata">
<code>ydata = None</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.NavigationToolbar2">
<code>class matplotlib.backend_bases.NavigationToolbar2(canvas)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Base class for the navigation cursor, version 2</p> <p>backends must implement a canvas that handles connections for ‘button_press_event’ and ‘button_release_event’. See <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><code>FigureCanvasBase.mpl_connect()</code></a> for more information</p> <p>They must also define</p>  <dl class="docutils"> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.save_figure" title="matplotlib.backend_bases.NavigationToolbar2.save_figure"><code>save_figure()</code></a>
</dt> <dd>save the current figure</dd> <dt>
 <a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.set_cursor" title="matplotlib.backend_bases.NavigationToolbar2.set_cursor"><code>set_cursor()</code></a>
</dt> <dd>if you want the pointer icon to change</dd> <dt>
<code>_init_toolbar()</code> </dt> <dd>create your toolbar widget</dd> <dt>
<code>draw_rubberband() (optional)</code> </dt> <dd>draw the zoom to rect “rubberband” rectangle</dd> <dt>
<code>press() (optional)</code> </dt> <dd>whenever a mouse button is pressed, you’ll be notified with the event</dd> <dt>
<code>release() (optional)</code> </dt> <dd>whenever a mouse button is released, you’ll be notified with the event</dd> <dt>
<code>set_message() (optional)</code> </dt> <dd>display message</dd> <dt>
<code>set_history_buttons() (optional)</code> </dt> <dd>you can change the history back / forward buttons to indicate disabled / enabled state.</dd> </dl>  <p>That’s it, we’ll do the rest!</p> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.back">
<code>back(*args)</code> </dt> <dd>
<p>move back up the view lim stack</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.drag_pan">
<code>drag_pan(event)</code> </dt> <dd>
<p>Callback for dragging in pan/zoom mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.drag_zoom">
<code>drag_zoom(event)</code> </dt> <dd>
<p>Callback for dragging in zoom mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.draw">
<code>draw()</code> </dt> <dd>
<p>Redraw the canvases, update the locators.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.draw_rubberband">
<code>draw_rubberband(event, x0, y0, x1, y1)</code> </dt> <dd>
<p>Draw a rectangle rubberband to indicate zoom limits.</p> <p>Note that it is not guaranteed that <code>x0 &lt;= x1</code> and <code>y0 &lt;= y1</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.dynamic_update">
<code>dynamic_update()</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified">Deprecated since version 2.1: </span>The dynamic_update function was deprecated in version 2.1. Use canvas.draw_idle instead.</p> </div>  </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.forward">
<code>forward(*args)</code> </dt> <dd>
<p>Move forward in the view lim stack.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.home">
<code>home(*args)</code> </dt> <dd>
<p>Restore the original view.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.mouse_move">
<code>mouse_move(event)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.pan">
<code>pan(*args)</code> </dt> <dd>
<p>Activate the pan/zoom tool. pan with left button, zoom with right</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.press">
<code>press(event)</code> </dt> <dd>
<p>Called whenver a mouse button is pressed.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.press_pan">
<code>press_pan(event)</code> </dt> <dd>
<p>Callback for mouse button press in pan/zoom mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.press_zoom">
<code>press_zoom(event)</code> </dt> <dd>
<p>Callback for mouse button press in zoom to rect mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.push_current">
<code>push_current()</code> </dt> <dd>
<p>Push the current view limits and position onto the stack.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.release">
<code>release(event)</code> </dt> <dd>
<p>Callback for mouse button release.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.release_pan">
<code>release_pan(event)</code> </dt> <dd>
<p>Callback for mouse button release in pan/zoom mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.release_zoom">
<code>release_zoom(event)</code> </dt> <dd>
<p>Callback for mouse button release in zoom to rect mode.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.remove_rubberband">
<code>remove_rubberband()</code> </dt> <dd>
<p>Remove the rubberband.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.save_figure">
<code>save_figure(*args)</code> </dt> <dd>
<p>Save the current figure.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.set_cursor">
<code>set_cursor(cursor)</code> </dt> <dd>
<p>Set the current cursor to one of the <code>Cursors</code> enums values.</p> <p>If required by the backend, this method should trigger an update in the backend event loop after the cursor is set, as this method may be called e.g. before a long-running task during which the GUI is not updated.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.set_history_buttons">
<code>set_history_buttons()</code> </dt> <dd>
<p>Enable or disable the back/forward button.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.set_message">
<code>set_message(s)</code> </dt> <dd>
<p>Display a message on toolbar or in status bar.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.NavigationToolbar2.toolitems">
<code>toolitems = (('Home', 'Reset original view', 'home', 'home'), ('Back', 'Back to previous view', 'back', 'back'), ('Forward', 'Forward to next view', 'forward', 'forward'), (None, None, None, None), ('Pan', 'Pan axes with left mouse, zoom with right', 'move', 'pan'), ('Zoom', 'Zoom to rectangle', 'zoom_to_rect', 'zoom'), ('Subplots', 'Configure subplots', 'subplots', 'configure_subplots'), (None, None, None, None), ('Save', 'Save the figure', 'filesave', 'save_figure'))</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.update">
<code>update()</code> </dt> <dd>
<p>Reset the axes stack.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.NavigationToolbar2.zoom">
<code>zoom(*args)</code> </dt> <dd>
<p>Activate zoom to rect mode.</p> </dd>
</dl> </dd>
</dl> <dl class="exception"> <dt id="matplotlib.backend_bases.NonGuiException">
<code>exception matplotlib.backend_bases.NonGuiException</code> </dt> <dd>
<p>Bases: <code>Exception</code></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.PickEvent">
<code>class matplotlib.backend_bases.PickEvent(name, canvas, mouseevent, artist, guiEvent=None, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a></p> <p>a pick event, fired when the user picks a location on the canvas sufficiently close to an artist.</p> <p>Attrs: all the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> attributes plus</p> <h4 class="rubric">Examples</h4> <p>Usage:</p> <pre data-language="python">ax.plot(np.rand(100), 'o', picker=5)  # 5 points tolerance

def on_pick(event):
    line = event.artist
    xdata, ydata = line.get_data()
    ind = event.ind
    print('on pick line:', np.array([xdata[ind], ydata[ind]]).T)

cid = fig.canvas.mpl_connect('pick_event', on_pick)
</pre> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>mouseevent</strong></td> <td>(<a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code>MouseEvent</code></a>) the mouse event that generated the pick</td> </tr> <tr>
<td><strong>artist</strong></td> <td>(<a class="reference internal" href="../artist_api/#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>matplotlib.artist.Artist</code></a>) the picked artist</td> </tr> <tr>
<td><strong>other</strong></td> <td>extra class dependent attrs – e.g., a <a class="reference internal" href="../_as_gen/matplotlib.lines.line2d/#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a> pick may define different extra attributes than a <a class="reference internal" href="../collections_api/#matplotlib.collections.PatchCollection" title="matplotlib.collections.PatchCollection"><code>PatchCollection</code></a> pick event</td> </tr>  </table> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.RendererBase">
<code>class matplotlib.backend_bases.RendererBase</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>An abstract base class to handle drawing/rendering operations.</p> <p>The following methods must be implemented in the backend for full functionality (though just implementing <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path" title="matplotlib.backend_bases.RendererBase.draw_path"><code>draw_path()</code></a> alone would give a highly capable backend):</p> <ul class="simple"> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path" title="matplotlib.backend_bases.RendererBase.draw_path"><code>draw_path()</code></a></li> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_image" title="matplotlib.backend_bases.RendererBase.draw_image"><code>draw_image()</code></a></li> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_gouraud_triangle" title="matplotlib.backend_bases.RendererBase.draw_gouraud_triangle"><code>draw_gouraud_triangle()</code></a></li> </ul> <p>The following methods <em>should</em> be implemented in the backend for optimization reasons:</p> <ul class="simple"> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_text" title="matplotlib.backend_bases.RendererBase.draw_text"><code>draw_text()</code></a></li> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_markers" title="matplotlib.backend_bases.RendererBase.draw_markers"><code>draw_markers()</code></a></li> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><code>draw_path_collection()</code></a></li> <li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_quad_mesh" title="matplotlib.backend_bases.RendererBase.draw_quad_mesh"><code>draw_quad_mesh()</code></a></li> </ul> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.close_group">
<code>close_group(s)</code> </dt> <dd>
<p>Close a grouping element with label <em>s</em> Is only currently used by <a class="reference internal" href="../backend_svg_api/#module-matplotlib.backends.backend_svg" title="matplotlib.backends.backend_svg"><code>backend_svg</code></a></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_gouraud_triangle">
<code>draw_gouraud_triangle(gc, points, colors, transform)</code> </dt> <dd>
<p>Draw a Gouraud-shaded triangle.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>points</strong> : array_like, shape=(3, 2)</p>  <p>Array of (x, y) points for the triangle.</p>  <p><strong>colors</strong> : array_like, shape=(3, 4)</p>  <p>RGBA colors for each point of the triangle.</p>  <p><strong>transform</strong> : <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p>  <p>An affine transform to apply to the points.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_gouraud_triangles">
<code>draw_gouraud_triangles(gc, triangles_array, colors_array, transform)</code> </dt> <dd>
<p>Draws a series of Gouraud triangles.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>points</strong> : array_like, shape=(N, 3, 2)</p>  <p>Array of <em>N</em> (x, y) points for the triangles.</p>  <p><strong>colors</strong> : array_like, shape=(N, 3, 4)</p>  <p>Array of <em>N</em> RGBA colors for each point of the triangles.</p>  <p><strong>transform</strong> : <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p>  <p>An affine transform to apply to the points.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_image">
<code>draw_image(gc, x, y, im, transform=None)</code> </dt> <dd>
<p>Draw an RGBA image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>gc</strong> : <a class="reference internal" href="#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><code>GraphicsContextBase</code></a></p>  <p>a graphics context with clipping information.</p>  <p><strong>x</strong> : scalar</p>  <p>the distance in physical units (i.e., dots or pixels) from the left hand side of the canvas.</p>  <p><strong>y</strong> : scalar</p>  <p>the distance in physical units (i.e., dots or pixels) from the bottom side of the canvas.</p>  <p><strong>im</strong> : array_like, shape=(N, M, 4), dtype=np.uint8</p>  <p>An array of RGBA pixels.</p>  <p><strong>transform</strong> : <a class="reference internal" href="../transformations/#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p>  <p>If and only if the concrete backend is written such that <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.option_scale_image" title="matplotlib.backend_bases.RendererBase.option_scale_image"><code>option_scale_image()</code></a> returns <code>True</code>, an affine transformation <em>may</em> be passed to <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_image" title="matplotlib.backend_bases.RendererBase.draw_image"><code>draw_image()</code></a>. It takes the form of a <a class="reference internal" href="../transformations/#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a> instance. The translation vector of the transformation is given in physical units (i.e., dots or pixels). Note that the transformation does not override <code>x</code> and <code>y</code>, and has to be applied <em>before</em> translating the result by <code>x</code> and <code>y</code> (this can be accomplished by adding <code>x</code> and <code>y</code> to the translation vector defined by <code>transform</code>).</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_markers">
<code>draw_markers(gc, marker_path, marker_trans, path, trans, rgbFace=None)</code> </dt> <dd>
<p>Draws a marker at each of the vertices in path. This includes all vertices, including control points on curves. To avoid that behavior, those vertices should be removed before calling this function.</p> <p>This provides a fallback implementation of draw_markers that makes multiple calls to <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path" title="matplotlib.backend_bases.RendererBase.draw_path"><code>draw_path()</code></a>. Some backends may want to override this method in order to draw the marker only once and reuse it multiple times.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>gc</strong> : <a class="reference internal" href="#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><code>GraphicsContextBase</code></a></p>  <p>The graphics context</p>  <p><strong>marker_trans</strong> : <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p>  <p>An affine transform applied to the marker.</p>  <p><strong>trans</strong> : <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p>  <p>An affine transform applied to the path.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_path">
<code>draw_path(gc, path, transform, rgbFace=None)</code> </dt> <dd>
<p>Draws a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance using the given affine transform.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_path_collection">
<code>draw_path_collection(gc, master_transform, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position)</code> </dt> <dd>
<p>Draws a collection of paths selecting drawing properties from the lists <em>facecolors</em>, <em>edgecolors</em>, <em>linewidths</em>, <em>linestyles</em> and <em>antialiaseds</em>. <em>offsets</em> is a list of offsets to apply to each of the paths. The offsets in <em>offsets</em> are first transformed by <em>offsetTrans</em> before being applied. <em>offset_position</em> may be either “screen” or “data” depending on the space that the offsets are in.</p> <p>This provides a fallback implementation of <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><code>draw_path_collection()</code></a> that makes multiple calls to <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path" title="matplotlib.backend_bases.RendererBase.draw_path"><code>draw_path()</code></a>. Some backends may want to override this in order to render each set of path data only once, and then reference that path multiple times with the different offsets, colors, styles etc. The generator methods <code>_iter_collection_raw_paths()</code> and <code>_iter_collection()</code> are provided to help with (and standardize) the implementation across backends. It is highly recommended to use those generators, so that changes to the behavior of <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><code>draw_path_collection()</code></a> can be made globally.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_quad_mesh">
<code>draw_quad_mesh(gc, master_transform, meshWidth, meshHeight, coordinates, offsets, offsetTrans, facecolors, antialiased, edgecolors)</code> </dt> <dd>
<p>This provides a fallback implementation of <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_quad_mesh" title="matplotlib.backend_bases.RendererBase.draw_quad_mesh"><code>draw_quad_mesh()</code></a> that generates paths and then calls <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><code>draw_path_collection()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_tex">
<code>draw_tex(gc, x, y, s, prop, angle, ismath='TeX!', mtext=None)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.draw_text">
<code>draw_text(gc, x, y, s, prop, angle, ismath=False, mtext=None)</code> </dt> <dd>
<p>Draw the text instance</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>gc</strong> : <a class="reference internal" href="#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><code>GraphicsContextBase</code></a></p>  <p>the graphics context</p>  <p><strong>x</strong> : scalar</p>  <p>the x location of the text in display coords</p>  <p><strong>y</strong> : scalar</p>  <p>the y location of the text baseline in display coords</p>  <p><strong>s</strong> : str</p>  <p>the text string</p>  <p><strong>prop</strong> : <a class="reference internal" href="../font_manager_api/#matplotlib.font_manager.FontProperties" title="matplotlib.font_manager.FontProperties"><code>matplotlib.font_manager.FontProperties</code></a></p>  <p>font properties</p>  <p><strong>angle</strong> : scalar</p>  <p>the rotation angle in degrees</p>  <p><strong>mtext</strong> : <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>matplotlib.text.Text</code></a></p>  <p>the original text object to be rendered</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p><strong>backend implementers note</strong></p> <p>When you are trying to determine if you have gotten your bounding box right (which is what enables the text layout/alignment to work properly), it helps to change the line in text.py:</p> <pre data-language="python">if 0: bbox_artist(self, renderer)
</pre> <p>to if 1, and then the actual bounding box will be plotted along with your text.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.flipy">
<code>flipy()</code> </dt> <dd>
<p>Return true if y small numbers are top for renderer Is used for drawing text (<a class="reference internal" href="../text_api/#module-matplotlib.text" title="matplotlib.text"><code>matplotlib.text</code></a>) and images (<a class="reference internal" href="../image_api/#module-matplotlib.image" title="matplotlib.image"><code>matplotlib.image</code></a>) only</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.get_canvas_width_height">
<code>get_canvas_width_height()</code> </dt> <dd>
<p>return the canvas width and height in display coords</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.get_image_magnification">
<code>get_image_magnification()</code> </dt> <dd>
<p>Get the factor by which to magnify images passed to <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_image" title="matplotlib.backend_bases.RendererBase.draw_image"><code>draw_image()</code></a>. Allows a backend to have images at a different resolution to other artists.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.get_texmanager">
<code>get_texmanager()</code> </dt> <dd>
<p>return the <code>matplotlib.texmanager.TexManager</code> instance</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.get_text_width_height_descent">
<code>get_text_width_height_descent(s, prop, ismath)</code> </dt> <dd>
<p>Get the width, height, and descent (offset from the bottom to the baseline), in display coords, of the string <em>s</em> with <a class="reference internal" href="../font_manager_api/#matplotlib.font_manager.FontProperties" title="matplotlib.font_manager.FontProperties"><code>FontProperties</code></a> <em>prop</em></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.new_gc">
<code>new_gc()</code> </dt> <dd>
<p>Return an instance of a <a class="reference internal" href="#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><code>GraphicsContextBase</code></a></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.open_group">
<code>open_group(s, gid=None)</code> </dt> <dd>
<p>Open a grouping element with label <em>s</em>. If <em>gid</em> is given, use <em>gid</em> as the id of the group. Is only currently used by <a class="reference internal" href="../backend_svg_api/#module-matplotlib.backends.backend_svg" title="matplotlib.backends.backend_svg"><code>backend_svg</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.option_image_nocomposite">
<code>option_image_nocomposite()</code> </dt> <dd>
<p>override this method for renderers that do not necessarily always want to rescale and composite raster images. (like SVG, PDF, or PS)</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.option_scale_image">
<code>option_scale_image()</code> </dt> <dd>
<p>override this method for renderers that support arbitrary affine transformations in <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_image" title="matplotlib.backend_bases.RendererBase.draw_image"><code>draw_image()</code></a> (most vector backends).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.points_to_pixels">
<code>points_to_pixels(points)</code> </dt> <dd>
<p>Convert points to display units</p> <p>You need to override this function (unless your backend doesn’t have a dpi, e.g., postscript or svg). Some imaging systems assume some value for pixels per inch:</p> <pre data-language="python">points to pixels = points * pixels_per_inch/72.0 * dpi/72.0
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>points</strong> : scalar or array_like</p>  <p>a float or a numpy array of float</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last">Points converted to pixels</p> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.start_filter">
<code>start_filter()</code> </dt> <dd>
<p>Used in AggRenderer. Switch to a temporary renderer for image filtering effects.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.start_rasterizing">
<code>start_rasterizing()</code> </dt> <dd>
<p>Used in MixedModeRenderer. Switch to the raster renderer.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.stop_filter">
<code>stop_filter(filter_func)</code> </dt> <dd>
<p>Used in AggRenderer. Switch back to the original renderer. The contents of the temporary renderer is processed with the <em>filter_func</em> and is drawn on the original renderer as an image.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.stop_rasterizing">
<code>stop_rasterizing()</code> </dt> <dd>
<p>Used in MixedModeRenderer. Switch back to the vector renderer and draw the contents of the raster renderer as an image on the vector renderer.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.RendererBase.strip_math">
<code>strip_math(s)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.ResizeEvent">
<code>class matplotlib.backend_bases.ResizeEvent(name, canvas)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>matplotlib.backend_bases.Event</code></a></p> <p>An event triggered by a canvas resize</p> <p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code>Event</code></a> attributes, the following event attributes are defined:</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>width</strong></td> <td>(scalar) width of the canvas in pixels</td> </tr> <tr>
<td><strong>height</strong></td> <td>(scalar) height of the canvas in pixels</td> </tr>  </table> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.ShowBase">
<code>class matplotlib.backend_bases.ShowBase</code> </dt> <dd>
<p>Bases: <code>matplotlib.backend_bases._Backend</code></p> <p>Simple base class to generate a show() callable in backends.</p> <p>Subclass must override mainloop() method.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.StatusbarBase">
<code>class matplotlib.backend_bases.StatusbarBase(toolmanager)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Base class for the statusbar</p> <dl class="method"> <dt id="matplotlib.backend_bases.StatusbarBase.set_message">
<code>set_message(s)</code> </dt> <dd>
<p>Display a message on toolbar or in status bar</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>s</strong> : str</p>  <p>Message text</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.TimerBase">
<code>class matplotlib.backend_bases.TimerBase(interval=None, callbacks=None)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>A base class for providing timer events, useful for things animations. Backends need to implement a few specific methods in order to use their own timing mechanisms so that the timer events are integrated into their event loops.</p> <p>Mandatory functions that must be implemented:</p>  <ul class="simple"> <li>
<code>_timer_start</code>: Contains backend-specific code for starting the timer</li> <li>
<code>_timer_stop</code>: Contains backend-specific code for stopping the timer</li> </ul>  <p>Optional overrides:</p>  <ul class="simple"> <li>
<code>_timer_set_single_shot</code>: Code for setting the timer to single shot operating mode, if supported by the timer object. If not, the <code>Timer</code> class itself will store the flag and the <code>_on_timer</code> method should be overridden to support such behavior.</li> <li>
<code>_timer_set_interval</code>: Code for setting the interval on the timer, if there is a method for doing so on the timer object.</li> <li>
<code>_on_timer</code>: This is the internal function that any timer object should call, which will handle the task of running all callbacks that have been set.</li> </ul>  <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>interval</strong></td> <td>(scalar) The time between timer events in milliseconds. Default is 1000 ms.</td> </tr> <tr>
<td><strong>single_shot</strong></td> <td>(bool) Boolean flag indicating whether this timer should operate as single shot (run once and then stop). Defaults to <a class="reference external" href="https://docs.python.org/2/library/constants.html#False" title="(in Python v2.7)" target="_blank"><code>False</code></a>.</td> </tr> <tr>
<td><strong>callbacks</strong></td> <td>(list) Stores list of (func, args) tuples that will be called upon timer events. This list can be manipulated directly, or the functions <a class="reference internal" href="#matplotlib.backend_bases.TimerBase.add_callback" title="matplotlib.backend_bases.TimerBase.add_callback"><code>add_callback</code></a> and <a class="reference internal" href="#matplotlib.backend_bases.TimerBase.remove_callback" title="matplotlib.backend_bases.TimerBase.remove_callback"><code>remove_callback</code></a> can be used.</td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backend_bases.TimerBase.add_callback">
<code>add_callback(func, *args, **kwargs)</code> </dt> <dd>
<p>Register <code>func</code> to be called by timer when the event fires. Any additional arguments provided will be passed to <code>func</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.TimerBase.interval">
<code>interval</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.TimerBase.remove_callback">
<code>remove_callback(func, *args, **kwargs)</code> </dt> <dd>
<p>Remove <code>func</code> from list of callbacks. <code>args</code> and <code>kwargs</code> are optional and used to distinguish between copies of the same function registered to be called with different arguments.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backend_bases.TimerBase.single_shot">
<code>single_shot</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.TimerBase.start">
<code>start(interval=None)</code> </dt> <dd>
<p>Start the timer object. <a class="reference internal" href="#matplotlib.backend_bases.TimerBase.interval" title="matplotlib.backend_bases.TimerBase.interval"><code>interval</code></a> is optional and will be used to reset the timer interval first if provided.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.TimerBase.stop">
<code>stop()</code> </dt> <dd>
<p>Stop the timer.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backend_bases.ToolContainerBase">
<code>class matplotlib.backend_bases.ToolContainerBase(toolmanager)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Base class for all tool containers, e.g. toolbars.</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>toolmanager</strong></td> <td>(<code>ToolManager</code>) The tools with which this <code>ToolContainer</code> wants to communicate.</td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backend_bases.ToolContainerBase.add_tool">
<code>add_tool(tool, group, position=-1)</code> </dt> <dd>
<p>Adds a tool to this container</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>tool</strong> : tool_like</p>  <p>The tool to add, see <code>ToolManager.get_tool</code>.</p>  <p><strong>group</strong> : str</p>  <p>The name of the group to add this tool to.</p>  <p><strong>position</strong> : int (optional)</p>  <p>The position within the group to place this tool. Defaults to end.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.ToolContainerBase.add_toolitem">
<code>add_toolitem(name, group, position, image, description, toggle)</code> </dt> <dd>
<p>Add a toolitem to the container</p> <p>This method must get implemented per backend</p> <p>The callback associated with the button click event, must be <strong>EXACTLY</strong> <code>self.trigger_tool(name)</code></p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>name</strong> : string</p>  <p>Name of the tool to add, this gets used as the tool’s ID and as the default label of the buttons</p>  <p><strong>group</strong> : String</p>  <p>Name of the group that this tool belongs to</p>  <p><strong>position</strong> : Int</p>  <p>Position of the tool within its group, if -1 it goes at the End</p>  <p><strong>image_file</strong> : String</p>  <p>Filename of the image for the button or <a class="reference external" href="https://docs.python.org/2/library/constants.html#None" title="(in Python v2.7)" target="_blank"><code>None</code></a></p>  <p><strong>description</strong> : String</p>  <p>Description of the tool, used for the tooltips</p>  <p><strong>toggle</strong> : Bool</p>  <ul class="simple"> <li>
<a class="reference external" href="https://docs.python.org/2/library/constants.html#True" title="(in Python v2.7)" target="_blank"><code>True</code></a> : The button is a toggle (change the pressed/unpressed state between consecutive clicks)</li> <li>
<a class="reference external" href="https://docs.python.org/2/library/constants.html#False" title="(in Python v2.7)" target="_blank"><code>False</code></a> : The button is a normal button (returns to unpressed state after release)</li> </ul>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.ToolContainerBase.remove_toolitem">
<code>remove_toolitem(name)</code> </dt> <dd>
<p>Remove a toolitem from the <code>ToolContainer</code></p> <p>This method must get implemented per backend</p> <p>Called when <code>ToolManager</code> emits a <code>tool_removed_event</code></p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>name</strong> : string</p>  <p>Name of the tool to remove</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.ToolContainerBase.toggle_toolitem">
<code>toggle_toolitem(name, toggled)</code> </dt> <dd>
<p>Toggle the toolitem without firing event</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>name</strong> : String</p>  <p>Id of the tool to toggle</p>  <p><strong>toggled</strong> : bool</p>  <p>Whether to set this tool as toggled or not.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backend_bases.ToolContainerBase.trigger_tool">
<code>trigger_tool(name)</code> </dt> <dd>
<p>Trigger the tool</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>name</strong> : String</p>  <p>Name (id) of the tool triggered from within the container</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backend_bases.get_registered_canvas_class">
<code>matplotlib.backend_bases.get_registered_canvas_class(format)</code> </dt> <dd>
<p>Return the registered default canvas for given file format. Handles deferred import of required backend.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backend_bases.key_press_handler">
<code>matplotlib.backend_bases.key_press_handler(event, canvas, toolbar=None)</code> </dt> <dd>
<p>Implement the default mpl key bindings for the canvas and toolbar described at <a class="reference internal" href="http://matplotlib.org/2.1.0/users/navigation_toolbar.html#key-event-handling" target="_blank"><span class="std std-ref">Navigation Keyboard Shortcuts</span></a></p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>event</strong> : <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code>KeyEvent</code></a></p>  <p>a key press/release event</p>  <p><strong>canvas</strong> : <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><code>FigureCanvasBase</code></a></p>  <p>the backend-specific canvas instance</p>  <p><strong>toolbar</strong> : <a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2" title="matplotlib.backend_bases.NavigationToolbar2"><code>NavigationToolbar2</code></a></p>  <p>the navigation cursor toolbar</p>  </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backend_bases.register_backend">
<code>matplotlib.backend_bases.register_backend(format, backend, description=None)</code> </dt> <dd>
<p>Register a backend for saving to a given file format.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>format</strong> : str</p>  <p>File extension</p>  <p><strong>backend</strong> : module string or canvas class</p>  <p>Backend for handling file output</p>  <p><strong>description</strong> : str, optional</p>  <p>Description of the file type. Defaults to an empty string</p>  </td> </tr>  </table> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/2.1.0/api/backend_bases_api.html" class="_attribution-link" target="_blank">http://matplotlib.org/2.1.0/api/backend_bases_api.html</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
