
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Working With Transformations - Matplotlib 2.1 - W3cubDocs</title>
  
  <meta name="description" content="matplotlib includes a framework for arbitrary geometric transformations that is used determine the final position of all elements drawn on the &hellip;">
  <meta name="keywords" content="working, with, transformations, -, matplotlib, matplotlib~2.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~2.1/transformations/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/matplotlib~2.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~2.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 2.1</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
				
<h1 id="working-with-transformations">Working with transformations</h1> <img src="data:image/png;base64,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" alt="Inheritance diagram of matplotlib.transforms, matplotlib.path" usemap="#inheritancedbde0cb62f" class="inheritance"> <map id="inheritancedbde0cb62f" name="inheritancedbde0cb62f"> <area shape="rect" id="node1" href="#matplotlib.transforms.Affine2D" target="_top" title="A mutable 2D affine transformation." alt="" coords="531,4,583,20"> <area shape="rect" id="node2" href="#matplotlib.transforms.Affine2DBase" target="_top" title="The base class of all 2D affine transformations." alt="" coords="402,118,475,135"> <area shape="rect" id="node8" href="#matplotlib.transforms.BboxTransform" target="_top" title=":class:`BboxTransform` linearly transforms points from one" alt="" coords="517,36,596,53"> <area shape="rect" id="node9" href="#matplotlib.transforms.BboxTransformFrom" target="_top" title=":class:`BboxTransformFrom` linearly transforms points from a given" alt="" coords="506,69,607,85"> <area shape="rect" id="node10" href="#matplotlib.transforms.BboxTransformTo" target="_top" title=":class:`BboxTransformTo` is a transformation that linearly" alt="" coords="512,101,601,118"> <area shape="rect" id="node12" href="#matplotlib.transforms.BlendedAffine2D" target="_top" title='A "blended" transform uses one transform for the *x*-direction, and' alt="" coords="513,134,600,151"> <area shape="rect" id="node14" href="#matplotlib.transforms.CompositeAffine2D" target="_top" title="A composite transform formed by applying transform *a* then transform *b*." alt="" coords="508,166,606,183"> <area shape="rect" id="node16" href="#matplotlib.transforms.IdentityTransform" target="_top" title="A special class that does one thing, the identity transform, in a" alt="" coords="511,199,602,216"> <area shape="rect" id="node19" href="#matplotlib.transforms.ScaledTranslation" target="_top" title="A transformation that translates by *xt* and *yt*, after *xt* and *yt*" alt="" coords="512,232,602,248"> <area shape="rect" id="node3" href="#matplotlib.transforms.AffineBase" target="_top" title="The base class of all affine transformations of any number of" alt="" coords="271,118,332,135"> <area shape="rect" id="node4" href="#matplotlib.transforms.Transform" target="_top" title="The base class of all :class:`TransformNode` instances that" alt="" coords="130,183,187,200"> <area shape="rect" id="node13" href="#matplotlib.transforms.BlendedGenericTransform" target="_top" title='A "blended" transform uses one transform for the *x*-direction, and' alt="" coords="239,151,365,167"> <area shape="rect" id="node15" href="#matplotlib.transforms.CompositeGenericTransform" target="_top" title="A composite transform formed by applying transform *a* then" alt="" coords="233,183,370,200"> <area shape="rect" id="node20" href="#matplotlib.transforms.TransformWrapper" target="_top" title="A helper class that holds a single child transform and acts" alt="" coords="255,216,348,233"> <area shape="rect" id="node5" href="#matplotlib.transforms.Bbox" target="_top" title="A mutable bounding box." alt="" coords="278,248,325,265"> <area shape="rect" id="node6" href="#matplotlib.transforms.BboxBase" target="_top" title="This is the base class of all bounding boxes, and provides" alt="" coords="130,281,187,298"> <area shape="rect" id="node17" href="#matplotlib.transforms.LockableBbox" target="_top" title="A :class:`Bbox` where some elements may be locked at certain values." alt="" coords="264,281,339,298"> <area shape="rect" id="node21" href="#matplotlib.transforms.TransformedBbox" target="_top" title="A :class:`Bbox` that is automatically transformed by a given" alt="" coords="257,314,347,330"> <area shape="rect" id="node7" href="#matplotlib.transforms.TransformNode" target="_top" title=":class:`TransformNode` is the base class for anything that" alt="" coords="4,281,84,298"> <area shape="rect" id="node23" href="#matplotlib.transforms.TransformedPath" target="_top" title="A :class:`TransformedPath` caches a non-affine transformed copy of" alt="" coords="115,329,202,346"> <area shape="rect" id="node11" href="#matplotlib.transforms.BboxTransformToMaxOnly" target="_top" title=":class:`BboxTransformTo` is a transformation that linearly" alt="" coords="639,101,764,118"> <area shape="rect" id="node18" href="path_api.html#matplotlib.path.Path" target="_top" title=":class:`Path` represents a series of possibly disconnected," alt="" coords="20,248,67,265"> <area shape="rect" id="node22" href="#matplotlib.transforms.TransformedPatchPath" target="_top" title="A :class:`TransformedPatchPath` caches a non-affine transformed copy of" alt="" coords="247,346,357,363"> </map>  <h2 id="matplotlib-transforms">matplotlib.transforms</h2> <p id="module-matplotlib.transforms">matplotlib includes a framework for arbitrary geometric transformations that is used determine the final position of all elements drawn on the canvas.</p> <p>Transforms are composed into trees of <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> objects whose actual value depends on their children. When the contents of children change, their parents are automatically invalidated. The next time an invalidated transform is accessed, it is recomputed to reflect those changes. This invalidation/caching approach prevents unnecessary recomputations of transforms, and contributes to better interactive performance.</p> <p>For example, here is a graph of the transform tree used to plot data to the graph:</p> <img alt="../_images/transforms.png" src="data:image/png;base64,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"> <p>The framework can be used for both affine and non-affine transformations. However, for speed, we want use the backend renderers to perform affine transformations whenever possible. Therefore, it is possible to perform just the affine or non-affine part of a transformation on a set of data. The affine is always assumed to occur after the non-affine. For any transform:</p> <pre data-language="python">full transform == non-affine part + affine part
</pre> <p>The backends are not expected to handle non-affine transformations themselves.</p> <dl class="class"> <dt id="matplotlib.transforms.Affine2D">
<code>class matplotlib.transforms.Affine2D(matrix=None, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A mutable 2D affine transformation.</p> <p>Initialize an Affine transform from a 3x3 numpy float array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>If <em>matrix</em> is None, initialize with the identity transform.</p> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.clear">
<code>clear()</code> </dt> <dd>
<p>Reset the underlying matrix to the identity transform.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Affine2D.from_values">
<code>static from_values(a, b, c, d, e, f)</code> </dt> <dd>
<p>(staticmethod) Create a new Affine2D instance from the given values:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the underlying transformation matrix as a 3x3 numpy array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Affine2D.identity">
<code>static identity()</code> </dt> <dd>
<p>(staticmethod) Return a new <a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a> object that is the identity transform.</p> <p>Unless this transform will be mutated later on, consider using the faster <a class="reference internal" href="#matplotlib.transforms.IdentityTransform" title="matplotlib.transforms.IdentityTransform"><code>IdentityTransform</code></a> class instead.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Affine2D.is_separable">
<code>is_separable</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.rotate">
<code>rotate(theta)</code> </dt> <dd>
<p>Add a rotation (in radians) to this transform in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.rotate_around">
<code>rotate_around(x, y, theta)</code> </dt> <dd>
<p>Add a rotation (in radians) around the point (x, y) in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.rotate_deg">
<code>rotate_deg(degrees)</code> </dt> <dd>
<p>Add a rotation (in degrees) to this transform in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.rotate_deg_around">
<code>rotate_deg_around(x, y, degrees)</code> </dt> <dd>
<p>Add a rotation (in degrees) around the point (x, y) in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.scale">
<code>scale(sx, sy=None)</code> </dt> <dd>
<p>Adds a scale in place.</p> <p>If <em>sy</em> is None, the same scale is applied in both the <em>x</em>- and <em>y</em>-directions.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.set">
<code>set(other)</code> </dt> <dd>
<p>Set this transformation from the frozen copy of another <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a> object.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.set_matrix">
<code>set_matrix(mtx)</code> </dt> <dd>
<p>Set the underlying transformation matrix from a 3x3 numpy array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.skew">
<code>skew(xShear, yShear)</code> </dt> <dd>
<p>Adds a skew in place.</p> <p><em>xShear</em> and <em>yShear</em> are the shear angles along the <em>x</em>- and <em>y</em>-axes, respectively, in radians.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.skew_deg">
<code>skew_deg(xShear, yShear)</code> </dt> <dd>
<p>Adds a skew in place.</p> <p><em>xShear</em> and <em>yShear</em> are the shear angles along the <em>x</em>- and <em>y</em>-axes, respectively, in degrees.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.translate">
<code>translate(tx, ty)</code> </dt> <dd>
<p>Adds a translation in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.Affine2DBase">
<code>class matplotlib.transforms.Affine2DBase(*args, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.AffineBase" title="matplotlib.transforms.AffineBase"><code>matplotlib.transforms.AffineBase</code></a></p> <p>The base class of all 2D affine transformations.</p> <p>2D affine transformations are performed using a 3x3 numpy array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>This class provides the read-only interface. For a mutable 2D affine transformation, use <a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a>.</p> <p>Subclasses of this class will generally only need to override a constructor and <code>get_matrix()</code> that generates a custom 3x3 matrix.</p> <dl class="method"> <dt id="matplotlib.transforms.Affine2DBase.frozen">
<code>frozen()</code> </dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Affine2DBase.has_inverse">
<code>has_inverse = True</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Affine2DBase.input_dims">
<code>input_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2DBase.inverted">
<code>inverted()</code> </dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Affine2DBase.is_separable">
<code>is_separable</code> </dt> 
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Affine2DBase.matrix_from_values">
<code>static matrix_from_values(a, b, c, d, e, f)</code> </dt> <dd>
<p>(staticmethod) Create a new transformation matrix as a 3x3 numpy array of the form:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Affine2DBase.output_dims">
<code>output_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2DBase.to_values">
<code>to_values()</code> </dt> <dd>
<p>Return the values of the matrix as a sequence (a,b,c,d,e,f)</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2DBase.transform_affine">
<code>transform_affine(points)</code> </dt> <dd>
<p>Performs only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.output_dims" title="matplotlib.transforms.Affine2DBase.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.output_dims" title="matplotlib.transforms.Affine2DBase.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2DBase.transform_point">
<code>transform_point(point)</code> </dt> <dd>
<p>A convenience function that returns the transformed copy of a single point.</p> <p>The point is given as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code>input_dims</code></a>. The transformed point is returned as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.output_dims" title="matplotlib.transforms.Affine2DBase.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.AffineBase">
<code>class matplotlib.transforms.AffineBase(*args, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>The base class of all affine transformations of any number of dimensions.</p> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.get_affine">
<code>get_affine()</code> </dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.AffineBase.is_affine">
<code>is_affine = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform">
<code>transform(values)</code> </dt> <dd>
<p>Performs the transformation on the given array of values.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform_affine">
<code>transform_affine(values)</code> </dt> <dd>
<p>Performs only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform_non_affine">
<code>transform_non_affine(points)</code> </dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform_path">
<code>transform_path(path)</code> </dt> <dd>
<p>Returns a transformed path.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p>In some cases, this transform may insert curves into the path that began as line segments.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform_path_affine">
<code>transform_path_affine(path)</code> </dt> <dd>
<p>Returns a path, transformed only by the affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform_path_non_affine">
<code>transform_path_non_affine(path)</code> </dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.Bbox">
<code>class matplotlib.transforms.Bbox(points, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>matplotlib.transforms.BboxBase</code></a></p> <p>A mutable bounding box.</p> <p><em>points</em>: a 2x2 numpy array of the form [[x0, y0], [x1, y1]]</p> <p>If you need to create a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> object from another form of data, consider the static methods <a class="reference internal" href="#matplotlib.transforms.Bbox.unit" title="matplotlib.transforms.Bbox.unit"><code>unit()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Bbox.from_bounds" title="matplotlib.transforms.Bbox.from_bounds"><code>from_bounds()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Bbox.from_extents" title="matplotlib.transforms.Bbox.from_extents"><code>from_extents()</code></a>.</p> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.bounds">
<code>bounds</code> </dt> <dd>
<p>(property) Returns (<a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code>y0</code></a>, <code>width</code>, <code>height</code>).</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Bbox.from_bounds">
<code>static from_bounds(x0, y0, width, height)</code> </dt> <dd>
<p>(staticmethod) Create a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> from <em>x0</em>, <em>y0</em>, <em>width</em> and <em>height</em>.</p> <p><em>width</em> and <em>height</em> may be negative.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Bbox.from_extents">
<code>static from_extents(*args)</code> </dt> <dd>
<p>(staticmethod) Create a new Bbox from <em>left</em>, <em>bottom</em>, <em>right</em> and <em>top</em>.</p> <p>The <em>y</em>-axis increases upwards.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.get_points">
<code>get_points()</code> </dt> <dd>
<p>Get the points of the bounding box directly as a numpy array of the form: [[x0, y0], [x1, y1]].</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.ignore">
<code>ignore(value)</code> </dt> <dd>
<p>Set whether the existing bounds of the box should be ignored by subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code>update_from_data_xy()</code></a>.</p> <p><em>value</em>:</p>  <ul class="simple"> <li>When True, subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code>update_from_data_xy()</code></a> will ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>When False, subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code>update_from_data_xy()</code></a> will include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> </ul>  </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.intervalx">
<code>intervalx</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.Bbox.intervalx" title="matplotlib.transforms.Bbox.intervalx"><code>intervalx</code></a> is the pair of <em>x</em> coordinates that define the bounding box. It is not guaranteed to be sorted from left to right.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.intervaly">
<code>intervaly</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.Bbox.intervaly" title="matplotlib.transforms.Bbox.intervaly"><code>intervaly</code></a> is the pair of <em>y</em> coordinates that define the bounding box. It is not guaranteed to be sorted from bottom to top.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.minpos">
<code>minpos</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.minposx">
<code>minposx</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.minposy">
<code>minposy</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.mutated">
<code>mutated()</code> </dt> <dd>
<p>return whether the bbox has changed since init</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.mutatedx">
<code>mutatedx()</code> </dt> <dd>
<p>return whether the x-limits have changed since init</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.mutatedy">
<code>mutatedy()</code> </dt> <dd>
<p>return whether the y-limits have changed since init</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Bbox.null">
<code>static null()</code> </dt> <dd>
<p>(staticmethod) Create a new null <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> from (inf, inf) to (-inf, -inf).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.p0">
<code>p0</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.Bbox.p0" title="matplotlib.transforms.Bbox.p0"><code>p0</code></a> is the first pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box. It is not guaranteed to be the bottom-left corner. For that, use <code>min</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.p1">
<code>p1</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.Bbox.p1" title="matplotlib.transforms.Bbox.p1"><code>p1</code></a> is the second pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box. It is not guaranteed to be the top-right corner. For that, use <code>max</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.set">
<code>set(other)</code> </dt> <dd>
<p>Set this bounding box from the “frozen” bounds of another <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.set_points">
<code>set_points(points)</code> </dt> <dd>
<p>Set the points of the bounding box directly from a numpy array of the form: [[x0, y0], [x1, y1]]. No error checking is performed, as this method is mainly for internal use.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Bbox.unit">
<code>static unit()</code> </dt> <dd>
<p>(staticmethod) Create a new unit <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> from (0, 0) to (1, 1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.update_from_data">
<code>update_from_data(x, y, ignore=None)</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified">Deprecated since version 2.0: </span>The update_from_data function was deprecated in version 2.0. Use update_from_data_xy instead.</p> </div> <p>Update the bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> based on the passed in data. After updating, the bounds will have positive <em>width</em> and <em>height</em>; <em>x0</em> and <em>y0</em> will be the minimal values.</p> <p><em>x</em>: a numpy array of <em>x</em>-values</p> <p><em>y</em>: a numpy array of <em>y</em>-values</p> <dl class="docutils"> <dt>
<em>ignore</em>:</dt> <dd>
<ul class="first last simple"> <li>when True, ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>when False, include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>when None, use the last value passed to <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code>ignore()</code></a>.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.update_from_data_xy">
<code>update_from_data_xy(xy, ignore=None, updatex=True, updatey=True)</code> </dt> <dd>
<p>Update the bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> based on the passed in data. After updating, the bounds will have positive <em>width</em> and <em>height</em>; <em>x0</em> and <em>y0</em> will be the minimal values.</p> <p><em>xy</em>: a numpy array of 2D points</p> <dl class="docutils"> <dt>
<em>ignore</em>:</dt> <dd>
<ul class="first last simple"> <li>when True, ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>when False, include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>when None, use the last value passed to <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code>ignore()</code></a>.</li> </ul> </dd> </dl> <p><em>updatex</em>: when True, update the x values</p> <p><em>updatey</em>: when True, update the y values</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.update_from_path">
<code>update_from_path(path, ignore=None, updatex=True, updatey=True)</code> </dt> <dd>
<p>Update the bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> based on the passed in data. After updating, the bounds will have positive <em>width</em> and <em>height</em>; <em>x0</em> and <em>y0</em> will be the minimal values.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance</p> <dl class="docutils"> <dt>
<em>ignore</em>:</dt> <dd>
<ul class="first last simple"> <li>when True, ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>when False, include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>when None, use the last value passed to <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code>ignore()</code></a>.</li> </ul> </dd> </dl> <p><em>updatex</em>: when True, update the x values</p> <p><em>updatey</em>: when True, update the y values</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.x0">
<code>x0</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code>x0</code></a> is the first of the pair of <em>x</em> coordinates that define the bounding box. <a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code>x0</code></a> is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.Bbox.x1" title="matplotlib.transforms.Bbox.x1"><code>x1</code></a>. If you require that, use <code>xmin</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.x1">
<code>x1</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.Bbox.x1" title="matplotlib.transforms.Bbox.x1"><code>x1</code></a> is the second of the pair of <em>x</em> coordinates that define the bounding box. <a class="reference internal" href="#matplotlib.transforms.Bbox.x1" title="matplotlib.transforms.Bbox.x1"><code>x1</code></a> is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code>x0</code></a>. If you require that, use <code>xmax</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.y0">
<code>y0</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code>y0</code></a> is the first of the pair of <em>y</em> coordinates that define the bounding box. <a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code>y0</code></a> is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.Bbox.y1" title="matplotlib.transforms.Bbox.y1"><code>y1</code></a>. If you require that, use <code>ymin</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.y1">
<code>y1</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.Bbox.y1" title="matplotlib.transforms.Bbox.y1"><code>y1</code></a> is the second of the pair of <em>y</em> coordinates that define the bounding box. <a class="reference internal" href="#matplotlib.transforms.Bbox.y1" title="matplotlib.transforms.Bbox.y1"><code>y1</code></a> is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code>y0</code></a>. If you require that, use <code>ymax</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BboxBase">
<code>class matplotlib.transforms.BboxBase(shorthand_name=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>matplotlib.transforms.TransformNode</code></a></p> <p>This is the base class of all bounding boxes, and provides read-only access to its data. A mutable bounding box is provided by the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> class.</p> <p>The canonical representation is as two points, with no restrictions on their ordering. Convenience properties are provided to get the left, bottom, right and top edges and width and height, but these are not stored explicitly.</p> <p>Creates a new <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a>.</p> <dl class="docutils"> <dt>
<strong>shorthand_name</strong> - a string representing the “name” of this</dt> <dd>transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</dd> </dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.anchored">
<code>anchored(c, container=None)</code> </dt> <dd>
<p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>, shifted to position <em>c</em> within a container.</p> <p><em>c</em>: may be either:</p>  <ul class="simple"> <li>a sequence (<em>cx</em>, <em>cy</em>) where <em>cx</em> and <em>cy</em> range from 0 to 1, where 0 is left or bottom and 1 is right or top</li> <li>a string: - ‘C’ for centered - ‘S’ for bottom-center - ‘SE’ for bottom-left - ‘E’ for left - etc.</li> </ul>  <p>Optional argument <em>container</em> is the box within which the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> is positioned; it defaults to the initial <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.bounds">
<code>bounds</code> </dt> <dd>
<p>(property) Returns (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.width" title="matplotlib.transforms.BboxBase.width"><code>width</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.height" title="matplotlib.transforms.BboxBase.height"><code>height</code></a>).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.coefs">
<code>coefs = {'C': (0.5, 0.5), 'SW': (0, 0), 'S': (0.5, 0), 'SE': (1.0, 0), 'E': (1.0, 0.5), 'NE': (1.0, 1.0), 'N': (0.5, 1.0), 'NW': (0, 1.0), 'W': (0, 0.5)}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.contains">
<code>contains(x, y)</code> </dt> <dd>
<p>Returns whether <code>x, y</code> is in the bounding box or on its edge.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.containsx">
<code>containsx(x)</code> </dt> <dd>
<p>Returns whether <code>x</code> is in the closed (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a>) interval.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.containsy">
<code>containsy(y)</code> </dt> <dd>
<p>Returns whether <code>y</code> is in the closed (<a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a>) interval.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.corners">
<code>corners()</code> </dt> <dd>
<p>Return an array of points which are the four corners of this rectangle. For example, if this <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> is defined by the points (<em>a</em>, <em>b</em>) and (<em>c</em>, <em>d</em>), <a class="reference internal" href="#matplotlib.transforms.BboxBase.corners" title="matplotlib.transforms.BboxBase.corners"><code>corners()</code></a> returns (<em>a</em>, <em>b</em>), (<em>a</em>, <em>d</em>), (<em>c</em>, <em>b</em>) and (<em>c</em>, <em>d</em>).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.count_contains">
<code>count_contains(vertices)</code> </dt> <dd>
<p>Count the number of vertices contained in the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>. Any vertices with a non-finite x or y value are ignored.</p> <p><em>vertices</em> is a Nx2 Numpy array.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.count_overlaps">
<code>count_overlaps(bboxes)</code> </dt> <dd>
<p>Count the number of bounding boxes that overlap this one.</p> <p>bboxes is a sequence of <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>BboxBase</code></a> objects</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.expanded">
<code>expanded(sw, sh)</code> </dt> <dd>
<p>Return a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> which is this <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> expanded around its center by the given factors <em>sw</em> and <em>sh</em>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.extents">
<code>extents</code> </dt> <dd>
<p>(property) Returns (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a>).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.frozen">
<code>frozen()</code> </dt> <dd>
<p><a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> is the base class for anything that participates in the transform tree and needs to invalidate its parents or be invalidated. This includes classes that are not really transforms, such as bounding boxes, since some transforms depend on bounding boxes to compute their values.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.fully_contains">
<code>fully_contains(x, y)</code> </dt> <dd>
<p>Returns whether <code>x, y</code> is in the bounding box, but not on its edge.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.fully_containsx">
<code>fully_containsx(x)</code> </dt> <dd>
<p>Returns whether <code>x</code> is in the open (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a>) interval.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.fully_containsy">
<code>fully_containsy(y)</code> </dt> <dd>
<p>Returns whether <code>y</code> is in the open (<a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a>) interval.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.fully_overlaps">
<code>fully_overlaps(other)</code> </dt> <dd>
<p>Returns whether this bounding box overlaps with the other bounding box, not including the edges.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.get_points">
<code>get_points()</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.height">
<code>height</code> </dt> <dd>
<p>(property) The height of the bounding box. It may be negative if <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a> &lt; <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.BboxBase.intersection">
<code>static intersection(bbox1, bbox2)</code> </dt> <dd>
<p>Return the intersection of the two bboxes or None if they do not intersect.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.intervalx">
<code>intervalx</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.intervalx" title="matplotlib.transforms.BboxBase.intervalx"><code>intervalx</code></a> is the pair of <em>x</em> coordinates that define the bounding box. It is not guaranteed to be sorted from left to right.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.intervaly">
<code>intervaly</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.intervaly" title="matplotlib.transforms.BboxBase.intervaly"><code>intervaly</code></a> is the pair of <em>y</em> coordinates that define the bounding box. It is not guaranteed to be sorted from bottom to top.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.inverse_transformed">
<code>inverse_transformed(transform)</code> </dt> <dd>
<p>Return a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> object, statically transformed by the inverse of the given transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.is_affine">
<code>is_affine = True</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.is_bbox">
<code>is_bbox = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.is_unit">
<code>is_unit()</code> </dt> <dd>
<p>Returns True if the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> is the unit bounding box from (0, 0) to (1, 1).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.max">
<code>max</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.max" title="matplotlib.transforms.BboxBase.max"><code>max</code></a> is the top-right corner of the bounding box.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.min">
<code>min</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.min" title="matplotlib.transforms.BboxBase.min"><code>min</code></a> is the bottom-left corner of the bounding box.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.overlaps">
<code>overlaps(other)</code> </dt> <dd>
<p>Returns whether this bounding box overlaps with the other bounding box.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.p0">
<code>p0</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.p0" title="matplotlib.transforms.BboxBase.p0"><code>p0</code></a> is the first pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box. It is not guaranteed to be the bottom-left corner. For that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.min" title="matplotlib.transforms.BboxBase.min"><code>min</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.p1">
<code>p1</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.p1" title="matplotlib.transforms.BboxBase.p1"><code>p1</code></a> is the second pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box. It is not guaranteed to be the top-right corner. For that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.max" title="matplotlib.transforms.BboxBase.max"><code>max</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.padded">
<code>padded(p)</code> </dt> <dd>
<p>Return a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> that is padded on all four sides by the given value.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.rotated">
<code>rotated(radians)</code> </dt> <dd>
<p>Return a new bounding box that bounds a rotated version of this bounding box by the given radians. The new bounding box is still aligned with the axes, of course.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.shrunk">
<code>shrunk(mx, my)</code> </dt> <dd>
<p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>, shrunk by the factor <em>mx</em> in the <em>x</em> direction and the factor <em>my</em> in the <em>y</em> direction. The lower left corner of the box remains unchanged. Normally <em>mx</em> and <em>my</em> will be less than 1, but this is not enforced.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.shrunk_to_aspect">
<code>shrunk_to_aspect(box_aspect, container=None, fig_aspect=1.0)</code> </dt> <dd>
<p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>, shrunk so that it is as large as it can be while having the desired aspect ratio, <em>box_aspect</em>. If the box coordinates are relative—that is, fractions of a larger box such as a figure—then the physical aspect ratio of that figure is specified with <em>fig_aspect</em>, so that <em>box_aspect</em> can also be given as a ratio of the absolute dimensions, not the relative dimensions.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.size">
<code>size</code> </dt> <dd>
<p>(property) The width and height of the bounding box. May be negative, in the same way as <a class="reference internal" href="#matplotlib.transforms.BboxBase.width" title="matplotlib.transforms.BboxBase.width"><code>width</code></a> and <a class="reference internal" href="#matplotlib.transforms.BboxBase.height" title="matplotlib.transforms.BboxBase.height"><code>height</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.splitx">
<code>splitx(*args)</code> </dt> <dd>
<p>e.g., <code>bbox.splitx(f1, f2, ...)</code></p> <p>Returns a list of new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> objects formed by splitting the original one with vertical lines at fractional positions <em>f1</em>, <em>f2</em>, …</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.splity">
<code>splity(*args)</code> </dt> <dd>
<p>e.g., <code>bbox.splitx(f1, f2, ...)</code></p> <p>Returns a list of new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> objects formed by splitting the original one with horizontal lines at fractional positions <em>f1</em>, <em>f2</em>, …</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.transformed">
<code>transformed(transform)</code> </dt> <dd>
<p>Return a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> object, statically transformed by the given transform.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.translated">
<code>translated(tx, ty)</code> </dt> <dd>
<p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>, statically translated by <em>tx</em> and <em>ty</em>.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.BboxBase.union">
<code>static union(bboxes)</code> </dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> that contains all of the given bboxes.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.width">
<code>width</code> </dt> <dd>
<p>(property) The width of the bounding box. It may be negative if <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a> &lt; <a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.x0">
<code>x0</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a> is the first of the pair of <em>x</em> coordinates that define the bounding box. <a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a> is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a>. If you require that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.xmin" title="matplotlib.transforms.BboxBase.xmin"><code>xmin</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.x1">
<code>x1</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a> is the second of the pair of <em>x</em> coordinates that define the bounding box. <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a> is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>. If you require that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.xmax" title="matplotlib.transforms.BboxBase.xmax"><code>xmax</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.xmax">
<code>xmax</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.xmax" title="matplotlib.transforms.BboxBase.xmax"><code>xmax</code></a> is the right edge of the bounding box.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.xmin">
<code>xmin</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.xmin" title="matplotlib.transforms.BboxBase.xmin"><code>xmin</code></a> is the left edge of the bounding box.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.y0">
<code>y0</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a> is the first of the pair of <em>y</em> coordinates that define the bounding box. <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a> is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a>. If you require that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.ymin" title="matplotlib.transforms.BboxBase.ymin"><code>ymin</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.y1">
<code>y1</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a> is the second of the pair of <em>y</em> coordinates that define the bounding box. <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a> is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>. If you require that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.ymax" title="matplotlib.transforms.BboxBase.ymax"><code>ymax</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.ymax">
<code>ymax</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.ymax" title="matplotlib.transforms.BboxBase.ymax"><code>ymax</code></a> is the top edge of the bounding box.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.ymin">
<code>ymin</code> </dt> <dd>
<p>(property) <a class="reference internal" href="#matplotlib.transforms.BboxBase.ymin" title="matplotlib.transforms.BboxBase.ymin"><code>ymin</code></a> is the bottom edge of the bounding box.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BboxTransform">
<code>class matplotlib.transforms.BboxTransform(boxin, boxout, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransform" title="matplotlib.transforms.BboxTransform"><code>BboxTransform</code></a> linearly transforms points from one <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> to another <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransform" title="matplotlib.transforms.BboxTransform"><code>BboxTransform</code></a> that linearly transforms points from <em>boxin</em> to <em>boxout</em>.</p> <dl class="method"> <dt id="matplotlib.transforms.BboxTransform.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxTransform.is_separable">
<code>is_separable = True</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BboxTransformFrom">
<code>class matplotlib.transforms.BboxTransformFrom(boxin, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransformFrom" title="matplotlib.transforms.BboxTransformFrom"><code>BboxTransformFrom</code></a> linearly transforms points from a given <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> to the unit bounding box.</p> <dl class="method"> <dt id="matplotlib.transforms.BboxTransformFrom.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxTransformFrom.is_separable">
<code>is_separable = True</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BboxTransformTo">
<code>class matplotlib.transforms.BboxTransformTo(boxout, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> is a transformation that linearly transforms points from the unit bounding box to a given <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> that linearly transforms points from the unit bounding box to <em>boxout</em>.</p> <dl class="method"> <dt id="matplotlib.transforms.BboxTransformTo.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxTransformTo.is_separable">
<code>is_separable = True</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BboxTransformToMaxOnly">
<code>class matplotlib.transforms.BboxTransformToMaxOnly(boxout, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>matplotlib.transforms.BboxTransformTo</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> is a transformation that linearly transforms points from the unit bounding box to a given <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> with a fixed upper left of (0, 0).</p> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> that linearly transforms points from the unit bounding box to <em>boxout</em>.</p> <dl class="method"> <dt id="matplotlib.transforms.BboxTransformToMaxOnly.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BlendedAffine2D">
<code>class matplotlib.transforms.BlendedAffine2D(x_transform, y_transform, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A “blended” transform uses one transform for the <em>x</em>-direction, and another transform for the <em>y</em>-direction.</p> <p>This version is an optimization for the case where both child transforms are of type <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a>.</p> <p>Create a new “blended” transform using <em>x_transform</em> to transform the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p> <p>Both <em>x_transform</em> and <em>y_transform</em> must be 2D affine transforms.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.blended_transform_factory" title="matplotlib.transforms.blended_transform_factory"><code>blended_transform_factory()</code></a> function instead, which can determine automatically which kind of blended transform to create.</p> <dl class="method"> <dt id="matplotlib.transforms.BlendedAffine2D.contains_branch_seperately">
<code>contains_branch_seperately(transform)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedAffine2D.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedAffine2D.is_separable">
<code>is_separable = True</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BlendedGenericTransform">
<code>class matplotlib.transforms.BlendedGenericTransform(x_transform, y_transform, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>A “blended” transform uses one transform for the <em>x</em>-direction, and another transform for the <em>y</em>-direction.</p> <p>This “generic” version can handle any given child transform in the <em>x</em>- and <em>y</em>-directions.</p> <p>Create a new “blended” transform using <em>x_transform</em> to transform the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.blended_transform_factory" title="matplotlib.transforms.blended_transform_factory"><code>blended_transform_factory()</code></a> function instead, which can determine automatically which kind of blended transform to create.</p> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.contains_branch">
<code>contains_branch(other)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.contains_branch_seperately">
<code>contains_branch_seperately(transform)</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.depth">
<code>depth</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.frozen">
<code>frozen()</code> </dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.get_affine">
<code>get_affine()</code> </dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.has_inverse">
<code>has_inverse</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.input_dims">
<code>input_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.inverted">
<code>inverted()</code> </dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.is_affine">
<code>is_affine</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.is_separable">
<code>is_separable = True</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.output_dims">
<code>output_dims = 2</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.pass_through">
<code>pass_through = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.transform_non_affine">
<code>transform_non_affine(points)</code> </dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.input_dims" title="matplotlib.transforms.BlendedGenericTransform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.output_dims" title="matplotlib.transforms.BlendedGenericTransform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.input_dims" title="matplotlib.transforms.BlendedGenericTransform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.output_dims" title="matplotlib.transforms.BlendedGenericTransform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.CompositeAffine2D">
<code>class matplotlib.transforms.CompositeAffine2D(a, b, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A composite transform formed by applying transform <em>a</em> then transform <em>b</em>.</p> <p>This version is an optimization that handles the case where both <em>a</em> and <em>b</em> are 2D affines.</p> <p>Create a new composite transform that is the result of applying transform <em>a</em> then transform <em>b</em>.</p> <p>Both <em>a</em> and <em>b</em> must be instances of <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a>.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.composite_transform_factory" title="matplotlib.transforms.composite_transform_factory"><code>composite_transform_factory()</code></a> function instead, which can automatically choose the best kind of composite transform instance to create.</p> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeAffine2D.depth">
<code>depth</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeAffine2D.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.CompositeGenericTransform">
<code>class matplotlib.transforms.CompositeGenericTransform(a, b, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>A composite transform formed by applying transform <em>a</em> then transform <em>b</em>.</p> <p>This “generic” version can handle any two arbitrary transformations.</p> <p>Create a new composite transform that is the result of applying transform <em>a</em> then transform <em>b</em>.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.composite_transform_factory" title="matplotlib.transforms.composite_transform_factory"><code>composite_transform_factory()</code></a> function instead, which can automatically choose the best kind of composite transform instance to create.</p> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeGenericTransform.depth">
<code>depth</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.frozen">
<code>frozen()</code> </dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.get_affine">
<code>get_affine()</code> </dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeGenericTransform.has_inverse">
<code>has_inverse</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.inverted">
<code>inverted()</code> </dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeGenericTransform.is_affine">
<code>is_affine</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeGenericTransform.is_separable">
<code>is_separable</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeGenericTransform.pass_through">
<code>pass_through = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.transform_affine">
<code>transform_affine(points)</code> </dt> <dd>
<p>Performs only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.transform_non_affine">
<code>transform_non_affine(points)</code> </dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine">
<code>transform_path_non_affine(path)</code> </dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.IdentityTransform">
<code>class matplotlib.transforms.IdentityTransform(*args, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A special class that does one thing, the identity transform, in a fast way.</p> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.frozen">
<code>frozen()</code> </dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.get_affine">
<code>get_affine()</code> </dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.inverted">
<code>inverted()</code> </dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform">
<code>transform(points)</code> </dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform_affine">
<code>transform_affine(points)</code> </dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform_non_affine">
<code>transform_non_affine(points)</code> </dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform_path">
<code>transform_path(path)</code> </dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform_path_affine">
<code>transform_path_affine(path)</code> </dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform_path_non_affine">
<code>transform_path_non_affine(path)</code> </dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.LockableBbox">
<code>class matplotlib.transforms.LockableBbox(bbox, x0=None, y0=None, x1=None, y1=None, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>matplotlib.transforms.BboxBase</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> where some elements may be locked at certain values.</p> <p>When the child bounding box changes, the bounds of this bbox will update accordingly with the exception of the locked elements.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>bbox</strong> : Bbox</p>  <p>The child bounding box to wrap.</p>  <p><strong>x0</strong> : float or None</p>  <p>The locked value for x0, or None to leave unlocked.</p>  <p><strong>y0</strong> : float or None</p>  <p>The locked value for y0, or None to leave unlocked.</p>  <p><strong>x1</strong> : float or None</p>  <p>The locked value for x1, or None to leave unlocked.</p>  <p><strong>y1</strong> : float or None</p>  <p>The locked value for y1, or None to leave unlocked.</p>  </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.transforms.LockableBbox.get_points">
<code>get_points()</code> </dt> <dd>
<p>Get the points of the bounding box directly as a numpy array of the form: [[x0, y0], [x1, y1]].</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.LockableBbox.locked_x0">
<code>locked_x0</code> </dt> <dd>
<p>float or None: The value used for the locked x0.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.LockableBbox.locked_x1">
<code>locked_x1</code> </dt> <dd>
<p>float or None: The value used for the locked x1.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.LockableBbox.locked_y0">
<code>locked_y0</code> </dt> <dd>
<p>float or None: The value used for the locked y0.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.LockableBbox.locked_y1">
<code>locked_y1</code> </dt> <dd>
<p>float or None: The value used for the locked y1.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.ScaledTranslation">
<code>class matplotlib.transforms.ScaledTranslation(xt, yt, scale_trans, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A transformation that translates by <em>xt</em> and <em>yt</em>, after <em>xt</em> and <em>yt</em> have been transformad by the given transform <em>scale_trans</em>.</p> <dl class="method"> <dt id="matplotlib.transforms.ScaledTranslation.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.Transform">
<code>class matplotlib.transforms.Transform(shorthand_name=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>matplotlib.transforms.TransformNode</code></a></p> <p>The base class of all <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> instances that actually perform a transformation.</p> <p>All non-affine transformations should be subclasses of this class. New affine transformations should be subclasses of <a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a>.</p> <p>Subclasses of this class should override the following members (at minimum):</p>  <ul class="simple"> <li><a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a></li> <li><a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a></li> <li><a class="reference internal" href="#matplotlib.transforms.Transform.transform" title="matplotlib.transforms.Transform.transform"><code>transform()</code></a></li> <li><a class="reference internal" href="#matplotlib.transforms.Transform.is_separable" title="matplotlib.transforms.Transform.is_separable"><code>is_separable</code></a></li> <li><a class="reference internal" href="#matplotlib.transforms.Transform.has_inverse" title="matplotlib.transforms.Transform.has_inverse"><code>has_inverse</code></a></li> <li>
<a class="reference internal" href="#matplotlib.transforms.Transform.inverted" title="matplotlib.transforms.Transform.inverted"><code>inverted()</code></a> (if <a class="reference internal" href="#matplotlib.transforms.Transform.has_inverse" title="matplotlib.transforms.Transform.has_inverse"><code>has_inverse</code></a> is True)</li> </ul>  <p>If the transform needs to do something non-standard with <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>matplotlib.path.Path</code></a> objects, such as adding curves where there were once line segments, it should override:</p>  <ul class="simple"> <li><a class="reference internal" href="#matplotlib.transforms.Transform.transform_path" title="matplotlib.transforms.Transform.transform_path"><code>transform_path()</code></a></li> </ul>  <p>Creates a new <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a>.</p> <dl class="docutils"> <dt>
<strong>shorthand_name</strong> - a string representing the “name” of this</dt> <dd>transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</dd> </dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.contains_branch">
<code>contains_branch(other)</code> </dt> <dd>
<p>Return whether the given transform is a sub-tree of this transform.</p> <p>This routine uses transform equality to identify sub-trees, therefore in many situations it is object id which will be used.</p> <p>For the case where the given transform represents the whole of this transform, returns True.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.contains_branch_seperately">
<code>contains_branch_seperately(other_transform)</code> </dt> <dd>
<p>Returns whether the given branch is a sub-tree of this transform on each seperate dimension.</p> <p>A common use for this method is to identify if a transform is a blended transform containing an axes’ data transform. e.g.:</p> <pre data-language="python">x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)
</pre> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Transform.depth">
<code>depth</code> </dt> <dd>
<p>Returns the number of transforms which have been chained together to form this Transform instance.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">For the special case of a Composite transform, the maximum depth of the two is returned.</p> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.get_affine">
<code>get_affine()</code> </dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Transform.has_inverse">
<code>has_inverse = False</code> </dt> <dd>
<p>True if this transform has a corresponding inverse transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Transform.input_dims">
<code>input_dims = None</code> </dt> <dd>
<p>The number of input dimensions of this transform. Must be overridden (with integers) in the subclass.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.inverted">
<code>inverted()</code> </dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Transform.is_separable">
<code>is_separable = False</code> </dt> <dd>
<p>True if this transform is separable in the x- and y- dimensions.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Transform.output_dims">
<code>output_dims = None</code> </dt> <dd>
<p>The number of output dimensions of this transform. Must be overridden (with integers) in the subclass.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform">
<code>transform(values)</code> </dt> <dd>
<p>Performs the transformation on the given array of values.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_affine">
<code>transform_affine(values)</code> </dt> <dd>
<p>Performs only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_angles">
<code>transform_angles(angles, pts, radians=False, pushoff=1e-05)</code> </dt> <dd>
<p>Performs transformation on a set of angles anchored at specific locations.</p> <p>The <em>angles</em> must be a column vector (i.e., numpy array).</p> <p>The <em>pts</em> must be a two-column numpy array of x,y positions (angle transforms currently only work in 2D). This array must have the same number of rows as <em>angles</em>.</p> <dl class="docutils"> <dt>
<em>radians</em> indicates whether or not input angles are given in</dt> <dd>radians (True) or degrees (False; the default).</dd> <dt>
<em>pushoff</em> is the distance to move away from <em>pts</em> for</dt> <dd>determining transformed angles (see discussion of method below).</dd> </dl> <p>The transformed angles are returned in an array with the same size as <em>angles</em>.</p> <p>The generic version of this method uses a very generic algorithm that transforms <em>pts</em>, as well as locations very close to <em>pts</em>, to find the angle in the transformed system.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_bbox">
<code>transform_bbox(bbox)</code> </dt> <dd>
<p>Transform the given bounding box.</p> <p>Note, for smarter transforms including caching (a common requirement for matplotlib figures), see <a class="reference internal" href="#matplotlib.transforms.TransformedBbox" title="matplotlib.transforms.TransformedBbox"><code>TransformedBbox</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_non_affine">
<code>transform_non_affine(values)</code> </dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_path">
<code>transform_path(path)</code> </dt> <dd>
<p>Returns a transformed path.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p>In some cases, this transform may insert curves into the path that began as line segments.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_path_affine">
<code>transform_path_affine(path)</code> </dt> <dd>
<p>Returns a path, transformed only by the affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_path_non_affine">
<code>transform_path_non_affine(path)</code> </dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_point">
<code>transform_point(point)</code> </dt> <dd>
<p>A convenience function that returns the transformed copy of a single point.</p> <p>The point is given as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>. The transformed point is returned as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.TransformNode">
<code>class matplotlib.transforms.TransformNode(shorthand_name=None)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> is the base class for anything that participates in the transform tree and needs to invalidate its parents or be invalidated. This includes classes that are not really transforms, such as bounding boxes, since some transforms depend on bounding boxes to compute their values.</p> <p>Creates a new <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a>.</p> <dl class="docutils"> <dt>
<strong>shorthand_name</strong> - a string representing the “name” of this</dt> <dd>transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</dd> </dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.INVALID">
<code>INVALID = 3</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.INVALID_AFFINE">
<code>INVALID_AFFINE = 2</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.INVALID_NON_AFFINE">
<code>INVALID_NON_AFFINE = 1</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformNode.frozen">
<code>frozen()</code> </dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformNode.invalidate">
<code>invalidate()</code> </dt> <dd>
<p>Invalidate this <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> and triggers an invalidation of its ancestors. Should be called any time the transform changes.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.is_affine">
<code>is_affine = False</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.is_bbox">
<code>is_bbox = False</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.pass_through">
<code>pass_through = False</code> </dt> <dd>
<p>If pass_through is True, all ancestors will always be invalidated, even if ‘self’ is already invalid.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformNode.set_children">
<code>set_children(*children)</code> </dt> <dd>
<p>Set the children of the transform, to let the invalidation system know which transforms can invalidate this transform. Should be called from the constructor of any transforms that depend on other transforms.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.TransformWrapper">
<code>class matplotlib.transforms.TransformWrapper(child)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>A helper class that holds a single child transform and acts equivalently to it.</p> <p>This is useful if a node of the transform tree must be replaced at run time with a transform of a different type. This class allows that replacement to correctly trigger invalidation.</p> <p>Note that <a class="reference internal" href="#matplotlib.transforms.TransformWrapper" title="matplotlib.transforms.TransformWrapper"><code>TransformWrapper</code></a> instances must have the same input and output dimensions during their entire lifetime, so the child transform may only be replaced with another child transform of the same dimensions.</p> <p><em>child</em>: A class:<a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance. This child may later be replaced with <a class="reference internal" href="#matplotlib.transforms.TransformWrapper.set" title="matplotlib.transforms.TransformWrapper.set"><code>set()</code></a>.</p> <dl class="method"> <dt id="matplotlib.transforms.TransformWrapper.frozen">
<code>frozen()</code> </dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformWrapper.has_inverse">
<code>has_inverse</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformWrapper.is_affine">
<code>is_affine</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformWrapper.is_separable">
<code>is_separable</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformWrapper.pass_through">
<code>pass_through = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformWrapper.set">
<code>set(child)</code> </dt> <dd>
<p>Replace the current child of this transform with another one.</p> <p>The new child must have the same number of input and output dimensions as the current child.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.TransformedBbox">
<code>class matplotlib.transforms.TransformedBbox(bbox, transform, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>matplotlib.transforms.BboxBase</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> that is automatically transformed by a given transform. When either the child bounding box or transform changes, the bounds of this bbox will update accordingly.</p> <p><em>bbox</em>: a child <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a></p> <p><em>transform</em>: a 2D <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a></p> <dl class="method"> <dt id="matplotlib.transforms.TransformedBbox.get_points">
<code>get_points()</code> </dt> <dd>
<p>Get the points of the bounding box directly as a numpy array of the form: [[x0, y0], [x1, y1]].</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.TransformedPatchPath">
<code>class matplotlib.transforms.TransformedPatchPath(patch)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>matplotlib.transforms.TransformedPath</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.TransformedPatchPath" title="matplotlib.transforms.TransformedPatchPath"><code>TransformedPatchPath</code></a> caches a non-affine transformed copy of the <code>Patch</code>. This cached copy is automatically updated when the non-affine part of the transform or the patch changes.</p> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.TransformedPatchPath" title="matplotlib.transforms.TransformedPatchPath"><code>TransformedPatchPath</code></a> from the given <code>Patch</code>.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.TransformedPath">
<code>class matplotlib.transforms.TransformedPath(path, transform)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>matplotlib.transforms.TransformNode</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>TransformedPath</code></a> caches a non-affine transformed copy of the <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>. This cached copy is automatically updated when the non-affine part of the transform changes.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Paths are considered immutable by this class. Any update to the path’s vertices/codes will not trigger a transform recomputation.</p> </div> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>TransformedPath</code></a> from the given <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> and <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>.</p> <dl class="method"> <dt id="matplotlib.transforms.TransformedPath.get_affine">
<code>get_affine()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformedPath.get_fully_transformed_path">
<code>get_fully_transformed_path()</code> </dt> <dd>
<p>Return a fully-transformed copy of the child path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformedPath.get_transformed_path_and_affine">
<code>get_transformed_path_and_affine()</code> </dt> <dd>
<p>Return a copy of the child path, with the non-affine part of the transform already applied, along with the affine part of the path necessary to complete the transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformedPath.get_transformed_points_and_affine">
<code>get_transformed_points_and_affine()</code> </dt> <dd>
<p>Return a copy of the child path, with the non-affine part of the transform already applied, along with the affine part of the path necessary to complete the transformation. Unlike <a class="reference internal" href="#matplotlib.transforms.TransformedPath.get_transformed_path_and_affine" title="matplotlib.transforms.TransformedPath.get_transformed_path_and_affine"><code>get_transformed_path_and_affine()</code></a>, no interpolation will be performed.</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.transforms.blended_transform_factory">
<code>matplotlib.transforms.blended_transform_factory(x_transform, y_transform)</code> </dt> <dd>
<p>Create a new “blended” transform using <em>x_transform</em> to transform the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p> <p>A faster version of the blended transform is returned for the case where both child transforms are affine.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.transforms.composite_transform_factory">
<code>matplotlib.transforms.composite_transform_factory(a, b)</code> </dt> <dd>
<p>Create a new composite transform that is the result of applying transform a then transform b.</p> <p>Shortcut versions of the blended transform are provided for the case where both child transforms are affine, or one or the other is the identity transform.</p> <p>Composite transforms may also be created using the ‘+’ operator, e.g.:</p> <pre data-language="python">c = a + b
</pre> </dd>
</dl> <dl class="function"> <dt id="matplotlib.transforms.interval_contains">
<code>matplotlib.transforms.interval_contains(interval, val)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.transforms.interval_contains_open">
<code>matplotlib.transforms.interval_contains_open(interval, val)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.transforms.nonsingular">
<code>matplotlib.transforms.nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True)</code> </dt> <dd>
<p>Modify the endpoints of a range as needed to avoid singularities.</p> <dl class="docutils"> <dt>
<em>vmin</em>, <em>vmax</em>
</dt> <dd>the initial endpoints.</dd> <dt><em>tiny</em></dt> <dd>threshold for the ratio of the interval to the maximum absolute value of its endpoints. If the interval is smaller than this, it will be expanded. This value should be around 1e-15 or larger; otherwise the interval will be approaching the double precision resolution limit.</dd> <dt><em>expander</em></dt> <dd>fractional amount by which <em>vmin</em> and <em>vmax</em> are expanded if the original interval is too small, based on <em>tiny</em>.</dd> <dt>
<em>increasing</em>: [True | False]</dt> <dd>If True (default), swap <em>vmin</em>, <em>vmax</em> if <em>vmin</em> &gt; <em>vmax</em>
</dd> </dl> <p>Returns <em>vmin</em>, <em>vmax</em>, expanded and/or swapped if necessary.</p> <p>If either input is inf or NaN, or if both inputs are 0 or very close to zero, it returns -<em>expander</em>, <em>expander</em>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.transforms.offset_copy">
<code>matplotlib.transforms.offset_copy(trans, fig=None, x=0.0, y=0.0, units='inches')</code> </dt> <dd>
<dl class="docutils"> <dt>Return a new transform with an added offset.</dt> <dd>
<dl class="first last docutils"> <dt>args:</dt> <dd>trans is any transform</dd> <dt>kwargs:</dt> <dd>fig is the current figure; it can be None if units are ‘dots’ x, y give the offset units is ‘inches’, ‘points’ or ‘dots’</dd> </dl> </dd> </dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/2.1.0/api/transformations.html" class="_attribution-link" target="_blank">http://matplotlib.org/2.1.0/api/transformations.html</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
