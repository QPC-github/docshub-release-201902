
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Contour - Matplotlib 2.1 - W3cubDocs</title>
  
  <meta name="description" content=" These are classes to support contour plotting and labelling for the Axes class. ">
  <meta name="keywords" content="contour, -, matplotlib, matplotlib~2.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~2.1/contour_api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/matplotlib~2.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~2.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 2.1</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1 id="contour">contour</h1>  <h2 id="matplotlib-contour">matplotlib.contour</h2> <p id="module-matplotlib.contour">These are classes to support contour plotting and labelling for the Axes class.</p> <dl class="class"> <dt id="matplotlib.contour.ClabelText">
<code>class matplotlib.contour.ClabelText(x=0, y=0, text='', color=None, verticalalignment='baseline', horizontalalignment='left', multialignment=None, fontproperties=None, rotation=None, linespacing=None, rotation_mode=None, usetex=None, wrap=False, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>matplotlib.text.Text</code></a></p> <p>Unlike the ordinary text, the get_rotation returns an updated angle in the pixel coordinate assuming that the input rotation is an angle in data coordinate (or whatever transform set).</p> <p>Create a <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>Text</code></a> instance at <em>x</em>, <em>y</em> with string <em>text</em>.</p> <p>Valid kwargs are</p>  <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Property</th> <th class="head">Description</th> </tr> </thead>  <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_agg_filter/#matplotlib.artist.Artist.set_agg_filter" title="matplotlib.artist.Artist.set_agg_filter"><code>agg_filter</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_alpha/#matplotlib.artist.Artist.set_alpha" title="matplotlib.artist.Artist.set_alpha"><code>alpha</code></a></td> <td>float (0.0 transparent through 1.0 opaque)</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_animated/#matplotlib.artist.Artist.set_animated" title="matplotlib.artist.Artist.set_animated"><code>animated</code></a></td> <td>[True | False]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_backgroundcolor" title="matplotlib.text.Text.set_backgroundcolor"><code>backgroundcolor</code></a></td> <td>any matplotlib color</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_bbox" title="matplotlib.text.Text.set_bbox"><code>bbox</code></a></td> <td>FancyBboxPatch prop dict</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_clip_box" title="matplotlib.text.Text.set_clip_box"><code>clip_box</code></a></td> <td>a <a class="reference internal" href="../transformations/#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>matplotlib.transforms.Bbox</code></a> instance</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_clip_on" title="matplotlib.text.Text.set_clip_on"><code>clip_on</code></a></td> <td>[True | False]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_clip_path" title="matplotlib.text.Text.set_clip_path"><code>clip_path</code></a></td> <td>[ (<a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="../_as_gen/matplotlib.patches.patch/#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None ]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_color" title="matplotlib.text.Text.set_color"><code>color</code></a></td> <td>any matplotlib color</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_contains/#matplotlib.artist.Artist.set_contains" title="matplotlib.artist.Artist.set_contains"><code>contains</code></a></td> <td>a callable function</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_family" title="matplotlib.text.Text.set_family"><code>family</code></a> or fontfamily or fontname or name</td> <td>[FONTNAME | ‘serif’ | ‘sans-serif’ | ‘cursive’ | ‘fantasy’ | ‘monospace’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_figure/#matplotlib.artist.Artist.set_figure" title="matplotlib.artist.Artist.set_figure"><code>figure</code></a></td> <td>a <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a> instance</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_fontproperties" title="matplotlib.text.Text.set_fontproperties"><code>fontproperties</code></a> or font_properties</td> <td>a <a class="reference internal" href="../font_manager_api/#matplotlib.font_manager.FontProperties" title="matplotlib.font_manager.FontProperties"><code>matplotlib.font_manager.FontProperties</code></a> instance</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_gid/#matplotlib.artist.Artist.set_gid" title="matplotlib.artist.Artist.set_gid"><code>gid</code></a></td> <td>an id string</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_horizontalalignment" title="matplotlib.text.Text.set_horizontalalignment"><code>horizontalalignment</code></a> or ha</td> <td>[ ‘center’ | ‘right’ | ‘left’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_label/#matplotlib.artist.Artist.set_label" title="matplotlib.artist.Artist.set_label"><code>label</code></a></td> <td>string or anything printable with ‘%s’ conversion.</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_linespacing" title="matplotlib.text.Text.set_linespacing"><code>linespacing</code></a></td> <td>float (multiple of font size)</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_multialignment" title="matplotlib.text.Text.set_multialignment"><code>multialignment</code></a></td> <td>[‘left’ | ‘right’ | ‘center’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_path_effects/#matplotlib.artist.Artist.set_path_effects" title="matplotlib.artist.Artist.set_path_effects"><code>path_effects</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_picker/#matplotlib.artist.Artist.set_picker" title="matplotlib.artist.Artist.set_picker"><code>picker</code></a></td> <td>[None|float|boolean|callable]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_position" title="matplotlib.text.Text.set_position"><code>position</code></a></td> <td>(x,y)</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_rasterized/#matplotlib.artist.Artist.set_rasterized" title="matplotlib.artist.Artist.set_rasterized"><code>rasterized</code></a></td> <td>[True | False | None]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_rotation" title="matplotlib.text.Text.set_rotation"><code>rotation</code></a></td> <td>[ angle in degrees | ‘vertical’ | ‘horizontal’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_rotation_mode" title="matplotlib.text.Text.set_rotation_mode"><code>rotation_mode</code></a></td> <td>unknown</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_size" title="matplotlib.text.Text.set_size"><code>size</code></a> or fontsize</td> <td>[size in points | ‘xx-small’ | ‘x-small’ | ‘small’ | ‘medium’ | ‘large’ | ‘x-large’ | ‘xx-large’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_sketch_params/#matplotlib.artist.Artist.set_sketch_params" title="matplotlib.artist.Artist.set_sketch_params"><code>sketch_params</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_snap/#matplotlib.artist.Artist.set_snap" title="matplotlib.artist.Artist.set_snap"><code>snap</code></a></td> <td>unknown</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_stretch" title="matplotlib.text.Text.set_stretch"><code>stretch</code></a> or fontstretch</td> <td>[a numeric value in range 0-1000 | ‘ultra-condensed’ | ‘extra-condensed’ | ‘condensed’ | ‘semi-condensed’ | ‘normal’ | ‘semi-expanded’ | ‘expanded’ | ‘extra-expanded’ | ‘ultra-expanded’ ]</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_style" title="matplotlib.text.Text.set_style"><code>style</code></a> or fontstyle</td> <td>[ ‘normal’ | ‘italic’ | ‘oblique’]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_text" title="matplotlib.text.Text.set_text"><code>text</code></a></td> <td>string or anything printable with ‘%s’ conversion.</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_transform/#matplotlib.artist.Artist.set_transform" title="matplotlib.artist.Artist.set_transform"><code>transform</code></a></td> <td>
<a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_url/#matplotlib.artist.Artist.set_url" title="matplotlib.artist.Artist.set_url"><code>url</code></a></td> <td>a url string</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_usetex" title="matplotlib.text.Text.set_usetex"><code>usetex</code></a></td> <td>unknown</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_variant" title="matplotlib.text.Text.set_variant"><code>variant</code></a> or fontvariant</td> <td>[ ‘normal’ | ‘small-caps’ ]</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_verticalalignment" title="matplotlib.text.Text.set_verticalalignment"><code>verticalalignment</code></a> or ma or va</td> <td>[ ‘center’ | ‘top’ | ‘bottom’ | ‘baseline’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_visible/#matplotlib.artist.Artist.set_visible" title="matplotlib.artist.Artist.set_visible"><code>visible</code></a></td> <td>[True | False]</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_weight" title="matplotlib.text.Text.set_weight"><code>weight</code></a> or fontweight</td> <td>[a numeric value in range 0-1000 | ‘ultralight’ | ‘light’ | ‘normal’ | ‘regular’ | ‘book’ | ‘medium’ | ‘roman’ | ‘semibold’ | ‘demibold’ | ‘demi’ | ‘bold’ | ‘heavy’ | ‘extra bold’ | ‘black’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_wrap" title="matplotlib.text.Text.set_wrap"><code>wrap</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_x" title="matplotlib.text.Text.set_x"><code>x</code></a></td> <td>float</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_y" title="matplotlib.text.Text.set_y"><code>y</code></a></td> <td>float</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_zorder/#matplotlib.artist.Artist.set_zorder" title="matplotlib.artist.Artist.set_zorder"><code>zorder</code></a></td> <td>any number</td> </tr>  </table>  <dl class="method"> <dt id="matplotlib.contour.ClabelText.get_rotation">
<code>get_rotation()</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.contour.ContourLabeler">
<code>class matplotlib.contour.ContourLabeler</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Mixin to provide labelling capability to ContourSet</p> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.add_label">
<code>add_label(x, y, rotation, lev, cvalue)</code> </dt> <dd>
<p>Add contour label using <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>Text</code></a> class.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.add_label_clabeltext">
<code>add_label_clabeltext(x, y, rotation, lev, cvalue)</code> </dt> <dd>
<p>Add contour label using <a class="reference internal" href="#matplotlib.contour.ClabelText" title="matplotlib.contour.ClabelText"><code>ClabelText</code></a> class.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.add_label_near">
<code>add_label_near(x, y, inline=True, inline_spacing=5, transform=None)</code> </dt> <dd>
<p>Add a label near the point (x, y). If transform is None (default), (x, y) is in data coordinates; if transform is False, (x, y) is in display coordinates; otherwise, the specified transform will be used to translate (x, y) into display coordinates.</p> <dl class="docutils"> <dt>
<em>inline</em>:</dt> <dd>controls whether the underlying contour is removed or not. Default is <em>True</em>.</dd> <dt>
<em>inline_spacing</em>:</dt> <dd>space in pixels to leave on each side of label when placing inline. Defaults to 5. This spacing will be exact for labels at locations where the contour is straight, less so for labels on curved contours.</dd> </dl> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.calc_label_rot_and_inline">
<code>calc_label_rot_and_inline(slc, ind, lw, lc=None, spacing=5)</code> </dt> <dd>
<p>This function calculates the appropriate label rotation given the linecontour coordinates in screen units, the index of the label location and the label width.</p> <p>It will also break contour and calculate inlining if <em>lc</em> is not empty (lc defaults to the empty list if None). <em>spacing</em> is the space around the label in pixels to leave empty.</p> <p>Do both of these tasks at once to avoid calling mlab.path_length multiple times, which is relatively costly.</p> <p>The method used here involves calculating the path length along the contour in pixel coordinates and then looking approximately label width / 2 away from central point to determine rotation and then to break contour if desired.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.clabel">
<code>clabel(*args, **kwargs)</code> </dt> <dd>
<p>Label a contour plot.</p> <p>Call signature:</p> <pre data-language="python">clabel(cs, **kwargs)
</pre> <p>Adds labels to line contours in <em>cs</em>, where <em>cs</em> is a <a class="reference internal" href="#matplotlib.contour.ContourSet" title="matplotlib.contour.ContourSet"><code>ContourSet</code></a> object returned by contour.</p> <pre data-language="python">clabel(cs, v, **kwargs)
</pre> <p>only labels contours listed in <em>v</em>.</p> <p>Optional keyword arguments:</p>  <dl class="docutils"> <dt>
<em>fontsize</em>:</dt> <dd>size in points or relative size e.g., ‘smaller’, ‘x-large’</dd> <dt>
<em>colors</em>:</dt> <dd>
<ul class="first last simple"> <li>if <em>None</em>, the color of each label matches the color of the corresponding contour</li> <li>if one string color, e.g., <em>colors</em> = ‘r’ or <em>colors</em> = ‘red’, all labels will be plotted in this color</li> <li>if a tuple of matplotlib color args (string, float, rgb, etc), different labels will be plotted in different colors in the order specified</li> </ul> </dd> <dt>
<em>inline</em>:</dt> <dd>controls whether the underlying contour is removed or not. Default is <em>True</em>.</dd> <dt>
<em>inline_spacing</em>:</dt> <dd>space in pixels to leave on each side of label when placing inline. Defaults to 5. This spacing will be exact for labels at locations where the contour is straight, less so for labels on curved contours.</dd> <dt>
<em>fmt</em>:</dt> <dd>a format string for the label. Default is ‘%1.3f’ Alternatively, this can be a dictionary matching contour levels with arbitrary strings to use for each contour level (i.e., fmt[level]=string), or it can be any callable, such as a <a class="reference internal" href="../ticker_api/#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>Formatter</code></a> instance, that returns a string when called with a numeric contour level.</dd> <dt>
<em>manual</em>:</dt> <dd>
<p class="first">if <em>True</em>, contour labels will be placed manually using mouse clicks. Click the first button near a contour to add a label, click the second button (or potentially both mouse buttons at once) to finish adding labels. The third button can be used to remove the last label added, but only if labels are not inline. Alternatively, the keyboard can be used to select label locations (enter to end label placement, delete or backspace act like the third mouse button, and any other key will select a label location).</p> <p class="last"><em>manual</em> can be an iterable object of x,y tuples. Contour labels will be created as if mouse is clicked at each x,y positions.</p> </dd> <dt>
<em>rightside_up</em>:</dt> <dd>if <em>True</em> (default), label rotations will always be plus or minus 90 degrees from level.</dd> <dt>
<em>use_clabeltext</em>:</dt> <dd>if <em>True</em> (default is False), ClabelText class (instead of matplotlib.Text) is used to create labels. ClabelText recalculates rotation angles of texts during the drawing time, therefore this can be used if aspect of the axes changes.</dd> </dl>  </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.get_label_coords">
<code>get_label_coords(distances, XX, YY, ysize, lw)</code> </dt> <dd>
<p>Return x, y, and the index of a label location.</p> <p>Labels are plotted at a location with the smallest deviation of the contour from a straight line unless there is another label nearby, in which case the next best place on the contour is picked up. If all such candidates are rejected, the beginning of the contour is chosen.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.get_label_width">
<code>get_label_width(lev, fmt, fsize)</code> </dt> <dd>
<p>Return the width of the label in points.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.get_real_label_width">
<code>get_real_label_width(lev, fmt, fsize)</code> </dt> <dd>
<p>This computes actual onscreen label width. This uses some black magic to determine onscreen extent of non-drawn label. This magic may not be very robust.</p> <p>This method is not being used, and may be modified or removed.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.get_text">
<code>get_text(lev, fmt)</code> </dt> <dd>
<p>get the text of the label</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.labels">
<code>labels(inline, inline_spacing)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.locate_label">
<code>locate_label(linecontour, labelwidth)</code> </dt> <dd>
<p>Find a good place to plot a label (relatively flat part of the contour).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.pop_label">
<code>pop_label(index=-1)</code> </dt> <dd>
<p>Defaults to removing last label, but any index can be supplied</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.print_label">
<code>print_label(linecontour, labelwidth)</code> </dt> <dd>
<p>Return <em>False</em> if contours are too short for a label.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.set_label_props">
<code>set_label_props(label, text, color)</code> </dt> <dd>
<p>set the label properties - color, fontsize, text</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourLabeler.too_close">
<code>too_close(x, y, lw)</code> </dt> <dd>
<p>Return <em>True</em> if a label is already near this location.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.contour.ContourSet">
<code>class matplotlib.contour.ContourSet(ax, *args, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../cm_api/#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code>matplotlib.cm.ScalarMappable</code></a>, <a class="reference internal" href="#matplotlib.contour.ContourLabeler" title="matplotlib.contour.ContourLabeler"><code>matplotlib.contour.ContourLabeler</code></a></p> <p>Store a set of contour lines or filled regions.</p> <p>User-callable method: clabel</p> <dl class="docutils"> <dt>Useful attributes:</dt> <dd>
<dl class="first last docutils"> <dt>ax:</dt> <dd>The axes object in which the contours are drawn</dd> <dt>collections:</dt> <dd>a silent_list of LineCollections or PolyCollections</dd> <dt>levels:</dt> <dd>contour levels</dd> <dt>layers:</dt> <dd>same as levels for line contours; half-way between levels for filled contours. See <code>_process_colors()</code>.</dd> </dl> </dd> </dl> <p>Draw contour lines or filled regions, depending on whether keyword arg ‘filled’ is <em>False</em> (default) or <em>True</em>.</p> <p>The first three arguments must be:</p>  <p><em>ax</em>: axes object.</p> <dl class="docutils"> <dt>
<em>levels</em>: [level0, level1, …, leveln]</dt> <dd>A list of floating point numbers indicating the contour levels.</dd> <dt>
<em>allsegs</em>: [level0segs, level1segs, …]</dt> <dd>
<p class="first">List of all the polygon segments for all the <em>levels</em>. For contour lines <code>len(allsegs) == len(levels)</code>, and for filled contour regions <code>len(allsegs) = len(levels)-1</code>.</p> <p>level0segs = [polygon0, polygon1, …]</p> <p class="last">polygon0 = array_like [[x0,y0], [x1,y1], …]</p> </dd> <dt>
<em>allkinds</em>: <em>None</em> or [level0kinds, level1kinds, …]</dt> <dd>
<p class="first">Optional list of all the polygon vertex kinds (code types), as described and used in Path. This is used to allow multiply- connected paths such as holes within filled polygons. If not <em>None</em>, len(allkinds) == len(allsegs).</p> <p>level0kinds = [polygon0kinds, …]</p> <p>polygon0kinds = [vertexcode0, vertexcode1, …]</p> <p>If <em>allkinds</em> is not <em>None</em>, usually all polygons for a particular contour level are grouped together so that</p> <p class="last">level0segs = [polygon0] and level0kinds = [polygon0kinds].</p> </dd> </dl>  <p>Keyword arguments are as described in <a class="reference internal" href="#matplotlib.contour.QuadContourSet.contour_doc" title="matplotlib.contour.QuadContourSet.contour_doc"><code>matplotlib.contour.QuadContourSet.contour_doc</code></a>.</p> <dl class="method"> <dt id="matplotlib.contour.ContourSet.changed">
<code>changed()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourSet.find_nearest_contour">
<code>find_nearest_contour(x, y, indices=None, pixel=True)</code> </dt> <dd>
<p>Finds contour that is closest to a point. Defaults to measuring distance in pixels (screen space - useful for manual contour labeling), but this can be controlled via a keyword argument.</p> <p>Returns a tuple containing the contour, segment, index of segment, x &amp; y of segment point and distance to minimum point.</p> <p>Optional keyword arguments:</p>  <dl class="docutils"> <dt>
<em>indices</em>:</dt> <dd>Indexes of contour levels to consider when looking for nearest point. Defaults to using all levels.</dd> <dt>
<em>pixel</em>:</dt> <dd>If <em>True</em>, measure distance in pixel space, if not, measure distance in axes space. Defaults to <em>True</em>.</dd> </dl>  </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourSet.get_alpha">
<code>get_alpha()</code> </dt> <dd>
<p>returns alpha to be applied to all ContourSet artists</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourSet.get_transform">
<code>get_transform()</code> </dt> <dd>
<p>Return the <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance used by this ContourSet.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourSet.legend_elements">
<code>legend_elements(variable_name='x', str_format=&lt;class 'str'&gt;)</code> </dt> <dd>
<p>Return a list of artist and labels suitable for passing through to <code>plt.legend()</code> which represent this ContourSet.</p> <p>Args:</p>  <dl class="docutils"> <dt>
<em>variable_name</em>: the string used inside the inequality used</dt> <dd>on the labels</dd> </dl> <p><em>str_format</em>: function used to format the numbers in the labels</p>  </dd>
</dl> <dl class="method"> <dt id="matplotlib.contour.ContourSet.set_alpha">
<code>set_alpha(alpha)</code> </dt> <dd>
<p>sets alpha for all ContourSet artists</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.contour.ContourSet.vmax">
<code>vmax</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.contour.ContourSet.vmin">
<code>vmin</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.contour.QuadContourSet">
<code>class matplotlib.contour.QuadContourSet(ax, *args, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.contour.ContourSet" title="matplotlib.contour.ContourSet"><code>matplotlib.contour.ContourSet</code></a></p> <p>Create and store a set of contour lines or filled regions.</p> <p>User-callable method: <code>clabel()</code></p> <dl class="docutils"> <dt>Useful attributes:</dt> <dd>
<dl class="first last docutils"> <dt>ax:</dt> <dd>The axes object in which the contours are drawn</dd> <dt>collections:</dt> <dd>A silent_list of LineCollections or PolyCollections</dd> <dt>levels:</dt> <dd>Contour levels</dd> <dt>layers:</dt> <dd>Same as levels for line contours; half-way between levels for filled contours. See <code>_process_colors()</code> method.</dd> </dl> </dd> </dl> <p>Draw contour lines or filled regions, depending on whether keyword arg ‘filled’ is <em>False</em> (default) or <em>True</em>.</p> <p>The first three arguments must be:</p>  <p><em>ax</em>: axes object.</p> <dl class="docutils"> <dt>
<em>levels</em>: [level0, level1, …, leveln]</dt> <dd>A list of floating point numbers indicating the contour levels.</dd> <dt>
<em>allsegs</em>: [level0segs, level1segs, …]</dt> <dd>
<p class="first">List of all the polygon segments for all the <em>levels</em>. For contour lines <code>len(allsegs) == len(levels)</code>, and for filled contour regions <code>len(allsegs) = len(levels)-1</code>.</p> <p>level0segs = [polygon0, polygon1, …]</p> <p class="last">polygon0 = array_like [[x0,y0], [x1,y1], …]</p> </dd> <dt>
<em>allkinds</em>: <em>None</em> or [level0kinds, level1kinds, …]</dt> <dd>
<p class="first">Optional list of all the polygon vertex kinds (code types), as described and used in Path. This is used to allow multiply- connected paths such as holes within filled polygons. If not <em>None</em>, len(allkinds) == len(allsegs).</p> <p>level0kinds = [polygon0kinds, …]</p> <p>polygon0kinds = [vertexcode0, vertexcode1, …]</p> <p>If <em>allkinds</em> is not <em>None</em>, usually all polygons for a particular contour level are grouped together so that</p> <p class="last">level0segs = [polygon0] and level0kinds = [polygon0kinds].</p> </dd> </dl>  <p>Keyword arguments are as described in <a class="reference internal" href="#matplotlib.contour.QuadContourSet.contour_doc" title="matplotlib.contour.QuadContourSet.contour_doc"><code>matplotlib.contour.QuadContourSet.contour_doc</code></a>.</p> <dl class="attribute"> <dt id="matplotlib.contour.QuadContourSet.contour_doc">
<code>contour_doc = "\n Plot contours.\n\n :func:`~matplotlib.pyplot.contour` and\n :func:`~matplotlib.pyplot.contourf` draw contour lines and\n filled contours, respectively. Except as noted, function\n signatures and return values are the same for both versions.\n\n :func:`~matplotlib.pyplot.contourf` differs from the MATLAB\n version in that it does not draw the polygon edges.\n To draw edges, add line contours with\n calls to :func:`~matplotlib.pyplot.contour`.\n\n\n Call signatures::\n\n contour(Z)\n\n make a contour plot of an array *Z*. The level values are chosen\n automatically.\n\n ::\n\n contour(X,Y,Z)\n\n *X*, *Y* specify the (x, y) coordinates of the surface\n\n ::\n\n contour(Z,N)\n contour(X,Y,Z,N)\n\n contour up to *N* automatically-chosen levels.\n\n ::\n\n contour(Z,V)\n contour(X,Y,Z,V)\n\n draw contour lines at the values specified in sequence *V*,\n which must be in increasing order.\n\n ::\n\n contourf(..., V)\n\n fill the ``len(V)-1`` regions between the values in *V*,\n which must be in increasing order.\n\n ::\n\n contour(Z, **kwargs)\n\n Use keyword args to control colors, linewidth, origin, cmap ... see\n below for more details.\n\n *X* and *Y* must both be 2-D with the same shape as *Z*, or they\n must both be 1-D such that ``len(X)`` is the number of columns in\n *Z* and ``len(Y)`` is the number of rows in *Z*.\n\n ``C = contour(...)`` returns a\n :class:`~matplotlib.contour.QuadContourSet` object.\n\n Optional keyword arguments:\n\n *corner_mask*: [ *True* | *False* | 'legacy' ]\n Enable/disable corner masking, which only has an effect if *Z* is\n a masked array. If *False*, any quad touching a masked point is\n masked out. If *True*, only the triangular corners of quads\n nearest those points are always masked out, other triangular\n corners comprising three unmasked points are contoured as usual.\n If 'legacy', the old contouring algorithm is used, which is\n equivalent to *False* and is deprecated, only remaining whilst the\n new algorithm is tested fully.\n\n If not specified, the default is taken from\n rcParams['contour.corner_mask'], which is True unless it has\n been modified.\n\n *colors*: [ *None* | string | (mpl_colors) ]\n If *None*, the colormap specified by cmap will be used.\n\n If a string, like 'r' or 'red', all levels will be plotted in this\n color.\n\n If a tuple of matplotlib color args (string, float, rgb, etc),\n different levels will be plotted in different colors in the order\n specified.\n\n *alpha*: float\n The alpha blending value\n\n *cmap*: [ *None* | Colormap ]\n A cm :class:`~matplotlib.colors.Colormap` instance or\n *None*. If *cmap* is *None* and *colors* is *None*, a\n default Colormap is used.\n\n *norm*: [ *None* | Normalize ]\n A :class:`matplotlib.colors.Normalize` instance for\n scaling data values to colors. If *norm* is *None* and\n *colors* is *None*, the default linear scaling is used.\n\n *vmin*, *vmax*: [ *None* | scalar ]\n If not *None*, either or both of these values will be\n supplied to the :class:`matplotlib.colors.Normalize`\n instance, overriding the default color scaling based on\n *levels*.\n\n *levels*: [level0, level1, ..., leveln]\n A list of floating point numbers indicating the level\n curves to draw, in increasing order; e.g., to draw just\n the zero contour pass ``levels=[0]``\n\n *origin*: [ *None* | 'upper' | 'lower' | 'image' ]\n If *None*, the first value of *Z* will correspond to the\n lower left corner, location (0,0). If 'image', the rc\n value for ``image.origin`` will be used.\n\n This keyword is not active if *X* and *Y* are specified in\n the call to contour.\n\n *extent*: [ *None* | (x0,x1,y0,y1) ]\n\n If *origin* is not *None*, then *extent* is interpreted as\n in :func:`matplotlib.pyplot.imshow`: it gives the outer\n pixel boundaries. In this case, the position of Z[0,0]\n is the center of the pixel, not a corner. If *origin* is\n *None*, then (*x0*, *y0*) is the position of Z[0,0], and\n (*x1*, *y1*) is the position of Z[-1,-1].\n\n This keyword is not active if *X* and *Y* are specified in\n the call to contour.\n\n *locator*: [ *None* | ticker.Locator subclass ]\n If *locator* is *None*, the default\n :class:`~matplotlib.ticker.MaxNLocator` is used. The\n locator is used to determine the contour levels if they\n are not given explicitly via the *V* argument.\n\n *extend*: [ 'neither' | 'both' | 'min' | 'max' ]\n Unless this is 'neither', contour levels are automatically\n added to one or both ends of the range so that all data\n are included. These added ranges are then mapped to the\n special colormap values which default to the ends of the\n colormap range, but can be set via\n :meth:`matplotlib.colors.Colormap.set_under` and\n :meth:`matplotlib.colors.Colormap.set_over` methods.\n\n *xunits*, *yunits*: [ *None* | registered units ]\n Override axis units by specifying an instance of a\n :class:`matplotlib.units.ConversionInterface`.\n\n *antialiased*: [ *True* | *False* ]\n enable antialiasing, overriding the defaults. For\n filled contours, the default is *True*. For line contours,\n it is taken from rcParams['lines.antialiased'].\n\n *nchunk*: [ 0 | integer ]\n If 0, no subdivision of the domain. Specify a positive integer to\n divide the domain into subdomains of *nchunk* by *nchunk* quads.\n Chunking reduces the maximum length of polygons generated by the\n contouring algorithm which reduces the rendering workload passed\n on to the backend and also requires slightly less RAM. It can\n however introduce rendering artifacts at chunk boundaries depending\n on the backend, the *antialiased* flag and value of *alpha*.\n\n contour-only keyword arguments:\n\n *linewidths*: [ *None* | number | tuple of numbers ]\n If *linewidths* is *None*, the default width in\n ``lines.linewidth`` in ``matplotlibrc`` is used.\n\n If a number, all levels will be plotted with this linewidth.\n\n If a tuple, different levels will be plotted with different\n linewidths in the order specified.\n\n *linestyles*: [ *None* | 'solid' | 'dashed' | 'dashdot' | 'dotted' ]\n If *linestyles* is *None*, the default is 'solid' unless\n the lines are monochrome. In that case, negative\n contours will take their linestyle from the ``matplotlibrc``\n ``contour.negative_linestyle`` setting.\n\n *linestyles* can also be an iterable of the above strings\n specifying a set of linestyles to be used. If this\n iterable is shorter than the number of contour levels\n it will be repeated as necessary.\n\n contourf-only keyword arguments:\n\n *hatches*:\n A list of cross hatch patterns to use on the filled areas.\n If None, no hatching will be added to the contour.\n Hatching is supported in the PostScript, PDF, SVG and Agg\n backends only.\n\n\n Note: contourf fills intervals that are closed at the top; that\n is, for boundaries *z1* and *z2*, the filled region is::\n\n z1 &lt; z &lt;= z2\n\n There is one exception: if the lowest boundary coincides with\n the minimum value of the *z* array, then that minimum value\n will be included in the lowest interval.\n "</code> </dt> 
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/2.1.0/api/contour_api.html" class="_attribution-link" target="_blank">http://matplotlib.org/2.1.0/api/contour_api.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
