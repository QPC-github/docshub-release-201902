
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Legend and Legend_handler - Matplotlib 2.1 - W3cubDocs</title>
  
  <meta name="description" content=" The legend module defines the Legend class, which is responsible for drawing legends associated with axes and&#47;or figures. ">
  <meta name="keywords" content="legend, and, handler, -, matplotlib, matplotlib~2.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~2.1/legend_api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/matplotlib~2.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~2.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 2.1</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
				
<h1 id="legend-and-legend-handler">legend and legend_handler</h1>  <h2 id="matplotlib-legend">matplotlib.legend</h2> <p id="module-matplotlib.legend">The legend module defines the Legend class, which is responsible for drawing legends associated with axes and/or figures.</p> <div class="admonition important"> <p class="first admonition-title">Important</p> <p class="last">It is unlikely that you would ever create a Legend instance manually. Most users would normally create a legend via the <a class="reference internal" href="../_as_gen/matplotlib.axes.axes.legend/#matplotlib.axes.Axes.legend" title="matplotlib.axes.Axes.legend"><code>legend()</code></a> function. For more details on legends there is also a <a class="reference internal" href="http://matplotlib.org/2.1.0/tutorials/intermediate/legend_guide.html#sphx-glr-tutorials-intermediate-legend-guide-py" target="_blank"><span class="std std-ref">legend guide</span></a>.</p> </div> <p>The Legend class can be considered as a container of legend handles and legend texts. Creation of corresponding legend handles from the plot elements in the axes or figures (e.g., lines, patches, etc.) are specified by the handler map, which defines the mapping between the plot elements and the legend handlers to be used (the default legend handlers are defined in the <a class="reference internal" href="#module-matplotlib.legend_handler" title="matplotlib.legend_handler"><code>legend_handler</code></a> module). Note that not all kinds of artist are supported by the legend yet by default but it is possible to extend the legend handler’s capabilities to support arbitrary objects. See the <a class="reference internal" href="http://matplotlib.org/2.1.0/tutorials/intermediate/legend_guide.html#sphx-glr-tutorials-intermediate-legend-guide-py" target="_blank"><span class="std std-ref">legend guide</span></a> for more information.</p> <dl class="class"> <dt id="matplotlib.legend.DraggableLegend">
<code>class matplotlib.legend.DraggableLegend(legend, use_blit=False, update='loc')</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../offsetbox_api/#matplotlib.offsetbox.DraggableOffsetBox" title="matplotlib.offsetbox.DraggableOffsetBox"><code>matplotlib.offsetbox.DraggableOffsetBox</code></a></p> <dl class="docutils"> <dt>
<code>update : If “loc”, update loc parameter of</code> </dt> <dd>legend upon finalizing. If “bbox”, update <em>bbox_to_anchor</em> parameter.</dd> </dl> <dl class="method"> <dt id="matplotlib.legend.DraggableLegend.artist_picker">
<code>artist_picker(legend, evt)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend.DraggableLegend.finalize_offset">
<code>finalize_offset()</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend.Legend">
<code>class matplotlib.legend.Legend(parent, handles, labels, loc=None, numpoints=None, markerscale=None, markerfirst=True, scatterpoints=None, scatteryoffsets=None, prop=None, fontsize=None, borderpad=None, labelspacing=None, handlelength=None, handleheight=None, handletextpad=None, borderaxespad=None, columnspacing=None, ncol=1, mode=None, fancybox=None, shadow=None, title=None, framealpha=None, edgecolor=None, facecolor=None, bbox_to_anchor=None, bbox_transform=None, frameon=None, handler_map=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../artist_api/#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>matplotlib.artist.Artist</code></a></p> <p>Place a legend on the axes at location loc. Labels are a sequence of strings and loc can be a string or an integer specifying the legend location</p> <p>The location codes are:</p> <pre data-language="python">'best'         : 0, (only implemented for axes legends)
'upper right'  : 1,
'upper left'   : 2,
'lower left'   : 3,
'lower right'  : 4,
'right'        : 5, (same as 'center right', for back-compatibility)
'center left'  : 6,
'center right' : 7,
'lower center' : 8,
'upper center' : 9,
'center'       : 10,
</pre> <p>loc can be a tuple of the normalized coordinate values with respect its parent.</p> <ul class="simple"> <li>
<em>parent</em>: the artist that contains the legend</li> <li>
<dl class="first docutils"> <dt>
<em>handles</em>: a list of artists (lines, patches) to be added to the</dt> <dd>legend</dd> </dl> </li> <li>
<em>labels</em>: a list of strings to label the legend</li> </ul> <p>Optional keyword arguments:</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Keyword</th> <th class="head">Description</th> </tr> </thead>  <tr>
<td>loc</td> <td>Location code string, or tuple (see below).</td> </tr> <tr>
<td>prop</td> <td>the font property</td> </tr> <tr>
<td>fontsize</td> <td>the font size (used only if prop is not specified)</td> </tr> <tr>
<td>markerscale</td> <td>the relative size of legend markers vs. original</td> </tr> <tr>
<td>markerfirst</td> <td>If True (default), marker is to left of the label.</td> </tr> <tr>
<td>numpoints</td> <td>the number of points in the legend for line</td> </tr> <tr>
<td>scatterpoints</td> <td>the number of points in the legend for scatter plot</td> </tr> <tr>
<td>scatteryoffsets</td> <td>a list of yoffsets for scatter symbols in legend</td> </tr> <tr>
<td>frameon</td> <td>If True, draw the legend on a patch (frame).</td> </tr> <tr>
<td>fancybox</td> <td>If True, draw the frame with a round fancybox.</td> </tr> <tr>
<td>shadow</td> <td>If True, draw a shadow behind legend.</td> </tr> <tr>
<td>framealpha</td> <td>Transparency of the frame.</td> </tr> <tr>
<td>edgecolor</td> <td>Frame edgecolor.</td> </tr> <tr>
<td>facecolor</td> <td>Frame facecolor.</td> </tr> <tr>
<td>ncol</td> <td>number of columns</td> </tr> <tr>
<td>borderpad</td> <td>the fractional whitespace inside the legend border</td> </tr> <tr>
<td>labelspacing</td> <td>the vertical space between the legend entries</td> </tr> <tr>
<td>handlelength</td> <td>the length of the legend handles</td> </tr> <tr>
<td>handleheight</td> <td>the height of the legend handles</td> </tr> <tr>
<td>handletextpad</td> <td>the pad between the legend handle and text</td> </tr> <tr>
<td>borderaxespad</td> <td>the pad between the axes and legend border</td> </tr> <tr>
<td>columnspacing</td> <td>the spacing between columns</td> </tr> <tr>
<td>title</td> <td>the legend title</td> </tr> <tr>
<td>bbox_to_anchor</td> <td>the bbox that the legend will be anchored.</td> </tr> <tr>
<td>bbox_transform</td> <td>the transform for the bbox. transAxes if None.</td> </tr>  </table> <p>The pad and spacing parameters are measured in font-size units. e.g., a fontsize of 10 points and a handlelength=5 implies a handlelength of 50 points. Values from rcParams will be used if None.</p> <p>Users can specify any arbitrary location for the legend using the <em>bbox_to_anchor</em> keyword argument. bbox_to_anchor can be an instance of BboxBase(or its derivatives) or a tuple of 2 or 4 floats. See <a class="reference internal" href="#matplotlib.legend.Legend.set_bbox_to_anchor" title="matplotlib.legend.Legend.set_bbox_to_anchor"><code>set_bbox_to_anchor()</code></a> for more detail.</p> <p>The legend location can be specified by setting <em>loc</em> with a tuple of 2 floats, which is interpreted as the lower-left corner of the legend in the normalized axes coordinate.</p> <dl class="attribute"> <dt id="matplotlib.legend.Legend.codes">
<code>codes = {'best': 0, 'upper right': 1, 'upper left': 2, 'lower left': 3, 'lower right': 4, 'right': 5, 'center left': 6, 'center right': 7, 'lower center': 8, 'upper center': 9, 'center': 10}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.contains">
<code>contains(event)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.draggable">
<code>draggable(state=None, use_blit=False, update='loc')</code> </dt> <dd>
<p>Set the draggable state – if state is</p>  <ul class="simple"> <li>None : toggle the current state</li> <li>True : turn draggable on</li> <li>False : turn draggable off</li> </ul>  <p>If draggable is on, you can drag the legend on the canvas with the mouse. The DraggableLegend helper instance is returned if draggable is on.</p> <p>The update parameter control which parameter of the legend changes when dragged. If update is “loc”, the <em>loc</em> parameter of the legend is changed. If “bbox”, the <em>bbox_to_anchor</em> parameter is changed.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.draw">
<code>draw(renderer)</code> </dt> <dd>
<p>Draw everything that belongs to the legend</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.draw_frame">
<code>draw_frame(b)</code> </dt> <dd>
<p>b is a boolean. Set draw frame to b</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.get_bbox_to_anchor">
<code>get_bbox_to_anchor()</code> </dt> <dd>
<p>return the bbox that the legend will be anchored</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.get_children">
<code>get_children()</code> </dt> <dd>
<p>return a list of child artists</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.legend.Legend.get_default_handler_map">
<code>classmethod get_default_handler_map()</code> </dt> <dd>
<p>A class method that returns the default handler map.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.get_frame">
<code>get_frame()</code> </dt> <dd>
<p>return the Rectangle instance used to frame the legend</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.get_frame_on">
<code>get_frame_on()</code> </dt> <dd>
<p>Get whether the legend box patch is drawn</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.legend.Legend.get_legend_handler">
<code>static get_legend_handler(legend_handler_map, orig_handle)</code> </dt> <dd>
<p>return a legend handler from <em>legend_handler_map</em> that corresponds to <em>orig_handler</em>.</p> <p><em>legend_handler_map</em> should be a dictionary object (that is returned by the get_legend_handler_map method).</p> <p>It first checks if the <em>orig_handle</em> itself is a key in the <em>legend_hanler_map</em> and return the associated value. Otherwise, it checks for each of the classes in its method-resolution-order. If no matching key is found, it returns None.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.get_legend_handler_map">
<code>get_legend_handler_map()</code> </dt> <dd>
<p>return the handler map.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.get_lines">
<code>get_lines()</code> </dt> <dd>
<p>return a list of lines.Line2D instances in the legend</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.get_patches">
<code>get_patches()</code> </dt> <dd>
<p>return a list of patch instances in the legend</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.get_texts">
<code>get_texts()</code> </dt> <dd>
<p>return a list of text.Text instance in the legend</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.get_title">
<code>get_title()</code> </dt> <dd>
<p>return Text instance for the legend title</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.get_window_extent">
<code>get_window_extent(*args, **kwargs)</code> </dt> <dd>
<p>return a extent of the legend</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.set_bbox_to_anchor">
<code>set_bbox_to_anchor(bbox, transform=None)</code> </dt> <dd>
<p>set the bbox that the legend will be anchored.</p> <p><em>bbox</em> can be a BboxBase instance, a tuple of [left, bottom, width, height] in the given transform (normalized axes coordinate if None), or a tuple of [left, bottom] where the width and height will be assumed to be zero.</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.legend.Legend.set_default_handler_map">
<code>classmethod set_default_handler_map(handler_map)</code> </dt> <dd>
<p>A class method to set the default handler map.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.set_frame_on">
<code>set_frame_on(b)</code> </dt> <dd>
<p>Set whether the legend box patch is drawn</p> <p>ACCEPTS: [ <em>True</em> | <em>False</em> ]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend.Legend.set_title">
<code>set_title(title, prop=None)</code> </dt> <dd>
<p>set the legend title. Fontproperties can be optionally set with <em>prop</em> parameter.</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.legend.Legend.update_default_handler_map">
<code>classmethod update_default_handler_map(handler_map)</code> </dt> <dd>
<p>A class method to update the default handler map.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.legend.Legend.zorder">
<code>zorder = 5</code> </dt> 
</dl> </dd>
</dl>   <h2 id="matplotlib-legend-handler">matplotlib.legend_handler</h2> <p id="module-matplotlib.legend_handler">This module defines default legend handlers.</p> <p>It is strongly encouraged to have read the <a class="reference internal" href="http://matplotlib.org/2.1.0/tutorials/intermediate/legend_guide.html#sphx-glr-tutorials-intermediate-legend-guide-py" target="_blank"><span class="std std-ref">legend guide</span></a> before this documentation.</p> <p>Legend handlers are expected to be a callable object with a following signature.</p> <pre data-language="python">legend_handler(legend, orig_handle, fontsize, handlebox)
</pre> <p>Where <em>legend</em> is the legend itself, <em>orig_handle</em> is the original plot, <em>fontsize</em> is the fontsize in pixles, and <em>handlebox</em> is a OffsetBox instance. Within the call, you should create relevant artists (using relevant properties from the <em>legend</em> and/or <em>orig_handle</em>) and add them into the handlebox. The artists needs to be scaled according to the fontsize (note that the size is in pixel, i.e., this is dpi-scaled value).</p> <p>This module includes definition of several legend handler classes derived from the base class (HandlerBase) with the following method.</p>  def legend_artist(self, legend, orig_handle, fontsize, handlebox): <dl class="class"> <dt id="matplotlib.legend_handler.HandlerBase">
<code>class matplotlib.legend_handler.HandlerBase(xpad=0.0, ypad=0.0, update_func=None)</code> </dt> <dd>
<p>A Base class for default legend handlers.</p> <p>The derived classes are meant to override <em>create_artists</em> method, which has a following signature.:</p> <pre data-language="python">def create_artists(self, legend, orig_handle,
                   xdescent, ydescent, width, height, fontsize,
                   trans):
</pre> <p>The overridden method needs to create artists of the given transform that fits in the given dimension (xdescent, ydescent, width, height) that are scaled by fontsize if necessary.</p> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerBase.adjust_drawing_area">
<code>adjust_drawing_area(legend, orig_handle, xdescent, ydescent, width, height, fontsize)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerBase.create_artists">
<code>create_artists(legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerBase.legend_artist">
<code>legend_artist(legend, orig_handle, fontsize, handlebox)</code> </dt> <dd>
<p>Return the artist that this HandlerBase generates for the given original artist/handle.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>legend</strong> : <a class="reference internal" href="#matplotlib.legend.Legend" title="matplotlib.legend.Legend"><code>matplotlib.legend.Legend</code></a> instance</p>  <p>The legend for which these legend artists are being created.</p>  <p><strong>orig_handle</strong> : <a class="reference internal" href="../artist_api/#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>matplotlib.artist.Artist</code></a> or similar</p>  <p>The object for which these legend artists are being created.</p>  <p><strong>fontsize</strong> : float or int</p>  <p>The fontsize in pixels. The artists being created should be scaled according to the given fontsize.</p>  <p><strong>handlebox</strong> : <a class="reference internal" href="../offsetbox_api/#matplotlib.offsetbox.OffsetBox" title="matplotlib.offsetbox.OffsetBox"><code>matplotlib.offsetbox.OffsetBox</code></a> instance</p>  <p>The box which has been created to hold this legend entry’s artists. Artists created in the <a class="reference internal" href="#matplotlib.legend_handler.HandlerBase.legend_artist" title="matplotlib.legend_handler.HandlerBase.legend_artist"><code>legend_artist</code></a> method must be added to this handlebox inside this method.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerBase.update_prop">
<code>update_prop(legend_handle, orig_handle, legend)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerCircleCollection">
<code>class matplotlib.legend_handler.HandlerCircleCollection(yoffsets=None, sizes=None, **kw)</code> </dt> <dd>
<p>Handler for CircleCollections</p> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerCircleCollection.create_collection">
<code>create_collection(orig_handle, sizes, offsets, transOffset)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerErrorbar">
<code>class matplotlib.legend_handler.HandlerErrorbar(xerr_size=0.5, yerr_size=None, marker_pad=0.3, numpoints=None, **kw)</code> </dt> <dd>
<p>Handler for Errorbars</p> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerErrorbar.create_artists">
<code>create_artists(legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerErrorbar.get_err_size">
<code>get_err_size(legend, xdescent, ydescent, width, height, fontsize)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerLine2D">
<code>class matplotlib.legend_handler.HandlerLine2D(marker_pad=0.3, numpoints=None, **kw)</code> </dt> <dd>
<p>Handler for Line2D instances.</p> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerLine2D.create_artists">
<code>create_artists(legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerLineCollection">
<code>class matplotlib.legend_handler.HandlerLineCollection(marker_pad=0.3, numpoints=None, **kw)</code> </dt> <dd>
<p>Handler for LineCollection instances.</p> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerLineCollection.create_artists">
<code>create_artists(legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerLineCollection.get_numpoints">
<code>get_numpoints(legend)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerNpoints">
<code>class matplotlib.legend_handler.HandlerNpoints(marker_pad=0.3, numpoints=None, **kw)</code> </dt> <dd>
<dl class="method"> <dt id="matplotlib.legend_handler.HandlerNpoints.get_numpoints">
<code>get_numpoints(legend)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerNpoints.get_xdata">
<code>get_xdata(legend, xdescent, ydescent, width, height, fontsize)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerNpointsYoffsets">
<code>class matplotlib.legend_handler.HandlerNpointsYoffsets(numpoints=None, yoffsets=None, **kw)</code> </dt> <dd>
<dl class="method"> <dt id="matplotlib.legend_handler.HandlerNpointsYoffsets.get_ydata">
<code>get_ydata(legend, xdescent, ydescent, width, height, fontsize)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerPatch">
<code>class matplotlib.legend_handler.HandlerPatch(patch_func=None, **kw)</code> </dt> <dd>
<p>Handler for Patch instances.</p> <p>The HandlerPatch class optionally takes a function <code>patch_func</code> who’s responsibility is to create the legend key artist. The <code>patch_func</code> should have the signature:</p> <pre data-language="python">def patch_func(legend=legend, orig_handle=orig_handle,
               xdescent=xdescent, ydescent=ydescent,
               width=width, height=height, fontsize=fontsize)
</pre> <p>Subsequently the created artist will have its <code>update_prop</code> method called and the appropriate transform will be applied.</p> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerPatch.create_artists">
<code>create_artists(legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerPathCollection">
<code>class matplotlib.legend_handler.HandlerPathCollection(yoffsets=None, sizes=None, **kw)</code> </dt> <dd>
<p>Handler for PathCollections, which are used by scatter</p> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerPathCollection.create_collection">
<code>create_collection(orig_handle, sizes, offsets, transOffset)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerPolyCollection">
<code>class matplotlib.legend_handler.HandlerPolyCollection(xpad=0.0, ypad=0.0, update_func=None)</code> </dt> <dd>
<p>Handler for PolyCollection used in fill_between and stackplot.</p> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerPolyCollection.create_artists">
<code>create_artists(legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerRegularPolyCollection">
<code>class matplotlib.legend_handler.HandlerRegularPolyCollection(yoffsets=None, sizes=None, **kw)</code> </dt> <dd>
<p>Handler for RegularPolyCollections.</p> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerRegularPolyCollection.create_artists">
<code>create_artists(legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerRegularPolyCollection.create_collection">
<code>create_collection(orig_handle, sizes, offsets, transOffset)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerRegularPolyCollection.get_numpoints">
<code>get_numpoints(legend)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerRegularPolyCollection.get_sizes">
<code>get_sizes(legend, orig_handle, xdescent, ydescent, width, height, fontsize)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerRegularPolyCollection.update_prop">
<code>update_prop(legend_handle, orig_handle, legend)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerStem">
<code>class matplotlib.legend_handler.HandlerStem(marker_pad=0.3, numpoints=None, bottom=None, yoffsets=None, **kw)</code> </dt> <dd>
<p>Handler for Errorbars</p> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerStem.create_artists">
<code>create_artists(legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerStem.get_ydata">
<code>get_ydata(legend, xdescent, ydescent, width, height, fontsize)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.legend_handler.HandlerTuple">
<code>class matplotlib.legend_handler.HandlerTuple(ndivide=1, pad=None, **kwargs)</code> </dt> <dd>
<p>Handler for Tuple.</p> <p>Additional kwargs are passed through to <a class="reference internal" href="#matplotlib.legend_handler.HandlerBase" title="matplotlib.legend_handler.HandlerBase"><code>HandlerBase</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>ndivide</strong> : int, optional</p>  <p>The number of sections to divide the legend area into. If None, use the length of the input tuple. Default is 1.</p>  <p><strong>pad</strong> : float, optional</p>  <p>If None, fall back to <code>legend.borderpad</code> as the default. In units of fraction of font size. Default is None.</p>  </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.legend_handler.HandlerTuple.create_artists">
<code>create_artists(legend, orig_handle, xdescent, ydescent, width, height, fontsize, trans)</code> </dt> 
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.legend_handler.update_from_first_child">
<code>matplotlib.legend_handler.update_from_first_child(tgt, src)</code> </dt> 
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/2.1.0/api/legend_api.html" class="_attribution-link" target="_blank">http://matplotlib.org/2.1.0/api/legend_api.html</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
