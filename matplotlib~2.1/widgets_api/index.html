
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Widgets - Matplotlib 2.1 - W3cubDocs</title>
  
  <meta name="description" content="Widgets that are designed to work for any of the GUI backends. All of these widgets require you to predefine a matplotlib.axes.Axes instance and &hellip;">
  <meta name="keywords" content="widgets, -, matplotlib, matplotlib~2.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~2.1/widgets_api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/matplotlib~2.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~2.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 2.1</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1 id="widgets">widgets</h1>  <h2 id="matplotlib-widgets">matplotlib.widgets</h2>  <h3 id="module-matplotlib.widgets">GUI neutral widgets</h3> <p>Widgets that are designed to work for any of the GUI backends. All of these widgets require you to predefine a <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a> instance and pass that as the first arg. matplotlib doesn’t try to be too smart with respect to layout – you will have to figure out how wide and tall you want your Axes to be to accommodate your widget.</p> <dl class="class"> <dt id="matplotlib.widgets.AxesWidget">
<code>class matplotlib.widgets.AxesWidget(ax)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.widgets.Widget" title="matplotlib.widgets.Widget"><code>matplotlib.widgets.Widget</code></a></p> <p>Widget that is connected to a single <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a>.</p> <p>To guarantee that the widget remains responsive and not garbage-collected, a reference to the object should be maintained by the user.</p> <p>This is necessary because the callback registry maintains only weak-refs to the functions, which are member functions of the widget. If there are no references to the widget object it may be garbage collected which will disconnect the callbacks.</p> <p>Attributes:</p> <dl class="docutils"> <dt>
<code>ax : Axes</code> </dt> <dd>The parent axes for the widget</dd> <dt>
<code>canvas : FigureCanvasBase subclass</code> </dt> <dd>The parent figure canvas for the widget.</dd> <dt>
<code>active : bool</code> </dt> <dd>If False, the widget does not respond to events.</dd> </dl> <dl class="method"> <dt id="matplotlib.widgets.AxesWidget.connect_event">
<code>connect_event(event, callback)</code> </dt> <dd>
<p>Connect callback with an event.</p> <p>This should be used in lieu of <code>figure.canvas.mpl_connect</code> since this function stores callback ids for later clean up.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.AxesWidget.disconnect_events">
<code>disconnect_events()</code> </dt> <dd>
<p>Disconnect all events created by this widget.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.Button">
<code>class matplotlib.widgets.Button(ax, label, image=None, color='0.85', hovercolor='0.95')</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.widgets.AxesWidget" title="matplotlib.widgets.AxesWidget"><code>matplotlib.widgets.AxesWidget</code></a></p> <p>A GUI neutral button.</p> <p>For the button to remain responsive you must keep a reference to it.</p> <p>The following attributes are accessible</p>  <dl class="docutils"> <dt><em>ax</em></dt> <dd>The <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a> the button renders into.</dd> <dt><em>label</em></dt> <dd>A <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>matplotlib.text.Text</code></a> instance.</dd> <dt><em>color</em></dt> <dd>The color of the button when not hovering.</dd> <dt><em>hovercolor</em></dt> <dd>The color of the button when hovering.</dd> </dl>  <p>Call <a class="reference internal" href="#matplotlib.widgets.Button.on_clicked" title="matplotlib.widgets.Button.on_clicked"><code>on_clicked()</code></a> to connect to the button</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>ax</strong> : matplotlib.axes.Axes</p>  <p>The <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a> instance the button will be placed into.</p>  <p><strong>label</strong> : str</p>  <p>The button text. Accepts string.</p>  <p><strong>image</strong> : array, mpl image, Pillow Image</p>  <p>The image to place in the button, if not <em>None</em>. Can be any legal arg to imshow (numpy array, matplotlib Image instance, or Pillow Image).</p>  <p><strong>color</strong> : color</p>  <p>The color of the button when not activated</p>  <p><strong>hovercolor</strong> : color</p>  <p>The color of the button when the mouse is over it</p>  </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.widgets.Button.disconnect">
<code>disconnect(cid)</code> </dt> <dd>
<p>remove the observer with connection id <em>cid</em></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.Button.on_clicked">
<code>on_clicked(func)</code> </dt> <dd>
<p>When the button is clicked, call this <em>func</em> with event.</p> <p>A connection id is returned. It can be used to disconnect the button from its callback.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.CheckButtons">
<code>class matplotlib.widgets.CheckButtons(ax, labels, actives)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.widgets.AxesWidget" title="matplotlib.widgets.AxesWidget"><code>matplotlib.widgets.AxesWidget</code></a></p> <p>A GUI neutral set of check buttons.</p> <p>For the check buttons to remain responsive you must keep a reference to this object.</p> <p>The following attributes are exposed</p>  <dl class="docutils"> <dt><em>ax</em></dt> <dd>The <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a> instance the buttons are located in</dd> <dt><em>labels</em></dt> <dd>List of <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>matplotlib.text.Text</code></a> instances</dd> <dt><em>lines</em></dt> <dd>List of (line1, line2) tuples for the x’s in the check boxes. These lines exist for each box, but have <code>set_visible(False)</code> when its box is not checked.</dd> <dt><em>rectangles</em></dt> <dd>List of <a class="reference internal" href="../_as_gen/matplotlib.patches.rectangle/#matplotlib.patches.Rectangle" title="matplotlib.patches.Rectangle"><code>matplotlib.patches.Rectangle</code></a> instances</dd> </dl>  <p>Connect to the CheckButtons with the <a class="reference internal" href="#matplotlib.widgets.CheckButtons.on_clicked" title="matplotlib.widgets.CheckButtons.on_clicked"><code>on_clicked()</code></a> method</p> <p>Add check buttons to <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a> instance <em>ax</em></p> <dl class="docutils"> <dt><em>labels</em></dt> <dd>A len(buttons) list of labels as strings</dd> <dt><em>actives</em></dt> <dd>
<dl class="first last docutils"> <dt>A len(buttons) list of booleans indicating whether</dt> <dd>the button is active</dd> </dl> </dd> </dl> <dl class="method"> <dt id="matplotlib.widgets.CheckButtons.disconnect">
<code>disconnect(cid)</code> </dt> <dd>
<p>remove the observer with connection id <em>cid</em></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.CheckButtons.get_status">
<code>get_status()</code> </dt> <dd>
<p>returns a tuple of the status (True/False) of all of the check buttons</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.CheckButtons.on_clicked">
<code>on_clicked(func)</code> </dt> <dd>
<p>When the button is clicked, call <em>func</em> with button label</p> <p>A connection id is returned which can be used to disconnect</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.CheckButtons.set_active">
<code>set_active(index)</code> </dt> <dd>
<p>Directly (de)activate a check button by index.</p> <dl class="docutils"> <dt>
<em>index</em> is an index into the original label list</dt> <dd>that this object was constructed with. Raises ValueError if <em>index</em> is invalid.</dd> </dl> <p>Callbacks will be triggered if <code>eventson</code> is True.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.Cursor">
<code>class matplotlib.widgets.Cursor(ax, horizOn=True, vertOn=True, useblit=False, **lineprops)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.widgets.AxesWidget" title="matplotlib.widgets.AxesWidget"><code>matplotlib.widgets.AxesWidget</code></a></p> <p>A horizontal and vertical line that spans the axes and moves with the pointer. You can turn off the hline or vline respectively with the following attributes:</p>  <dl class="docutils"> <dt><em>horizOn</em></dt> <dd>Controls the visibility of the horizontal line</dd> <dt><em>vertOn</em></dt> <dd>Controls the visibility of the horizontal line</dd> </dl>  <p>and the visibility of the cursor itself with the <em>visible</em> attribute.</p> <p>For the cursor to remain responsive you must keep a reference to it.</p> <p>Add a cursor to <em>ax</em>. If <code>useblit=True</code>, use the backend- dependent blitting features for faster updates (GTKAgg only for now). <em>lineprops</em> is a dictionary of line properties.</p> <dl class="method"> <dt id="matplotlib.widgets.Cursor.clear">
<code>clear(event)</code> </dt> <dd>
<p>clear the cursor</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.Cursor.onmove">
<code>onmove(event)</code> </dt> <dd>
<p>on mouse motion draw the cursor if visible</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.EllipseSelector">
<code>class matplotlib.widgets.EllipseSelector(ax, onselect, drawtype='box', minspanx=None, minspany=None, useblit=False, lineprops=None, rectprops=None, spancoords='data', button=None, maxdist=10, marker_props=None, interactive=False, state_modifier_keys=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.widgets.RectangleSelector" title="matplotlib.widgets.RectangleSelector"><code>matplotlib.widgets.RectangleSelector</code></a></p> <p>Select an elliptical region of an axes.</p> <p>For the cursor to remain responsive you must keep a reference to it.</p> <p>Example usage:</p> <pre data-language="python">from matplotlib.widgets import  EllipseSelector
from pylab import *

def onselect(eclick, erelease):
  'eclick and erelease are matplotlib events at press and release'
  print(' startposition : (%f, %f)' % (eclick.xdata, eclick.ydata))
  print(' endposition   : (%f, %f)' % (erelease.xdata, erelease.ydata))
  print(' used button   : ', eclick.button)

def toggle_selector(event):
    print(' Key pressed.')
    if event.key in ['Q', 'q'] and toggle_selector.ES.active:
        print(' EllipseSelector deactivated.')
        toggle_selector.RS.set_active(False)
    if event.key in ['A', 'a'] and not toggle_selector.ES.active:
        print(' EllipseSelector activated.')
        toggle_selector.ES.set_active(True)

x = arange(100)/(99.0)
y = sin(x)
fig = figure
ax = subplot(111)
ax.plot(x,y)

toggle_selector.ES = EllipseSelector(ax, onselect, drawtype='line')
connect('key_press_event', toggle_selector)
show()
</pre> <p>Create a selector in <em>ax</em>. When a selection is made, clear the span and call onselect with:</p> <pre data-language="python">onselect(pos_1, pos_2)
</pre> <p>and clear the drawn box/line. The <code>pos_1</code> and <code>pos_2</code> are arrays of length 2 containing the x- and y-coordinate.</p> <p>If <em>minspanx</em> is not <em>None</em> then events smaller than <em>minspanx</em> in x direction are ignored (it’s the same for y).</p> <p>The rectangle is drawn with <em>rectprops</em>; default:</p> <pre data-language="python">rectprops = dict(facecolor='red', edgecolor = 'black',
                 alpha=0.2, fill=True)
</pre> <p>The line is drawn with <em>lineprops</em>; default:</p> <pre data-language="python">lineprops = dict(color='black', linestyle='-',
                 linewidth = 2, alpha=0.5)
</pre> <p>Use <em>drawtype</em> if you want the mouse to draw a line, a box or nothing between click and actual position by setting</p> <p><code>drawtype = 'line'</code>, <code>drawtype='box'</code> or <code>drawtype = 'none'</code>.</p> <p><em>spancoords</em> is one of ‘data’ or ‘pixels’. If ‘data’, <em>minspanx</em> and <em>minspanx</em> will be interpreted in the same coordinates as the x and y axis. If ‘pixels’, they are in pixels.</p> <p><em>button</em> is a list of integers indicating which mouse buttons should be used for rectangle selection. You can also specify a single integer if only a single button is desired. Default is <em>None</em>, which does not limit which button can be used.</p> <dl class="docutils"> <dt>Note, typically:</dt> <dd>1 = left mouse button 2 = center mouse button (scroll wheel) 3 = right mouse button</dd> </dl> <p><em>interactive</em> will draw a set of handles and allow you interact with the widget after it is drawn.</p> <p><em>state_modifier_keys</em> are keyboard modifiers that affect the behavior of the widget.</p> <p>The defaults are: dict(move=’ ‘, clear=’escape’, square=’shift’, center=’ctrl’)</p> <p>Keyboard modifiers, which: ‘move’: Move the existing shape. ‘clear’: Clear the current shape. ‘square’: Makes the shape square. ‘center’: Make the initial point the center of the shape. ‘square’ and ‘center’ can be combined.</p> <dl class="method"> <dt id="matplotlib.widgets.EllipseSelector.draw_shape">
<code>draw_shape(extents)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.Lasso">
<code>class matplotlib.widgets.Lasso(ax, xy, callback=None, useblit=True)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.widgets.AxesWidget" title="matplotlib.widgets.AxesWidget"><code>matplotlib.widgets.AxesWidget</code></a></p> <p>Selection curve of an arbitrary shape.</p> <p>The selected path can be used in conjunction with <a class="reference internal" href="../path_api/#matplotlib.path.Path.contains_point" title="matplotlib.path.Path.contains_point"><code>contains_point()</code></a> to select data points from an image.</p> <p>Unlike <a class="reference internal" href="#matplotlib.widgets.LassoSelector" title="matplotlib.widgets.LassoSelector"><code>LassoSelector</code></a>, this must be initialized with a starting point <code>xy</code>, and the <a class="reference internal" href="#matplotlib.widgets.Lasso" title="matplotlib.widgets.Lasso"><code>Lasso</code></a> events are destroyed upon release.</p> <p>Parameters:</p> <dl class="docutils"> <dt>
<code>ax : Axes</code> </dt> <dd>The parent axes for the widget.</dd> <dt>
<code>xy : array</code> </dt> <dd>Coordinates of the start of the lasso.</dd> <dt>
<code>callback : function</code> </dt> <dd>Whenever the lasso is released, the <code>callback</code> function is called and passed the vertices of the selected path.</dd> </dl> <dl class="method"> <dt id="matplotlib.widgets.Lasso.onmove">
<code>onmove(event)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.Lasso.onrelease">
<code>onrelease(event)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.LassoSelector">
<code>class matplotlib.widgets.LassoSelector(ax, onselect=None, useblit=True, lineprops=None, button=None)</code> </dt> <dd>
<p>Bases: <code>matplotlib.widgets._SelectorWidget</code></p> <p>Selection curve of an arbitrary shape.</p> <p>For the selector to remain responsive you must keep a reference to it.</p> <p>The selected path can be used in conjunction with <a class="reference internal" href="../path_api/#matplotlib.path.Path.contains_point" title="matplotlib.path.Path.contains_point"><code>contains_point()</code></a> to select data points from an image.</p> <p>In contrast to <a class="reference internal" href="#matplotlib.widgets.Lasso" title="matplotlib.widgets.Lasso"><code>Lasso</code></a>, <a class="reference internal" href="#matplotlib.widgets.LassoSelector" title="matplotlib.widgets.LassoSelector"><code>LassoSelector</code></a> is written with an interface similar to <a class="reference internal" href="#matplotlib.widgets.RectangleSelector" title="matplotlib.widgets.RectangleSelector"><code>RectangleSelector</code></a> and <a class="reference internal" href="#matplotlib.widgets.SpanSelector" title="matplotlib.widgets.SpanSelector"><code>SpanSelector</code></a> and will continue to interact with the axes until disconnected.</p> <p>Parameters:</p> <dl class="docutils"> <dt>
<code>ax : Axes</code> </dt> <dd>The parent axes for the widget.</dd> <dt>
<code>onselect : function</code> </dt> <dd>Whenever the lasso is released, the <code>onselect</code> function is called and passed the vertices of the selected path.</dd> </dl> <p>Example usage:</p> <pre data-language="python">   ax = subplot(111)
   ax.plot(x,y)

   def onselect(verts):
       print(verts)
   lasso = LassoSelector(ax, onselect)

*button* is a list of integers indicating which mouse buttons should
   be used for rectangle selection.  You can also specify a single
   integer if only a single button is desired.  Default is *None*,
   which does not limit which button can be used.

   Note, typically:
    1 = left mouse button
    2 = center mouse button (scroll wheel)
    3 = right mouse button
</pre> <dl class="method"> <dt id="matplotlib.widgets.LassoSelector.onpress">
<code>onpress(event)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.LassoSelector.onrelease">
<code>onrelease(event)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.LockDraw">
<code>class matplotlib.widgets.LockDraw</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Some widgets, like the cursor, draw onto the canvas, and this is not desirable under all circumstances, like when the toolbar is in zoom-to-rect mode and drawing a rectangle. The module level “lock” allows someone to grab the lock and prevent other widgets from drawing. Use <code>matplotlib.widgets.lock(someobj)</code> to prevent other widgets from drawing while you’re interacting with the canvas.</p> <dl class="method"> <dt id="matplotlib.widgets.LockDraw.available">
<code>available(o)</code> </dt> <dd>
<p>drawing is available to <em>o</em></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.LockDraw.isowner">
<code>isowner(o)</code> </dt> <dd>
<p>Return True if <em>o</em> owns this lock</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.LockDraw.locked">
<code>locked()</code> </dt> <dd>
<p>Return True if the lock is currently held by an owner</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.LockDraw.release">
<code>release(o)</code> </dt> <dd>
<p>release the lock</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.MultiCursor">
<code>class matplotlib.widgets.MultiCursor(canvas, axes, useblit=True, horizOn=False, vertOn=True, **lineprops)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.widgets.Widget" title="matplotlib.widgets.Widget"><code>matplotlib.widgets.Widget</code></a></p> <p>Provide a vertical (default) and/or horizontal line cursor shared between multiple axes.</p> <p>For the cursor to remain responsive you must keep a reference to it.</p> <p>Example usage:</p> <pre data-language="python">from matplotlib.widgets import MultiCursor
from pylab import figure, show, np

t = np.arange(0.0, 2.0, 0.01)
s1 = np.sin(2*np.pi*t)
s2 = np.sin(4*np.pi*t)
fig = figure()
ax1 = fig.add_subplot(211)
ax1.plot(t, s1)

ax2 = fig.add_subplot(212, sharex=ax1)
ax2.plot(t, s2)

multi = MultiCursor(fig.canvas, (ax1, ax2), color='r', lw=1,
                    horizOn=False, vertOn=True)
show()
</pre> <dl class="method"> <dt id="matplotlib.widgets.MultiCursor.clear">
<code>clear(event)</code> </dt> <dd>
<p>clear the cursor</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.MultiCursor.connect">
<code>connect()</code> </dt> <dd>
<p>connect events</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.MultiCursor.disconnect">
<code>disconnect()</code> </dt> <dd>
<p>disconnect events</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.MultiCursor.onmove">
<code>onmove(event)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.PolygonSelector">
<code>class matplotlib.widgets.PolygonSelector(ax, onselect, useblit=False, lineprops=None, markerprops=None, vertex_select_radius=15)</code> </dt> <dd>
<p>Bases: <code>matplotlib.widgets._SelectorWidget</code></p> <p>Select a polygon region of an axes.</p> <p>Place vertices with each mouse click, and make the selection by completing the polygon (clicking on the first vertex). Hold the <em>ctrl</em> key and click and drag a vertex to reposition it (the <em>ctrl</em> key is not necessary if the polygon has already been completed). Hold the <em>shift</em> key and click and drag anywhere in the axes to move all vertices. Press the <em>esc</em> key to start a new polygon.</p> <p>For the selector to remain responsive you must keep a reference to it.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>ax</strong> : <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a></p>  <p>The parent axes for the widget.</p>  <p><strong>onselect</strong> : function</p>  <p>When a polygon is completed or modified after completion, the <code>onselect</code> function is called and passed a list of the vertices as <code>(xdata, ydata)</code> tuples.</p>  <p><strong>useblit</strong> : bool, optional</p> <p><strong>lineprops</strong> : dict, optional</p>  <p>The line for the sides of the polygon is drawn with the properties given by <code>lineprops</code>. The default is <code>dict(color='k', linestyle='-',
linewidth=2, alpha=0.5)</code>.</p>  <p><strong>markerprops</strong> : dict, optional</p>  <p>The markers for the vertices of the polygon are drawn with the properties given by <code>markerprops</code>. The default is <code>dict(marker='o',
markersize=7, mec='k', mfc='k', alpha=0.5)</code>.</p>  <p><strong>vertex_select_radius</strong> : float, optional</p>  <p>A vertex is selected (to complete the polygon or to move a vertex) if the mouse click is within <code>vertex_select_radius</code> pixels of the vertex. The default radius is 15 pixels.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="http://matplotlib.org/2.1.0/gallery/widgets/polygon_selector_demo.html#sphx-glr-gallery-widgets-polygon-selector-demo-py" target="_blank"><span class="std std-ref">Polygon Selector Demo</span></a></p> </div> <dl class="method"> <dt id="matplotlib.widgets.PolygonSelector.onmove">
<code>onmove(event)</code> </dt> <dd>
<p>Cursor move event handler and validator</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.widgets.PolygonSelector.verts">
<code>verts</code> </dt> <dd>
<p>Get the polygon vertices.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">list</p>  <p>A list of the vertices of the polygon as <code>(xdata, ydata)</code> tuples.</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.RadioButtons">
<code>class matplotlib.widgets.RadioButtons(ax, labels, active=0, activecolor='blue')</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.widgets.AxesWidget" title="matplotlib.widgets.AxesWidget"><code>matplotlib.widgets.AxesWidget</code></a></p> <p>A GUI neutral radio button.</p> <p>For the buttons to remain responsive you must keep a reference to this object.</p> <p>The following attributes are exposed:</p>  <dl class="docutils"> <dt><em>ax</em></dt> <dd>The <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a> instance the buttons are in</dd> <dt><em>activecolor</em></dt> <dd>The color of the button when clicked</dd> <dt><em>labels</em></dt> <dd>A list of <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>matplotlib.text.Text</code></a> instances</dd> <dt><em>circles</em></dt> <dd>A list of <a class="reference internal" href="../_as_gen/matplotlib.patches.circle/#matplotlib.patches.Circle" title="matplotlib.patches.Circle"><code>matplotlib.patches.Circle</code></a> instances</dd> <dt><em>value_selected</em></dt> <dd>A string listing the current value selected</dd> </dl>  <p>Connect to the RadioButtons with the <a class="reference internal" href="#matplotlib.widgets.RadioButtons.on_clicked" title="matplotlib.widgets.RadioButtons.on_clicked"><code>on_clicked()</code></a> method</p> <p>Add radio buttons to <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a> instance <em>ax</em></p> <dl class="docutils"> <dt><em>labels</em></dt> <dd>A len(buttons) list of labels as strings</dd> <dt><em>active</em></dt> <dd>The index into labels for the button that is active</dd> <dt><em>activecolor</em></dt> <dd>The color of the button when clicked</dd> </dl> <dl class="method"> <dt id="matplotlib.widgets.RadioButtons.disconnect">
<code>disconnect(cid)</code> </dt> <dd>
<p>remove the observer with connection id <em>cid</em></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.RadioButtons.on_clicked">
<code>on_clicked(func)</code> </dt> <dd>
<p>When the button is clicked, call <em>func</em> with button label</p> <p>A connection id is returned which can be used to disconnect</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.RadioButtons.set_active">
<code>set_active(index)</code> </dt> <dd>
<p>Trigger which radio button to make active.</p> <dl class="docutils"> <dt>
<em>index</em> is an index into the original label list</dt> <dd>that this object was constructed with. Raise ValueError if the index is invalid.</dd> </dl> <p>Callbacks will be triggered if <code>eventson</code> is True.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.RectangleSelector">
<code>class matplotlib.widgets.RectangleSelector(ax, onselect, drawtype='box', minspanx=None, minspany=None, useblit=False, lineprops=None, rectprops=None, spancoords='data', button=None, maxdist=10, marker_props=None, interactive=False, state_modifier_keys=None)</code> </dt> <dd>
<p>Bases: <code>matplotlib.widgets._SelectorWidget</code></p> <p>Select a rectangular region of an axes.</p> <p>For the cursor to remain responsive you must keep a reference to it.</p> <p>Example usage:</p> <pre data-language="python">from matplotlib.widgets import  RectangleSelector
from pylab import *

def onselect(eclick, erelease):
  'eclick and erelease are matplotlib events at press and release'
  print(' startposition : (%f, %f)' % (eclick.xdata, eclick.ydata))
  print(' endposition   : (%f, %f)' % (erelease.xdata, erelease.ydata))
  print(' used button   : ', eclick.button)

def toggle_selector(event):
    print(' Key pressed.')
    if event.key in ['Q', 'q'] and toggle_selector.RS.active:
        print(' RectangleSelector deactivated.')
        toggle_selector.RS.set_active(False)
    if event.key in ['A', 'a'] and not toggle_selector.RS.active:
        print(' RectangleSelector activated.')
        toggle_selector.RS.set_active(True)

x = arange(100)/(99.0)
y = sin(x)
fig = figure
ax = subplot(111)
ax.plot(x,y)

toggle_selector.RS = RectangleSelector(ax, onselect, drawtype='line')
connect('key_press_event', toggle_selector)
show()
</pre> <p>Create a selector in <em>ax</em>. When a selection is made, clear the span and call onselect with:</p> <pre data-language="python">onselect(pos_1, pos_2)
</pre> <p>and clear the drawn box/line. The <code>pos_1</code> and <code>pos_2</code> are arrays of length 2 containing the x- and y-coordinate.</p> <p>If <em>minspanx</em> is not <em>None</em> then events smaller than <em>minspanx</em> in x direction are ignored (it’s the same for y).</p> <p>The rectangle is drawn with <em>rectprops</em>; default:</p> <pre data-language="python">rectprops = dict(facecolor='red', edgecolor = 'black',
                 alpha=0.2, fill=True)
</pre> <p>The line is drawn with <em>lineprops</em>; default:</p> <pre data-language="python">lineprops = dict(color='black', linestyle='-',
                 linewidth = 2, alpha=0.5)
</pre> <p>Use <em>drawtype</em> if you want the mouse to draw a line, a box or nothing between click and actual position by setting</p> <p><code>drawtype = 'line'</code>, <code>drawtype='box'</code> or <code>drawtype = 'none'</code>.</p> <p><em>spancoords</em> is one of ‘data’ or ‘pixels’. If ‘data’, <em>minspanx</em> and <em>minspanx</em> will be interpreted in the same coordinates as the x and y axis. If ‘pixels’, they are in pixels.</p> <p><em>button</em> is a list of integers indicating which mouse buttons should be used for rectangle selection. You can also specify a single integer if only a single button is desired. Default is <em>None</em>, which does not limit which button can be used.</p> <dl class="docutils"> <dt>Note, typically:</dt> <dd>1 = left mouse button 2 = center mouse button (scroll wheel) 3 = right mouse button</dd> </dl> <p><em>interactive</em> will draw a set of handles and allow you interact with the widget after it is drawn.</p> <p><em>state_modifier_keys</em> are keyboard modifiers that affect the behavior of the widget.</p> <p>The defaults are: dict(move=’ ‘, clear=’escape’, square=’shift’, center=’ctrl’)</p> <p>Keyboard modifiers, which: ‘move’: Move the existing shape. ‘clear’: Clear the current shape. ‘square’: Makes the shape square. ‘center’: Make the initial point the center of the shape. ‘square’ and ‘center’ can be combined.</p> <dl class="attribute"> <dt id="matplotlib.widgets.RectangleSelector.center">
<code>center</code> </dt> <dd>
<p>Center of rectangle</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.widgets.RectangleSelector.corners">
<code>corners</code> </dt> <dd>
<p>Corners of rectangle from lower left, moving clockwise.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.RectangleSelector.draw_shape">
<code>draw_shape(extents)</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.widgets.RectangleSelector.edge_centers">
<code>edge_centers</code> </dt> <dd>
<p>Midpoint of rectangle edges from left, moving clockwise.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.widgets.RectangleSelector.extents">
<code>extents</code> </dt> <dd>
<p>Return (xmin, xmax, ymin, ymax).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.widgets.RectangleSelector.geometry">
<code>geometry</code> </dt> <dd>
<p>Returns numpy.ndarray of shape (2,5) containing x (<code>RectangleSelector.geometry[1,:]</code>) and y (<code>RectangleSelector.geometry[0,:]</code>) coordinates of the four corners of the rectangle starting and ending in the top left corner.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.Slider">
<code>class matplotlib.widgets.Slider(ax, label, valmin, valmax, valinit=0.5, valfmt='%1.2f', closedmin=True, closedmax=True, slidermin=None, slidermax=None, dragging=True, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.widgets.AxesWidget" title="matplotlib.widgets.AxesWidget"><code>matplotlib.widgets.AxesWidget</code></a></p> <p>A slider representing a floating point range.</p> <p>Create a slider from <code>valmin</code> to <code>valmax</code> in axes <code>ax</code>. For the slider to remain responsive you must maintain a reference to it.</p> <p>Call <a class="reference internal" href="#matplotlib.widgets.Slider.on_changed" title="matplotlib.widgets.Slider.on_changed"><code>on_changed()</code></a> to connect to the slider event</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>ax</strong> : Axes</p>  <p>The Axes to put the slider in.</p>  <p><strong>label</strong> : str</p>  <p>Slider label.</p>  <p><strong>valmin</strong> : float</p>  <p>The minimum value of the slider.</p>  <p><strong>valmax</strong> : float</p>  <p>The maximum value of the slider.</p>  <p><strong>valinit</strong> : float, optional, default: 0.5</p>  <p>The slider initial position.</p>  <p><strong>valfmt</strong> : str, optional, default: “%1.2f”</p>  <p>Used to format the slider value, fprint format string.</p>  <p><strong>closedmin</strong> : bool, optional, default: True</p>  <p>Indicate whether the slider interval is closed on the bottom.</p>  <p><strong>closedmax</strong> : bool, optional, default: True</p>  <p>Indicate whether the slider interval is closed on the top.</p>  <p><strong>slidermin</strong> : Slider, optional, default: None</p>  <p>Do not allow the current slider to have a value less than the value of the Slider <code>slidermin</code>.</p>  <p><strong>slidermax</strong> : Slider, optional, default: None</p>  <p>Do not allow the current slider to have a value greater than the value of the Slider <code>slidermax</code>.</p>  <p><strong>dragging</strong> : bool, optional, default: True</p>  <p>If True the slider can be dragged by the mouse.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Additional kwargs are passed on to <code>self.poly</code> which is the <a class="reference internal" href="../_as_gen/matplotlib.patches.rectangle/#matplotlib.patches.Rectangle" title="matplotlib.patches.Rectangle"><code>Rectangle</code></a> that draws the slider knob. See the <a class="reference internal" href="../_as_gen/matplotlib.patches.rectangle/#matplotlib.patches.Rectangle" title="matplotlib.patches.Rectangle"><code>Rectangle</code></a> documentation for valid property names (e.g., <code>facecolor</code>, <code>edgecolor</code>, <code>alpha</code>).</p> <dl class="method"> <dt id="matplotlib.widgets.Slider.disconnect">
<code>disconnect(cid)</code> </dt> <dd>
<p>remove the observer with connection id <em>cid</em></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.Slider.on_changed">
<code>on_changed(func)</code> </dt> <dd>
<p>When the slider value is changed, call <em>func</em> with the new slider position</p> <p>A connection id is returned which can be used to disconnect</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.Slider.reset">
<code>reset()</code> </dt> <dd>
<p>reset the slider to the initial value if needed</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.Slider.set_val">
<code>set_val(val)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.SpanSelector">
<code>class matplotlib.widgets.SpanSelector(ax, onselect, direction, minspan=None, useblit=False, rectprops=None, onmove_callback=None, span_stays=False, button=None)</code> </dt> <dd>
<p>Bases: <code>matplotlib.widgets._SelectorWidget</code></p> <p>Visually select a min/max range on a single axis and call a function with those values.</p> <p>To guarantee that the selector remains responsive, keep a reference to it.</p> <p>In order to turn off the SpanSelector, set <code>span_selector.active=False</code>. To turn it back on, set <code>span_selector.active=True</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>ax</strong> : <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a> object</p> <p><strong>onselect</strong> : func(min, max), min/max are floats</p> <p><strong>direction</strong> : “horizontal” or “vertical”</p>  <p>The axis along which to draw the span selector</p>  <p><strong>minspan</strong> : float, default is None</p>  <p>If selection is less than <em>minspan</em>, do not call <em>onselect</em></p>  <p><strong>useblit</strong> : bool, default is False</p>  <p>If True, use the backend-dependent blitting features for faster canvas updates. Only available for GTKAgg right now.</p>  <p><strong>rectprops</strong> : dict, default is None</p>  <p>Dictionary of <a class="reference internal" href="../_as_gen/matplotlib.patches.patch/#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>matplotlib.patches.Patch</code></a> properties</p>  <p><strong>onmove_callback</strong> : func(min, max), min/max are floats, default is None</p>  <p>Called on mouse move while the span is being selected</p>  <p><strong>span_stays</strong> : bool, default is False</p>  <p>If True, the span stays visible after the mouse is released</p>  <p><strong>button</strong> : int or list of ints</p>  <dl class="docutils"> <dt>Determines which mouse buttons activate the span selector</dt> <dd>
<p class="first">1 = left mouse button</p> <p>2 = center mouse button (scroll wheel)</p> <p class="last">3 = right mouse button</p> </dd> </dl>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; import matplotlib.widgets as mwidgets
&gt;&gt;&gt; fig, ax = plt.subplots()
&gt;&gt;&gt; ax.plot([1, 2, 3], [10, 50, 100])
&gt;&gt;&gt; def onselect(vmin, vmax):
        print(vmin, vmax)
&gt;&gt;&gt; rectprops = dict(facecolor='blue', alpha=0.5)
&gt;&gt;&gt; span = mwidgets.SpanSelector(ax, onselect, 'horizontal',
                                 rectprops=rectprops)
&gt;&gt;&gt; fig.show()
</pre> <p>See also: <a class="reference internal" href="http://matplotlib.org/2.1.0/gallery/widgets/span_selector.html#sphx-glr-gallery-widgets-span-selector-py" target="_blank"><span class="std std-ref">Span Selector</span></a></p> <dl class="method"> <dt id="matplotlib.widgets.SpanSelector.ignore">
<code>ignore(event)</code> </dt> <dd>
<p>return <em>True</em> if <em>event</em> should be ignored</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.SpanSelector.new_axes">
<code>new_axes(ax)</code> </dt> <dd>
<p>Set SpanSelector to operate on a new Axes</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.SubplotTool">
<code>class matplotlib.widgets.SubplotTool(targetfig, toolfig)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.widgets.Widget" title="matplotlib.widgets.Widget"><code>matplotlib.widgets.Widget</code></a></p> <p>A tool to adjust the subplot params of a <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a>.</p> <dl class="docutils"> <dt><em>targetfig</em></dt> <dd>The figure instance to adjust.</dd> <dt><em>toolfig</em></dt> <dd>The figure instance to embed the subplot tool into. If <em>None</em>, a default figure will be created. If you are using this from the GUI</dd> </dl> <dl class="method"> <dt id="matplotlib.widgets.SubplotTool.funcbottom">
<code>funcbottom(val)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.SubplotTool.funchspace">
<code>funchspace(val)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.SubplotTool.funcleft">
<code>funcleft(val)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.SubplotTool.funcright">
<code>funcright(val)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.SubplotTool.functop">
<code>functop(val)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.SubplotTool.funcwspace">
<code>funcwspace(val)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.TextBox">
<code>class matplotlib.widgets.TextBox(ax, label, initial='', color='.95', hovercolor='1', label_pad=0.01)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.widgets.AxesWidget" title="matplotlib.widgets.AxesWidget"><code>matplotlib.widgets.AxesWidget</code></a></p> <p>A GUI neutral text input box.</p> <p>For the text box to remain responsive you must keep a reference to it.</p> <p>The following attributes are accessible:</p>  <dl class="docutils"> <dt><em>ax</em></dt> <dd>The <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a> the button renders into.</dd> <dt><em>label</em></dt> <dd>A <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>matplotlib.text.Text</code></a> instance.</dd> <dt><em>color</em></dt> <dd>The color of the text box when not hovering.</dd> <dt><em>hovercolor</em></dt> <dd>The color of the text box when hovering.</dd> </dl>  <p>Call <a class="reference internal" href="#matplotlib.widgets.TextBox.on_text_change" title="matplotlib.widgets.TextBox.on_text_change"><code>on_text_change()</code></a> to be updated whenever the text changes.</p> <p>Call <a class="reference internal" href="#matplotlib.widgets.TextBox.on_submit" title="matplotlib.widgets.TextBox.on_submit"><code>on_submit()</code></a> to be updated whenever the user hits enter or leaves the text entry field.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>ax</strong> : matplotlib.axes.Axes</p>  <p>The <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a> instance the button will be placed into.</p>  <p><strong>label</strong> : str</p>  <p>Label for this text box. Accepts string.</p>  <p><strong>initial</strong> : str</p>  <p>Initial value in the text box</p>  <p><strong>color</strong> : color</p>  <p>The color of the box</p>  <p><strong>hovercolor</strong> : color</p>  <p>The color of the box when the mouse is over it</p>  <p><strong>label_pad</strong> : float</p>  <p>the distance between the label and the right side of the textbox</p>  </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.widgets.TextBox.begin_typing">
<code>begin_typing(x)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.TextBox.disconnect">
<code>disconnect(cid)</code> </dt> <dd>
<p>remove the observer with connection id <em>cid</em></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.TextBox.on_submit">
<code>on_submit(func)</code> </dt> <dd>
<p>When the user hits enter or leaves the submision box, call this <em>func</em> with event.</p> <p>A connection id is returned which can be used to disconnect.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.TextBox.on_text_change">
<code>on_text_change(func)</code> </dt> <dd>
<p>When the text changes, call this <em>func</em> with event.</p> <p>A connection id is returned which can be used to disconnect.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.TextBox.position_cursor">
<code>position_cursor(x)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.TextBox.set_val">
<code>set_val(val)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.TextBox.stop_typing">
<code>stop_typing()</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.ToolHandles">
<code>class matplotlib.widgets.ToolHandles(ax, x, y, marker='o', marker_props=None, useblit=True)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Control handles for canvas tools.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>ax</strong> : <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a></p>  <p>Matplotlib axes where tool handles are displayed.</p>  <p><strong>x, y</strong> : 1D arrays</p>  <p>Coordinates of control handles.</p>  <p><strong>marker</strong> : str</p>  <p>Shape of marker used to display handle. See <a class="reference internal" href="../_as_gen/matplotlib.pyplot.plot/#matplotlib.pyplot.plot" title="matplotlib.pyplot.plot"><code>matplotlib.pyplot.plot</code></a>.</p>  <p><strong>marker_props</strong> : dict</p>  <p>Additional marker properties. See <a class="reference internal" href="../_as_gen/matplotlib.lines.line2d/#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>matplotlib.lines.Line2D</code></a>.</p>  </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.widgets.ToolHandles.closest">
<code>closest(x, y)</code> </dt> <dd>
<p>Return index and pixel distance to closest index.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.ToolHandles.set_animated">
<code>set_animated(val)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.ToolHandles.set_data">
<code>set_data(pts, y=None)</code> </dt> <dd>
<p>Set x and y positions of handles</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.ToolHandles.set_visible">
<code>set_visible(val)</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.widgets.ToolHandles.x">
<code>x</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.widgets.ToolHandles.y">
<code>y</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.widgets.Widget">
<code>class matplotlib.widgets.Widget</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Abstract base class for GUI neutral widgets</p> <dl class="attribute"> <dt id="matplotlib.widgets.Widget.active">
<code>active</code> </dt> <dd>
<p>Is the widget active?</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.widgets.Widget.drawon">
<code>drawon = True</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.widgets.Widget.eventson">
<code>eventson = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.widgets.Widget.get_active">
<code>get_active()</code> </dt> <dd>
<p>Get whether the widget is active.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.Widget.ignore">
<code>ignore(event)</code> </dt> <dd>
<p>Return True if event should be ignored.</p> <p>This method (or a version of it) should be called at the beginning of any event callback.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.widgets.Widget.set_active">
<code>set_active(active)</code> </dt> <dd>
<p>Set whether the widget is active.</p> </dd>
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/2.1.0/api/widgets_api.html" class="_attribution-link" target="_blank">http://matplotlib.org/2.1.0/api/widgets_api.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
