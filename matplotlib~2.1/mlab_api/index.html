
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Mlab - Matplotlib 2.1 - W3cubDocs</title>
  
  <meta name="description" content=" Numerical python functions written for compatability with MATLAB commands with the same names. ">
  <meta name="keywords" content="mlab, -, matplotlib, matplotlib~2.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~2.1/mlab_api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/matplotlib~2.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~2.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 2.1</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
				
<h1 id="mlab">mlab</h1>  <h2 id="matplotlib-mlab">matplotlib.mlab</h2> <p id="module-matplotlib.mlab">Numerical python functions written for compatability with MATLAB commands with the same names.</p>  <h3 id="matlab-compatible-functions">MATLAB compatible functions</h3> <dl class="docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><code>cohere()</code></a>
</dt> <dd>Coherence (normalized cross spectral density)</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code>csd()</code></a>
</dt> <dd>Cross spectral density using Welch’s average periodogram</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend()</code></a>
</dt> <dd>Remove the mean or best fit line from an array</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.find" title="matplotlib.mlab.find"><code>find()</code></a>
</dt> <dd>Return the indices where some condition is true; numpy.nonzero is similar but more general.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.griddata" title="matplotlib.mlab.griddata"><code>griddata()</code></a>
</dt> <dd>Interpolate irregularly distributed data to a regular grid.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.prctile" title="matplotlib.mlab.prctile"><code>prctile()</code></a>
</dt> <dd>Find the percentiles of a sequence</dd> <dt>
<code>prepca()</code> </dt> <dd>Principal Component Analysis</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd()</code></a>
</dt> <dd>Power spectral density using Welch’s average periodogram</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.rk4" title="matplotlib.mlab.rk4"><code>rk4()</code></a>
</dt> <dd>A 4th order runge kutta integrator for 1D or ND systems</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram()</code></a>
</dt> <dd>Spectrogram (spectrum over segments of time)</dd> </dl>   <h3 id="miscellaneous-functions">Miscellaneous functions</h3> <p>Functions that don’t exist in MATLAB, but are useful anyway:</p> <dl class="docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.cohere_pairs" title="matplotlib.mlab.cohere_pairs"><code>cohere_pairs()</code></a>
</dt> <dd>Coherence over all pairs. This is not a MATLAB function, but we compute coherence a lot in my lab, and we compute it for a lot of pairs. This function is optimized to do this efficiently by caching the direct FFTs.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.rk4" title="matplotlib.mlab.rk4"><code>rk4()</code></a>
</dt> <dd>A 4th order Runge-Kutta ODE integrator in case you ever find yourself stranded without scipy (and the far superior scipy.integrate tools)</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.contiguous_regions" title="matplotlib.mlab.contiguous_regions"><code>contiguous_regions()</code></a>
</dt> <dd>Return the indices of the regions spanned by some logical mask</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.cross_from_below" title="matplotlib.mlab.cross_from_below"><code>cross_from_below()</code></a>
</dt> <dd>Return the indices where a 1D array crosses a threshold from below</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.cross_from_above" title="matplotlib.mlab.cross_from_above"><code>cross_from_above()</code></a>
</dt> <dd>Return the indices where a 1D array crosses a threshold from above</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum()</code></a>
</dt> <dd>Return the complex-valued frequency spectrum of a signal</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum()</code></a>
</dt> <dd>Return the magnitude of the frequency spectrum of a signal</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum()</code></a>
</dt> <dd>Return the angle (wrapped phase) of the frequency spectrum of a signal</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum()</code></a>
</dt> <dd>Return the phase (unwrapped angle) of the frequency spectrum of a signal</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean()</code></a>
</dt> <dd>Remove the mean from a line.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.demean" title="matplotlib.mlab.demean"><code>demean()</code></a>
</dt> <dd>Remove the mean from a line. This function is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean()</code></a> except for the default <em>axis</em>.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear()</code></a>
</dt> <dd>Remove the best fit line from a line.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none()</code></a>
</dt> <dd>Return the original line.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.stride_windows" title="matplotlib.mlab.stride_windows"><code>stride_windows()</code></a>
</dt> <dd>Get all windows in an array in a memory-efficient manner</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.stride_repeat" title="matplotlib.mlab.stride_repeat"><code>stride_repeat()</code></a>
</dt> <dd>Repeat an array in a memory-efficient manner</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.apply_window" title="matplotlib.mlab.apply_window"><code>apply_window()</code></a>
</dt> <dd>Apply a window along a given axis</dd> </dl>   <h3 id="record-array-helper-functions">record array helper functions</h3> <p>A collection of helper methods for numpyrecord arrays</p>  See <a class="reference internal" href="http://matplotlib.org/2.1.0/gallery/index.html#misc-examples-index" target="_blank"><span class="std std-ref">Miscellaneous Examples</span></a> <dl class="docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.rec2txt" title="matplotlib.mlab.rec2txt"><code>rec2txt()</code></a>
</dt> <dd>Pretty print a record array</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.rec2csv" title="matplotlib.mlab.rec2csv"><code>rec2csv()</code></a>
</dt> <dd>Store record array in CSV file</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.csv2rec" title="matplotlib.mlab.csv2rec"><code>csv2rec()</code></a>
</dt> <dd>Import record array from CSV file with type inspection</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.rec_append_fields" title="matplotlib.mlab.rec_append_fields"><code>rec_append_fields()</code></a>
</dt> <dd>Adds field(s)/array(s) to record array</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.rec_drop_fields" title="matplotlib.mlab.rec_drop_fields"><code>rec_drop_fields()</code></a>
</dt> <dd>Drop fields from record array</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.rec_join" title="matplotlib.mlab.rec_join"><code>rec_join()</code></a>
</dt> <dd>Join two record arrays on sequence of fields</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.recs_join" title="matplotlib.mlab.recs_join"><code>recs_join()</code></a>
</dt> <dd>A simple join of multiple recarrays using a single column as a key</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.rec_groupby" title="matplotlib.mlab.rec_groupby"><code>rec_groupby()</code></a>
</dt> <dd>Summarize data by groups (similar to SQL GROUP BY)</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.rec_summarize" title="matplotlib.mlab.rec_summarize"><code>rec_summarize()</code></a>
</dt> <dd>Helper code to filter rec array fields into new fields</dd> </dl> <p>For the rec viewer functions(e rec2csv), there are a bunch of Format objects you can pass into the functions that will do things like color negative values red, set percent formatting and scaling, etc.</p> <p>Example usage:</p> <pre data-language="python">r = csv2rec('somefile.csv', checkrows=0)

formatd = dict(
    weight = FormatFloat(2),
    change = FormatPercent(2),
    cost   = FormatThousands(2),
    )


rec2excel(r, 'test.xls', formatd=formatd)
rec2csv(r, 'test.csv', formatd=formatd)
scroll = rec2gtk(r, formatd=formatd)

win = gtk.Window()
win.set_size_request(600,800)
win.add(scroll)
win.show_all()
gtk.main()
</pre> <dl class="class"> <dt id="matplotlib.mlab.FormatBool">
<code>class matplotlib.mlab.FormatBool</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><code>matplotlib.mlab.FormatObj</code></a></p> <dl class="method"> <dt id="matplotlib.mlab.FormatBool.fromstr">
<code>fromstr(s)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.mlab.FormatBool.toval">
<code>toval(x)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.FormatDate">
<code>class matplotlib.mlab.FormatDate(fmt)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><code>matplotlib.mlab.FormatObj</code></a></p> <dl class="method"> <dt id="matplotlib.mlab.FormatDate.fromstr">
<code>fromstr(x)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.mlab.FormatDate.toval">
<code>toval(x)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.FormatDatetime">
<code>class matplotlib.mlab.FormatDatetime(fmt='%Y-%m-%d %H:%M:%S')</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatDate" title="matplotlib.mlab.FormatDate"><code>matplotlib.mlab.FormatDate</code></a></p> <dl class="method"> <dt id="matplotlib.mlab.FormatDatetime.fromstr">
<code>fromstr(x)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.FormatFloat">
<code>class matplotlib.mlab.FormatFloat(precision=4, scale=1.0)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatFormatStr" title="matplotlib.mlab.FormatFormatStr"><code>matplotlib.mlab.FormatFormatStr</code></a></p> <dl class="method"> <dt id="matplotlib.mlab.FormatFloat.fromstr">
<code>fromstr(s)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.mlab.FormatFloat.toval">
<code>toval(x)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.FormatFormatStr">
<code>class matplotlib.mlab.FormatFormatStr(fmt)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><code>matplotlib.mlab.FormatObj</code></a></p> <dl class="method"> <dt id="matplotlib.mlab.FormatFormatStr.tostr">
<code>tostr(x)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.FormatInt">
<code>class matplotlib.mlab.FormatInt</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><code>matplotlib.mlab.FormatObj</code></a></p> <dl class="method"> <dt id="matplotlib.mlab.FormatInt.fromstr">
<code>fromstr(s)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.mlab.FormatInt.tostr">
<code>tostr(x)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.mlab.FormatInt.toval">
<code>toval(x)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.FormatMillions">
<code>class matplotlib.mlab.FormatMillions(precision=4)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatFloat" title="matplotlib.mlab.FormatFloat"><code>matplotlib.mlab.FormatFloat</code></a></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.FormatObj">
<code>class matplotlib.mlab.FormatObj</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <dl class="method"> <dt id="matplotlib.mlab.FormatObj.fromstr">
<code>fromstr(s)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.mlab.FormatObj.tostr">
<code>tostr(x)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.mlab.FormatObj.toval">
<code>toval(x)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.FormatPercent">
<code>class matplotlib.mlab.FormatPercent(precision=4)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatFloat" title="matplotlib.mlab.FormatFloat"><code>matplotlib.mlab.FormatFloat</code></a></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.FormatString">
<code>class matplotlib.mlab.FormatString</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><code>matplotlib.mlab.FormatObj</code></a></p> <dl class="method"> <dt id="matplotlib.mlab.FormatString.tostr">
<code>tostr(x)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.FormatThousands">
<code>class matplotlib.mlab.FormatThousands(precision=4)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatFloat" title="matplotlib.mlab.FormatFloat"><code>matplotlib.mlab.FormatFloat</code></a></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.GaussianKDE">
<code>class matplotlib.mlab.GaussianKDE(dataset, bw_method=None)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Representation of a kernel-density estimate using Gaussian kernels.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>dataset</strong> : array_like</p>  <p>Datapoints to estimate from. In case of univariate data this is a 1-D array, otherwise a 2-D array with shape (# of dims, # of data).</p>  <p><strong>bw_method</strong> : str, scalar or callable, optional</p>  <p>The method used to calculate the estimator bandwidth. This can be ‘scott’, ‘silverman’, a scalar constant or a callable. If a scalar, this will be used directly as <code>kde.factor</code>. If a callable, it should take a <a class="reference internal" href="#matplotlib.mlab.GaussianKDE" title="matplotlib.mlab.GaussianKDE"><code>GaussianKDE</code></a> instance as only parameter and return a scalar. If None (default), ‘scott’ is used.</p>  </td> </tr>  </table> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>dataset</strong></td> <td>(ndarray) The dataset with which <code>gaussian_kde</code> was initialized.</td> </tr> <tr>
<td><strong>dim</strong></td> <td>(int) Number of dimensions.</td> </tr> <tr>
<td><strong>num_dp</strong></td> <td>(int) Number of datapoints.</td> </tr> <tr>
<td><strong>factor</strong></td> <td>(float) The bandwidth factor, obtained from <code>kde.covariance_factor</code>, with which the covariance matrix is multiplied.</td> </tr> <tr>
<td><strong>covariance</strong></td> <td>(ndarray) The covariance matrix of <code>dataset</code>, scaled by the calculated bandwidth (<code>kde.factor</code>).</td> </tr> <tr>
<td><strong>inv_cov</strong></td> <td>(ndarray) The inverse of <code>covariance</code>.</td> </tr>  </table> <h4 class="rubric">Methods</h4> <table class="docutils">   <tr>
<td><strong>kde.evaluate(points)</strong></td> <td>(ndarray) Evaluate the estimated pdf on a provided set of points.</td> </tr> <tr>
<td><strong>kde(points)</strong></td> <td>(ndarray) Same as kde.evaluate(points)</td> </tr>  </table> <dl class="method"> <dt id="matplotlib.mlab.GaussianKDE.covariance_factor">
<code>covariance_factor()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.mlab.GaussianKDE.evaluate">
<code>evaluate(points)</code> </dt> <dd>
<p>Evaluate the estimated pdf on a set of points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>points</strong> : (# of dimensions, # of points)-array</p>  <p>Alternatively, a (# of dimensions,) vector can be passed in and treated as a single point.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>values</strong> : (# of points,)-array</p>  <p>The values at each point.</p>  </td> </tr> <tr>
<th class="field-name">Raises:</th>
<td class="field-body">
<p class="first"><strong>ValueError</strong> : if the dimensionality of the input points is different</p>  <p>than the dimensionality of the KDE.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.mlab.GaussianKDE.scotts_factor">
<code>scotts_factor()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.mlab.GaussianKDE.silverman_factor">
<code>silverman_factor()</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.mlab.PCA">
<code>class matplotlib.mlab.PCA(a, standardize=True)</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>compute the SVD of a and store data for PCA. Use project to project the data onto a reduced set of dimensions</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>a</strong> : np.ndarray</p>  <p>A numobservations x numdims array</p>  <p><strong>standardize</strong> : bool</p>  <p>True if input data are to be standardized. If False, only centering will be carried out.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The factor loadings are in the <code>Wt</code> factor, i.e., the factor loadings for the first principal component are given by <code>Wt[0]</code>. This row is also the first eigenvector.</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td><strong>a</strong></td> <td>A centered unit sigma version of input <code>a</code>.</td> </tr> <tr>
<td><strong>numrows, numcols</strong></td> <td>The dimensions of <code>a</code>.</td> </tr> <tr>
<td><strong>mu</strong></td> <td>A numdims array of means of <code>a</code>. This is the vector that points to the origin of PCA space.</td> </tr> <tr>
<td><strong>sigma</strong></td> <td>A numdims array of standard deviation of <code>a</code>.</td> </tr> <tr>
<td><strong>fracs</strong></td> <td>The proportion of variance of each of the principal components.</td> </tr> <tr>
<td><strong>s</strong></td> <td>The actual eigenvalues of the decomposition.</td> </tr> <tr>
<td><strong>Wt</strong></td> <td>The weight vector for projecting a numdims point or array into PCA space.</td> </tr> <tr>
<td><strong>Y</strong></td> <td>A projected into PCA space.</td> </tr>  </table> <dl class="method"> <dt id="matplotlib.mlab.PCA.center">
<code>center(x)</code> </dt> <dd>
<p>center and optionally standardize the data using the mean and sigma from training set a</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.mlab.PCA.project">
<code>project(x, minfrac=0.0)</code> </dt> <dd>
<p>project x onto the principle axes, dropping any axes where fraction of variance&lt;minfrac</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.amap">
<code>matplotlib.mlab.amap(function, sequence[, sequence, ...]) → array.</code> </dt> <dd>
<p>Works like <a class="reference external" href="https://docs.python.org/2/library/functions.html#map" title="(in Python v2.7)" target="_blank"><code>map()</code></a>, but it returns an array. This is just a convenient shorthand for <code>numpy.array(map(...))</code>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.angle_spectrum">
<code>matplotlib.mlab.angle_spectrum(x, Fs=None, window=None, pad_to=None, sides=None)</code> </dt> <dd>
<p>Compute the angle of the frequency spectrum (wrapped phase spectrum) of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : 1-D array or sequence</p>  <p>Array or sequence containing the data</p>  <p><strong>Fs</strong> : scalar</p>  <p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p>  <p><strong>window</strong> : callable or ndarray</p>  <p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.13)" target="_blank"><code>numpy.blackman()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.13)" target="_blank"><code>numpy.hamming()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.13)" target="_blank"><code>numpy.bartlett()</code></a>, <code>scipy.signal()</code>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v0.19.1)" target="_blank"><code>scipy.signal.get_window()</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p>  <p><strong>sides</strong> : [ ‘default’ | ‘onesided’ | ‘twosided’ ]</p>  <p>Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. ‘onesided’ forces the return of a one-sided spectrum, while ‘twosided’ forces two-sided.</p>  <p><strong>pad_to</strong> : integer</p>  <p>The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>spectrum</strong> : 1-D array</p>  <p>The values for the angle spectrum in radians (real valued)</p>  <p><strong>freqs</strong> : 1-D array</p>  <p>The frequencies corresponding to the elements in <em>spectrum</em></p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum()</code></a>
</dt> <dd>This function returns the angle value of <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum()</code></a>.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum()</code></a> returns the magnitudes of the corresponding frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum()</code></a> returns the unwrapped version of this function.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram()</code></a> can return the angle spectrum of segments within the signal.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.apply_window">
<code>matplotlib.mlab.apply_window(x, window, axis=0, return_window=None)</code> </dt> <dd>
<p>Apply the given window to the given 1D or 2D array along the given axis.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : 1D or 2D array or sequence</p>  <p>Array or sequence containing the data.</p>  <p><strong>window</strong> : function or array.</p>  <p>Either a function to generate a window or an array with length <em>x</em>.shape[<em>axis</em>]</p>  <p><strong>axis</strong> : integer</p>  <p>The axis over which to do the repetition. Must be 0 or 1. The default is 0</p>  <p><strong>return_window</strong> : bool</p>  <p>If true, also return the 1D values of the window that was applied</p>  </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.base_repr">
<code>matplotlib.mlab.base_repr(number, base=2, padding=0)</code> </dt> <dd>
<p>Return the representation of a <em>number</em> in any given <em>base</em>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.binary_repr">
<code>matplotlib.mlab.binary_repr(number, max_length=1025)</code> </dt> <dd>
<p>Return the binary representation of the input <em>number</em> as a string.</p> <p>This is more efficient than using <a class="reference internal" href="#matplotlib.mlab.base_repr" title="matplotlib.mlab.base_repr"><code>base_repr()</code></a> with base 2.</p> <p>Increase the value of max_length for very large numbers. Note that on 32-bit machines, 2**1023 is the largest integer power of 2 which can be converted to a Python float.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.bivariate_normal">
<code>matplotlib.mlab.bivariate_normal(X, Y, sigmax=1.0, sigmay=1.0, mux=0.0, muy=0.0, sigmaxy=0.0)</code> </dt> <dd>
<p>Bivariate Gaussian distribution for equal shape <em>X</em>, <em>Y</em>.</p> <p>See <a class="reference external" href="http://mathworld.wolfram.com/BivariateNormalDistribution.html" target="_blank">bivariate normal</a> at mathworld.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.center_matrix">
<code>matplotlib.mlab.center_matrix(M, dim=0)</code> </dt> <dd>
<p>Return the matrix <em>M</em> with each row having zero mean and unit std.</p> <p>If <em>dim</em> = 1 operate on columns instead of rows. (<em>dim</em> is opposite to the numpy axis kwarg.)</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.cohere">
<code>matplotlib.mlab.cohere(x, y, NFFT=256, Fs=2, detrend=&lt;function detrend_none&gt;, window=&lt;function window_hanning&gt;, noverlap=0, pad_to=None, sides='default', scale_by_freq=None)</code> </dt> <dd>
<p>The coherence between <em>x</em> and <em>y</em>. Coherence is the normalized cross spectral density:</p> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF0AAAApCAMAAABgHNUmAAAAwFBMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOoSlDAAAAP3RSTlMAQX3MHmYwYCDQWo4QqDgGCHmIvvmkF8dSEwKRRZcb4K5ddLSaam/pLCNP/oRIOwqrJuYM9YNVwz3ToGLz3LoDfh7MAAACBklEQVRIx+2W6W6CQBSFLyhQkUVFWdxAwd0WrWLVtPL+b9VhaKXKQESwSZOeHzeTEzgww535APhrKu84+nHpIx6sdb4Ivp9mK5t86dxTsAYNv1OnxecrGwZ7KCAdXiaosM3NpU1NBbWIdLqFynwrX9jPB0WrFZGucADGG39t5xaOqTVpZjx8gsekU6/kKSVJzpS+FG9LlxxNsWh57WRK10Z4LHTrusjWWaNDTFdXh6BnqePHOEO6VF20JLz1oVo2yj11x5DS16bt4oHns9l6JtSmbaEnrKA3I6SrZsX9Wp8J3JPeGFSpKVS7FdK624uX70lYec4ZtkGw975yngV1f4vqzNAl2I4/SL1NrERSMj/0w+8/ECXN9/NwVnz65LydJb74dLv5fVw6xHOzVYp0wo5/q4IdumDCGBo15p7r8Ywtt8fHKUjHIl6+/q4Ha95D7SjwwKyEVls3rC4svULWhrJLtkgbaOTK4AT9KQimDFo3+aciBlSyF5NZBgHtuQ64Wzf5qhhQE7wLzcfsBGroOwxHMNdS3iEG1ATv8mzqMB4zQq0zcwZaIyU9BtQEL1GHlEMnDlSyR9bUhPkprQ9eb/PIUj1umfazFgcq2btPP4GKS+RhvoaQvU9XQA3KDy/gawjZnMJADakaCfMVl5zCQA2pGgnzFZeHKOBrWIoX5msCZP/1O/oEHL4242Ko3bkAAAAASUVORK5CYII=" class="center"><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x, y</strong></p>  <p>Array or sequence containing the data</p>  <p><strong>Fs</strong> : scalar</p>  <p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p>  <p><strong>window</strong> : callable or ndarray</p>  <p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.13)" target="_blank"><code>numpy.blackman()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.13)" target="_blank"><code>numpy.hamming()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.13)" target="_blank"><code>numpy.bartlett()</code></a>, <code>scipy.signal()</code>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v0.19.1)" target="_blank"><code>scipy.signal.get_window()</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p>  <p><strong>sides</strong> : [ ‘default’ | ‘onesided’ | ‘twosided’ ]</p>  <p>Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. ‘onesided’ forces the return of a one-sided spectrum, while ‘twosided’ forces two-sided.</p>  <p><strong>pad_to</strong> : integer</p>  <p>The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p>  <p><strong>NFFT</strong> : integer</p>  <p>The number of data points used in each block for the FFT. A power 2 is most efficient. The default value is 256. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect. Use <em>pad_to</em> for this instead.</p>  <p><strong>detrend</strong> : {‘default’, ‘constant’, ‘mean’, ‘linear’, ‘none’} or callable</p>  <p>The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in matplotlib is it a function. The <code>pylab</code> module defines <code>detrend_none()</code>, <code>detrend_mean()</code>, and <code>detrend_linear()</code>, but you can use a custom function as well. You can also use a string to choose one of the functions. ‘default’, ‘constant’, and ‘mean’ call <code>detrend_mean()</code>. ‘linear’ calls <code>detrend_linear()</code>. ‘none’ calls <code>detrend_none()</code>.</p>  <p><strong>scale_by_freq</strong> : boolean, optional</p>  <p>Specifies whether the resulting density values should be scaled by the scaling frequency, which gives density in units of Hz^-1. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p>  <p><strong>noverlap</strong> : integer</p>  <p>The number of points of overlap between blocks. The default value is 0 (no overlap).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">The return value is the tuple (<em>Cxy</em>, <em>f</em>), where <em>f</em> are the</p> <p>frequencies of the coherence vector. For cohere, scaling the</p> <p>individual densities by the sampling frequency has no effect,</p> <p class="last">since the factors cancel out.</p> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd()</code></a>, <a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code>csd()</code></a></p> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.cohere_pairs">
<code>matplotlib.mlab.cohere_pairs(X, ij, NFFT=256, Fs=2, detrend=&lt;function detrend_none&gt;, window=&lt;function window_hanning&gt;, noverlap=0, preferSpeedOverMemory=True, progressCallback=&lt;function donothing_callback&gt;, returnPxx=False)</code> </dt> <dd>
<p>Compute the coherence and phase for all pairs <em>ij</em>, in <em>X</em>.</p> <p><em>X</em> is a <em>numSamples</em> * <em>numCols</em> array</p> <p><em>ij</em> is a list of tuples. Each tuple is a pair of indexes into the columns of X for which you want to compute coherence. For example, if <em>X</em> has 64 columns, and you want to compute all nonredundant pairs, define <em>ij</em> as:</p> <pre data-language="python">ij = []
for i in range(64):
    for j in range(i+1,64):
        ij.append( (i,j) )
</pre> <p><em>preferSpeedOverMemory</em> is an optional bool. Defaults to true. If False, limits the caching by only making one, rather than two, complex cache arrays. This is useful if memory becomes critical. Even when <em>preferSpeedOverMemory</em> is False, <a class="reference internal" href="#matplotlib.mlab.cohere_pairs" title="matplotlib.mlab.cohere_pairs"><code>cohere_pairs()</code></a> will still give significant performace gains over calling <a class="reference internal" href="#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><code>cohere()</code></a> for each pair, and will use subtantially less memory than if <em>preferSpeedOverMemory</em> is True. In my tests with a 43000,64 array over all nonredundant pairs, <em>preferSpeedOverMemory</em> = True delivered a 33% performance boost on a 1.7GHZ Athlon with 512MB RAM compared with <em>preferSpeedOverMemory</em> = False. But both solutions were more than 10x faster than naively crunching all possible pairs through <a class="reference internal" href="#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><code>cohere()</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>Cxy</strong> : dictionary of (<em>i</em>, <em>j</em>) tuples -&gt; coherence vector for</p>  <p>that pair. i.e., <code>Cxy[(i,j) = cohere(X[:,i], X[:,j])</code>. Number of dictionary keys is <code>len(ij)</code>.</p>  <p><strong>Phase</strong> : dictionary of phases of the cross spectral density at</p>  <p>each frequency for each pair. Keys are (<em>i</em>, <em>j</em>).</p>  <p><strong>freqs</strong> : vector of frequencies, equal in length to either the</p>  <p>coherence or phase vectors for any (<em>i</em>, <em>j</em>) key.</p>  <p>e.g., to make a coherence Bode plot:</p> <pre data-language="python">subplot(211)
plot( freqs, Cxy[(12,19)])
subplot(212)
plot( freqs, Phase[(12,19)])
</pre> <p>For a large number of pairs, <a class="reference internal" href="#matplotlib.mlab.cohere_pairs" title="matplotlib.mlab.cohere_pairs"><code>cohere_pairs()</code></a> can be much more</p> <p>efficient than just calling <a class="reference internal" href="#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><code>cohere()</code></a> for each pair, because</p> <p>it caches most of the intensive computations. If <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAABHNCSVQICAgIfAhkiAAAARNJREFUOI3l0jsvRVEQBeCPkJsQmuv1D1BKkEjQU1JodBKtROlPiBIVtdBrvIJCIxTcRKL2KkRDFBR737i59nGORmM1Z87MrJU1e4Y/QAd2cYUP7Cd6ZnET6y/YQ0ue8CJuI6kvUW/CBTprk40/CA5hIcbziXprdPaQ56yKbTQIoz2iVFefxEw9KcthLyrCuOsoY7quZwxHRd3NYSLGXXjDQV3PZoqY5XAEJzG+xw7Go3PC+K+/EWzHc83/avxWlzOMswzuN/RgJZGvCBstYQn9RR2OSj/2mnD0U1HsuqjDZXQn8mXh3Q6xkUVOOezGXSL/hC3hXC6LCg6iLavZ13Jy728Ap3gXjvk8iqdwjOY8wX+ET9cTMfGNhlQVAAAAAElFTkSuQmCC" style="position: relative; bottom: -3px"> is the</p> <p>number of pairs, this function is <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAZCAMAAAB5GOwQAAAA1VBMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwim1yAAAARnRSTlMAjwJVWKAUwCiHqOv8Adyjxrh6IBmzEU4WdAc2OXcxm6tgYq0N4Nhdyfn0vEpmBHEcCorPNNKcJUK6pz1GUeTvl2uC5/CuBWLUjgAAAYdJREFUOMu1U9l2gjAQjWUTWQUqiqJS933faq12m///pJIMoadHfGhPm4fcmZsLmSVDyB+s6Y/UTu2KUvPfXL9gScWczOyXCQP50AWFGj0Thkrf+xLLihQrDaczj52dwulZB9hPpxuZVIupOt95RaNPuZbA+UcfchTbdFeeErZt3vOgwSXuc5roh2FqQYxjMd5Oo4S1dDexJnAiYSG9VCUhUKVK45Z1zKwOTS4IQSCjGfcexqQ8oIlYzO2KDC6QBluAGtF4jGTbpkyeBA3mtlQGJpR5d7Rz0IYql9NL93GyRyxsA6McvPPzMVzIHHhDPFaVrhY4yCyxlOc3LreHHvFSucBirIBoGdhYrJ+iB3geQY+QBfAXkGMxygNFQr+BKAKmXB06FDSfNykpM1TQaC0RJTOu613Uwa+Kyek66d2R577p8QKPpG0zLKFTYbK6rcNqjRlhl0v6POv1ulqQ+ap9O/u1F6JM+iBky93VXQZbt40bwxSp19xC2d0cvtn+evhq/zjsv1yfH5kgXlh61t4AAAAASUVORK5CYII=" style="position: relative; bottom: -8px"> for most of the</p> <p>heavy lifting, whereas calling cohere for each pair is</p> <p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADkAAAAaCAMAAAA6/gQvAAAA2FBMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1ChoIAAAAR3RSTlMABgpzqIdZoQROGvwTFzIgm78BtLi7FTl2eo4nVKthXdytkdI2SvnpPfXFDsAk32qjyFbwZOyKz9dBcNrCKUVRlyqxguHkeObO93IAAAHGSURBVDjLxVTZVuJAEK3shOwZIgSQfQdBBdQZHXet//8ju7vS8QxEOMcHp19u1e26nVq6A/ADy9bq+smxoFIBF2gAvV9HhGm16JMjFewpM4ynf3ndsio9Sma1EuAmN7jgRruD00gt+Wynz1x1Uf7UnUSWCxCnr5xrLCStLbEhku/TkUp/wmFQyYWN5QsZF5zrXkpet7HOcd4jv24TRvdZwLwjC08xgOAt70837mwVhkM6azWBM2E8JFnAuRNk1gYfoKbnqRhQQ5P3RBRm2p5Xow44rkAfT2XsO15CoklvMwRvdMcMi3tVBxGz5G5MAY/YzAvDKmxlERDOOdMAJdydUNcQcIuevADjtaLiQO7zVH6zHk02u8qQKhqtJTHERyjTINjyREdvt0r6d1d5RXNZjyUxm5aZUsY1RREamufxrtKgeiNHIb+FbXZDUF69uijCHd1ZezcxJMpE6tRgmnIY27Jd2cxQ21N2rwitDptX3F7SARWaGfjZBCafLctXv50ZrcQKT2tudlmfhe7CwWufqt97c65TLnpiwVg5+sZnxbzeOqZMmsV8cF06LPRn8Rc7LeOgUI3Ovtz7c39IaVS/+w8swX9bH6JSJH15wjj6AAAAAElFTkSuQmCC" style="position: relative; bottom: -8px">. However, because of the caching, it is also more</p> <p>memory intensive, making 2 additional complex arrays with</p> <p>approximately the same number of elements as <em>X</em>.</p> <p>See <code>test/cohere_pairs_test.py</code> in the src tree for an</p> <p>example script that shows that this <a class="reference internal" href="#matplotlib.mlab.cohere_pairs" title="matplotlib.mlab.cohere_pairs"><code>cohere_pairs()</code></a> and</p> <p class="last"><a class="reference internal" href="#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><code>cohere()</code></a> give the same results for a given pair.</p> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd()</code></a>
</dt> <dd>For information about the methods used to compute <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAZCAYAAADNAiUZAAAABHNCSVQICAgIfAhkiAAAAa5JREFUSInt1U2IjWEUB/Af1xgGzSSxQCaLUb6SsjB1KbFQ0134KKWUhaywsbZR9rKwmAV2CmUhJfIVloopJYpYiA0pEorFObe5jfe9k7d3KPlvnnuf/3nP/5zznPM8/AVMK9jrxWUMYTne4HFys7AYj3AMT+oOaA9+YGdBUJfwHoN1i55K0YUF3Ehyx6s4nt6Fa+I53hVwc3OdV6doP9bgQQm/OdcyvhK2i/IdLOAWiPO8pbgRK+NEiq6esD8ksruAOVWdzyjZb+IbDqU49OAzjqq5rMRIfMHtuh23UdRIG1L47p8UbeZ6Z6pEi3AVX9E3id0m7MdpcXsdwBVRpYboh7NYmfYb8/8vmfZgGA9F05RhAEtxJm134SI+4DtaOC8ujyX5zQhedToZxA08E936ETexo0S0LwOEUeybwPdnYC+MT8h9bO2SyG/hpci6LdbGXpzsCPKTnO1ud283tMSZrRPP3WvMxu4Om0V4mr+3YSyFNSqKDosG6RWPwgqsxzlxpvBWPIvzcQT3cL2iXiWMYctUi6wy3qktXOskq5Z3MjQwE8uwFofF7P/HP4qfU8hKJoRMyNAAAAAASUVORK5CYII=" style="position: relative; bottom: -9px">, <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAWCAYAAADXYyzPAAAABHNCSVQICAgIfAhkiAAAAVlJREFUSInt1T1LXEEUxvFfNKImiinERoQlggFRCIIWC6t1ICiogVS2qdKlTiP4BSwtQmoj+AHElxSxE7SwyRYBC8FGsZAEhaSYWQuZu7uue02hTzMw/3vnOWfOmRn+k54k5tqxjiG8xDEOIutAP/bxGYd5BPUefzGXCGwNpyjkYbwcjfsS7G1ki40u3lKFlVDGSYJ1xbG72cY9GMWPDD4VxyzesN4IW/khwXqF+m5JN+edtBSNR27MDwlZruL5XQyeZsyXcImPMQBowwU+yWGLCcflN7bzWLyiVHONR/Pv921ciuNOnsapGlfqu1vj30kMYkIIshszwk33pxa/mXEbitgTGilLLzCAL/HbeXzDGa7q4NcqYAM/hS4+xyZmM4yfxSBhBQu35E3RLyE7wo1XF692V1fTtHDGXwtP5RE68a5OrrVB4yKGhWNXxiuM4atQw1r8UQ9A/wAVTEZIG479kAAAAABJRU5ErkJggg==" style="position: relative; bottom: -6px"> and <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAZCAYAAAAiwE4nAAAABHNCSVQICAgIfAhkiAAAAXVJREFUSInt1b9LVWEcx/GXXX+hiSGig4LScIeytgaFixA1BOKQi+Af4GQtzS1Be/QPOAoRNAWR+AttDOqCEAmCi9giCIrooMPz2IU659zrvScH6bN8n/N9H76f58f3OYcrVlNCrg0fUMRt7OJ7ZO0YwDe8xGaek5nGGaYSJvQe+xjO0/BtNOxLYBORvbps0RsZrIQt/EpgN2PsysuwG/fwJYWPx5jGL60nwpbNJrBe4fyWJTddXXodDUf+yBeFVb1DZz2Fm1PyJZxiLhpDC47wQo5bSWj7Y6zkWfRCSU3zIJquXZVhKcbVf2GYpI84QUfGOwXhfOdxJ+ZG43MW+2uFLRjDV6FB0jSJBeHiD8bcBHaqsN8axiJ+Cl15gCU8TTHsxi1sq3T6Bh5VYQ1pBm/iuAOHKnczlWV9S6upHz/i+DHKsXAmKzRguCf8unrwHOv4XAPLRWU8rIPVrLsqXTeJTzWyure0gFYM4T6eCXe3Gvuva6BzYPBO7ppy0nEAAAAASUVORK5CYII=" style="position: relative; bottom: -9px">.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.complex_spectrum">
<code>matplotlib.mlab.complex_spectrum(x, Fs=None, window=None, pad_to=None, sides=None)</code> </dt> <dd>
<p>Compute the complex-valued frequency spectrum of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : 1-D array or sequence</p>  <p>Array or sequence containing the data</p>  <p><strong>Fs</strong> : scalar</p>  <p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p>  <p><strong>window</strong> : callable or ndarray</p>  <p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.13)" target="_blank"><code>numpy.blackman()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.13)" target="_blank"><code>numpy.hamming()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.13)" target="_blank"><code>numpy.bartlett()</code></a>, <code>scipy.signal()</code>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v0.19.1)" target="_blank"><code>scipy.signal.get_window()</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p>  <p><strong>sides</strong> : [ ‘default’ | ‘onesided’ | ‘twosided’ ]</p>  <p>Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. ‘onesided’ forces the return of a one-sided spectrum, while ‘twosided’ forces two-sided.</p>  <p><strong>pad_to</strong> : integer</p>  <p>The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>spectrum</strong> : 1-D array</p>  <p>The values for the complex spectrum (complex valued)</p>  <p><strong>freqs</strong> : 1-D array</p>  <p>The frequencies corresponding to the elements in <em>spectrum</em></p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum()</code></a> returns the absolute value of this function.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum()</code></a> returns the angle of this function.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum()</code></a> returns the phase (unwrapped angle) of this function.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram()</code></a> can return the complex spectrum of segments within the signal.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.contiguous_regions">
<code>matplotlib.mlab.contiguous_regions(mask)</code> </dt> <dd>
<p>return a list of (ind0, ind1) such that mask[ind0:ind1].all() is True and we cover all such regions</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.cross_from_above">
<code>matplotlib.mlab.cross_from_above(x, threshold)</code> </dt> <dd>
<p>return the indices into <em>x</em> where <em>x</em> crosses some threshold from below, e.g., the i’s where:</p> <pre data-language="python">x[i-1]&gt;threshold and x[i]&lt;=threshold
</pre> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#matplotlib.mlab.cross_from_below" title="matplotlib.mlab.cross_from_below"><code>cross_from_below()</code></a></p> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.cross_from_below">
<code>matplotlib.mlab.cross_from_below(x, threshold)</code> </dt> <dd>
<p>return the indices into <em>x</em> where <em>x</em> crosses some threshold from below, e.g., the i’s where:</p> <pre data-language="python">x[i-1]&lt;threshold and x[i]&gt;=threshold
</pre> <p>Example code:</p> <pre data-language="python">import matplotlib.pyplot as plt

t = np.arange(0.0, 2.0, 0.1)
s = np.sin(2*np.pi*t)

fig = plt.figure()
ax = fig.add_subplot(111)
ax.plot(t, s, '-o')
ax.axhline(0.5)
ax.axhline(-0.5)

ind = cross_from_below(s, 0.5)
ax.vlines(t[ind], -1, 1)

ind = cross_from_above(s, -0.5)
ax.vlines(t[ind], -1, 1)

plt.show()
</pre> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#matplotlib.mlab.cross_from_above" title="matplotlib.mlab.cross_from_above"><code>cross_from_above()</code></a></p> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.csd">
<code>matplotlib.mlab.csd(x, y, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None)</code> </dt> <dd>
<p>Compute the cross-spectral density.</p> <p>Call signature:</p> <pre data-language="python">csd(x, y, NFFT=256, Fs=2, detrend=mlab.detrend_none,
    window=mlab.window_hanning, noverlap=0, pad_to=None,
    sides='default', scale_by_freq=None)
</pre> <p>The cross spectral density <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAZCAYAAADNAiUZAAAABHNCSVQICAgIfAhkiAAAAa5JREFUSInt1U2IjWEUB/Af1xgGzSSxQCaLUb6SsjB1KbFQ0134KKWUhaywsbZR9rKwmAV2CmUhJfIVloopJYpYiA0pEorFObe5jfe9k7d3KPlvnnuf/3nP/5zznPM8/AVMK9jrxWUMYTne4HFys7AYj3AMT+oOaA9+YGdBUJfwHoN1i55K0YUF3Ehyx6s4nt6Fa+I53hVwc3OdV6doP9bgQQm/OdcyvhK2i/IdLOAWiPO8pbgRK+NEiq6esD8ksruAOVWdzyjZb+IbDqU49OAzjqq5rMRIfMHtuh23UdRIG1L47p8UbeZ6Z6pEi3AVX9E3id0m7MdpcXsdwBVRpYboh7NYmfYb8/8vmfZgGA9F05RhAEtxJm134SI+4DtaOC8ujyX5zQhedToZxA08E936ETexo0S0LwOEUeybwPdnYC+MT8h9bO2SyG/hpci6LdbGXpzsCPKTnO1ud283tMSZrRPP3WvMxu4Om0V4mr+3YSyFNSqKDosG6RWPwgqsxzlxpvBWPIvzcQT3cL2iXiWMYctUi6wy3qktXOskq5Z3MjQwE8uwFofF7P/HP4qfU8hKJoRMyNAAAAAASUVORK5CYII=" style="position: relative; bottom: -9px"> by Welch’s average periodogram method. The vectors <em>x</em> and <em>y</em> are divided into <em>NFFT</em> length segments. Each segment is detrended by function <em>detrend</em> and windowed by function <em>window</em>. <em>noverlap</em> gives the length of the overlap between segments. The product of the direct FFTs of <em>x</em> and <em>y</em> are averaged over each segment to compute <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAZCAYAAADNAiUZAAAABHNCSVQICAgIfAhkiAAAAa5JREFUSInt1U2IjWEUB/Af1xgGzSSxQCaLUb6SsjB1KbFQ0134KKWUhaywsbZR9rKwmAV2CmUhJfIVloopJYpYiA0pEorFObe5jfe9k7d3KPlvnnuf/3nP/5zznPM8/AVMK9jrxWUMYTne4HFys7AYj3AMT+oOaA9+YGdBUJfwHoN1i55K0YUF3Ehyx6s4nt6Fa+I53hVwc3OdV6doP9bgQQm/OdcyvhK2i/IdLOAWiPO8pbgRK+NEiq6esD8ksruAOVWdzyjZb+IbDqU49OAzjqq5rMRIfMHtuh23UdRIG1L47p8UbeZ6Z6pEi3AVX9E3id0m7MdpcXsdwBVRpYboh7NYmfYb8/8vmfZgGA9F05RhAEtxJm134SI+4DtaOC8ujyX5zQhedToZxA08E936ETexo0S0LwOEUeybwPdnYC+MT8h9bO2SyG/hpci6LdbGXpzsCPKTnO1ud283tMSZrRPP3WvMxu4Om0V4mr+3YSyFNSqKDosG6RWPwgqsxzlxpvBWPIvzcQT3cL2iXiWMYctUi6wy3qktXOskq5Z3MjQwE8uwFofF7P/HP4qfU8hKJoRMyNAAAAAASUVORK5CYII=" style="position: relative; bottom: -9px">, with a scaling to correct for power loss due to windowing.</p> <p>If len(<em>x</em>) &lt; <em>NFFT</em> or len(<em>y</em>) &lt; <em>NFFT</em>, they will be zero padded to <em>NFFT</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x, y</strong> : 1-D arrays or sequences</p>  <p>Arrays or sequences containing the data</p>  <p><strong>Fs</strong> : scalar</p>  <p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p>  <p><strong>window</strong> : callable or ndarray</p>  <p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.13)" target="_blank"><code>numpy.blackman()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.13)" target="_blank"><code>numpy.hamming()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.13)" target="_blank"><code>numpy.bartlett()</code></a>, <code>scipy.signal()</code>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v0.19.1)" target="_blank"><code>scipy.signal.get_window()</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p>  <p><strong>sides</strong> : [ ‘default’ | ‘onesided’ | ‘twosided’ ]</p>  <p>Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. ‘onesided’ forces the return of a one-sided spectrum, while ‘twosided’ forces two-sided.</p>  <p><strong>pad_to</strong> : integer</p>  <p>The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p>  <p><strong>NFFT</strong> : integer</p>  <p>The number of data points used in each block for the FFT. A power 2 is most efficient. The default value is 256. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect. Use <em>pad_to</em> for this instead.</p>  <p><strong>detrend</strong> : {‘default’, ‘constant’, ‘mean’, ‘linear’, ‘none’} or callable</p>  <p>The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in matplotlib is it a function. The <code>pylab</code> module defines <code>detrend_none()</code>, <code>detrend_mean()</code>, and <code>detrend_linear()</code>, but you can use a custom function as well. You can also use a string to choose one of the functions. ‘default’, ‘constant’, and ‘mean’ call <code>detrend_mean()</code>. ‘linear’ calls <code>detrend_linear()</code>. ‘none’ calls <code>detrend_none()</code>.</p>  <p><strong>scale_by_freq</strong> : boolean, optional</p>  <p>Specifies whether the resulting density values should be scaled by the scaling frequency, which gives density in units of Hz^-1. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p>  <p><strong>noverlap</strong> : integer</p>  <p>The number of points of overlap between segments. The default value is 0 (no overlap).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>Pxy</strong> : 1-D array</p>  <p>The values for the cross spectrum <code>P_{xy}</code> before scaling (real valued)</p>  <p><strong>freqs</strong> : 1-D array</p>  <p>The frequencies corresponding to the elements in <em>Pxy</em></p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd()</code></a> is the equivalent to setting y=x.</dd> </dl> </div> <h4 class="rubric">References</h4> <p>Bendat &amp; Piersol – Random Data: Analysis and Measurement Procedures, John Wiley &amp; Sons (1986)</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.csv2rec">
<code>matplotlib.mlab.csv2rec(fname, comments='#', skiprows=0, checkrows=0, delimiter=', ', converterd=None, names=None, missing='', missingd=None, use_mrecords=False, dayfirst=False, yearfirst=False)</code> </dt> <dd>
<p>Load data from comma/space/tab delimited file in <em>fname</em> into a numpy record array and return the record array.</p> <p>If <em>names</em> is <em>None</em>, a header row is required to automatically assign the recarray names. The headers will be lower cased, spaces will be converted to underscores, and illegal attribute name characters removed. If <em>names</em> is not <em>None</em>, it is a sequence of names to use for the column names. In this case, it is assumed there is no header row.</p> <ul> <li>
<em>fname</em>: can be a filename or a file handle. Support for gzipped files is automatic, if the filename ends in ‘.gz’ </li> <li>
<em>comments</em>: the character used to indicate the start of a comment in the file, or <em>None</em> to switch off the removal of comments </li> <li>
<em>skiprows</em>: is the number of rows from the top to skip </li> <li>
<em>checkrows</em>: is the number of rows to check to validate the column data type. When set to zero all rows are validated. </li> <li>
<em>converterd</em>: if not <em>None</em>, is a dictionary mapping column number or munged column name to a converter function. </li> <li>
<em>names</em>: if not None, is a list of header names. In this case, no header will be read from the file </li> <li>
<em>missingd</em> is a dictionary mapping munged column names to field values which signify that the field does not contain actual data and should be masked, e.g., ‘0000-00-00’ or ‘unused’ </li> <li>
<em>missing</em>: a string whose value signals a missing field regardless of the column it appears in </li> <li>
<em>use_mrecords</em>: if True, return an mrecords.fromrecords record array if any of the data are missing </li> <li>
<em>dayfirst</em>: default is False so that MM-DD-YY has precedence over DD-MM-YY. See <a class="reference external" href="http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47" target="_blank">http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47</a> for further information. </li> <li>
<p class="first"><em>yearfirst</em>: default is False so that MM-DD-YY has precedence over YY-MM-DD. See <a class="reference external" href="http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47" target="_blank">http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47</a> for further information.</p> <p>If no rows are found, <em>None</em> is returned</p> </li> </ul> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.csvformat_factory">
<code>matplotlib.mlab.csvformat_factory(format)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.mlab.demean">
<code>matplotlib.mlab.demean(x, axis=0)</code> </dt> <dd>
<p>Return x minus its mean along the specified axis.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array or sequence</p>  <p>Array or sequence containing the data Can have any dimensionality</p>  <p><strong>axis</strong> : integer</p>  <p>The axis along which to take the mean. See numpy.mean for a description of this argument.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p><code>delinear()</code></p> <dl class="last docutils"> <dt>
<code>denone()</code> </dt> <dd>
<code>delinear()</code> and <code>denone()</code> are other detrend algorithms.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean()</code></a>
</dt> <dd>This function is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean()</code></a> except for the default <em>axis</em>.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.detrend">
<code>matplotlib.mlab.detrend(x, key=None, axis=None)</code> </dt> <dd>
<p>Return x with its trend removed.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array or sequence</p>  <p>Array or sequence containing the data.</p>  <p><strong>key</strong> : [ ‘default’ | ‘constant’ | ‘mean’ | ‘linear’ | ‘none’] or function</p>  <p>Specifies the detrend algorithm to use. ‘default’ is ‘mean’, which is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean()</code></a>. ‘constant’ is the same. ‘linear’ is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear()</code></a>. ‘none’ is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none()</code></a>. The default is ‘mean’. See the corresponding functions for more details regarding the algorithms. Can also be a function that carries out the detrend operation.</p>  <p><strong>axis</strong> : integer</p>  <p>The axis along which to do the detrending.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean()</code></a> implements the ‘mean’ algorithm.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear()</code></a> implements the ‘linear’ algorithm.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none()</code></a> implements the ‘none’ algorithm.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.detrend_linear">
<code>matplotlib.mlab.detrend_linear(y)</code> </dt> <dd>
<p>Return x minus best fit line; ‘linear’ detrending.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>y</strong> : 0-D or 1-D array or sequence</p>  <p>Array or sequence containing the data</p>  <p><strong>axis</strong> : integer</p>  <p>The axis along which to take the mean. See numpy.mean for a description of this argument.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="docutils"> <dt>
<code>delinear()</code> </dt> <dd>This function is the same as <code>delinear()</code> except for the default <em>axis</em>.</dd> </dl> <p><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean()</code></a></p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean()</code></a> and <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none()</code></a> are other detrend algorithms.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend()</code></a> is a wrapper around all the detrend algorithms.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.detrend_mean">
<code>matplotlib.mlab.detrend_mean(x, axis=None)</code> </dt> <dd>
<p>Return x minus the mean(x).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array or sequence</p>  <p>Array or sequence containing the data Can have any dimensionality</p>  <p><strong>axis</strong> : integer</p>  <p>The axis along which to take the mean. See numpy.mean for a description of this argument.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.demean" title="matplotlib.mlab.demean"><code>demean()</code></a>
</dt> <dd>This function is the same as <a class="reference internal" href="#matplotlib.mlab.demean" title="matplotlib.mlab.demean"><code>demean()</code></a> except for the default <em>axis</em>.</dd> </dl> <p><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear()</code></a></p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear()</code></a> and <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none()</code></a> are other detrend algorithms.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend()</code></a> is a wrapper around all the detrend algorithms.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.detrend_none">
<code>matplotlib.mlab.detrend_none(x, axis=None)</code> </dt> <dd>
<p>Return x: no detrending.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : any object</p>  <p>An object containing the data</p>  <p><strong>axis</strong> : integer</p>  <p>This parameter is ignored. It is included for compatibility with detrend_mean</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="docutils"> <dt>
<code>denone()</code> </dt> <dd>This function is the same as <code>denone()</code> except for the default <em>axis</em>, which has no effect.</dd> </dl> <p><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean()</code></a></p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean()</code></a> and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear()</code></a> are other detrend algorithms.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend()</code></a> is a wrapper around all the detrend algorithms.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.dist">
<code>matplotlib.mlab.dist(x, y)</code> </dt> <dd>
<p>Return the distance between two points.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.dist_point_to_segment">
<code>matplotlib.mlab.dist_point_to_segment(p, s0, s1)</code> </dt> <dd>
<p>Get the distance of a point to a segment.</p>  <em>p</em>, <em>s0</em>, <em>s1</em> are <em>xy</em> sequences <p>This algorithm from <a class="reference external" href="http://geomalgorithms.com/a02-_lines.html" target="_blank">http://geomalgorithms.com/a02-_lines.html</a></p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.distances_along_curve">
<code>matplotlib.mlab.distances_along_curve(X)</code> </dt> <dd>
<p>Computes the distance between a set of successive points in <em>N</em> dimensions.</p> <p>Where <em>X</em> is an <em>M</em> x <em>N</em> array or matrix. The distances between successive rows is computed. Distance is the standard Euclidean distance.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.donothing_callback">
<code>matplotlib.mlab.donothing_callback(*args)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.mlab.entropy">
<code>matplotlib.mlab.entropy(y, bins)</code> </dt> <dd>
<p>Return the entropy of the data in <em>y</em> in units of nat.</p> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAgCAMAAAAi/naRAAAAzFBMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp9KgPAAAAQ3RSTlMAN9XkiPWU4ciAKgsDZ41Qs6kUBvlFwGrNuAgBDvzREKzw5+uFdbtIGKFeJRsicD8WVZrEcabcMkItWsttH31jTaUgkNsnaQAAAmpJREFUSMftVtly4jAQlE+CjQ8wMeawOcx9hoUQjmxCMv//TyslGGQkG0gVtfuw8+DCQ0stSz09QuhvRgbAV6IoQhTiPbgMgLB/enX62j7rYrLZPchsgHL1LDcxi/l7cBVaAFMmK0jje5D1AIobJjvLXjk8dxOZiqVQYbLD6wa/CUxK1pLhFRFAveL7F2KHSZYMFqi7/eRZNljrvctkvxVmX0cuDyiUU2ZZArSerqhFhqsx5wLdx+RJql0A+wdcnxJfGVY3ZZZxCFC6nauTUIUFv5AyjQWgMPKZq936Um6UaK7HoDnctlX7q/y6Sx4Mh7hNW/MvgMCJpxwTrbwNqhUF+rvqTRufhj0gibDHg5FzlNO49BWAGU+tLUchi22ZsT3MEJW1iTnrIPBgZOXpFif4cHYcfUeAES4/X0XbAcVF1pzNkFMmf9OwAw6X87fqhYdT7Gmv8RrnFow6LeJW8IoKBYore+LS4rADDnOlq9r0dLYHkK2Q/XF8D49c33vIwMgeDtKo3jnGXg1xA6hIqv6a534XCvc0DEW4C9qYNV/YpAbPeIkLfeh45GCQ1D4+2xL5We7QMBThEApSnHsS8szGaFrqQNZRTdsR7w1AcXNfT8dVIMB679g07IAjdeEnd7+ayO1WH5GHmkad78ahQ8OOOGuR3O7KnHJY45N5i0RRm/JH5t8RBTviuvNkCe7YVjlW0QQiu342NvyRn16OgkW4l0U1WYJsb6s/rI0MiBf9eCizsIo7ukGCOWslXXmPmLKtShaSJWjFE0+9tgQg//yylEuWoHLyrF0gtg53X+0ON7YGcMND/+MfiD+TgUhK3cszVQAAAABJRU5ErkJggg==" class="center"><p>where <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAABHNCSVQICAgIfAhkiAAAARhJREFUOI3l0r8rxHEcx/HHyY8LoVC3WPxalJnhyi2sBkUWtislFqt/QDdxZVaUhdUiJbKw2W7xozAwWCgRw32uvu6+191g814+7/fz/fm8Pu/35/PmDywR8WeQwRBmsYgUBnCCfC2xZuSCX8AlRkPciQ+M1xLJYBpNeMdSWf4BG7VEUmjBGL4xHMkl8YmtCJvHTjWxNTyWsYkgvBxhPeguBY1lB9I4LWNT+MJBhD1XqyKBF6xGWBL32Axxe6hoH71xIiOh7L0I28YZ2kK8oPiTV4qjUNFOGq/hljxa8YRJvIU9hxgM7RXiKtnFUWyjvy2HLLrikndYr0PkFh1YKYGGsPajDxd1iJxjDsdRmMWN4qNeq5zW/2Y/1wswozpxFqMAAAAASUVORK5CYII=" style="position: relative; bottom: -7px"> is the probability of observing <em>y</em> in the <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAWCAYAAADafVyIAAAABHNCSVQICAgIfAhkiAAAAVxJREFUSInt1D9LXFEQBfBfIttoQIngWliIipvGf0ELA0FRrBQkhdiHELGIgo3kIwSsTGETiL2fQAgIgQSCKOgiqKBoCnERhTSpArG4V3hZ3ibsumKTU825c+ecN3eGxx3jwS3rs3iDGrxNu/CwAtEn6I9xAbvoLnW5EoNFdCR4Lz6XI9CJM0yXyJ+iKcG/4lkpsbQOHuEc+0Xn41jBb7wWnqkOXcjFD/oozKVivMJygo/hGPWRv8PUvzr4G4awkeDD+IAfkQ/goEzNP3CCx8igAV8wGHNZ7MW44aYg2UEP3uMTRlPEm/ATV3iJWmFlN2N+Emt4jrZigwxmMCfs9XyKwSXyUfwQzVjHr5g/EmbRju3i4hcYiXEeSykGt0KL0M1TYQ37qm1wg2Xs3JV4BhdYiLy12gYTwsCyaFTi71gukmuaE56ngFmsVsOgJhF/F3a5G9+wVQ2D/7h/XAPNFTUn2tzEdQAAAABJRU5ErkJggg==" style="position: relative; bottom: -3px"> bin of <em>bins</em>. <em>bins</em> can be a number of bins or a range of bins; see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html#numpy.histogram" title="(in NumPy v1.13)" target="_blank"><code>numpy.histogram()</code></a>.</p> <p>Compare <em>S</em> with analytic calculation for a Gaussian:</p> <pre data-language="python">x = mu + sigma * randn(200000)
Sanalytic = 0.5 * ( 1.0 + log(2*pi*sigma**2.0) )
</pre> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.exp_safe">
<code>matplotlib.mlab.exp_safe(x)</code> </dt> <dd>
<p>Compute exponentials which safely underflow to zero.</p> <p>Slow, but convenient to use. Note that numpy provides proper floating point exception handling with access to the underlying hardware.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.fftsurr">
<code>matplotlib.mlab.fftsurr(x, detrend=&lt;function detrend_none&gt;, window=&lt;function window_none&gt;)</code> </dt> <dd>
<p>Compute an FFT phase randomized surrogate of <em>x</em>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.find">
<code>matplotlib.mlab.find(condition)</code> </dt> <dd>
<p>Return the indices where ravel(condition) is true</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.frange">
<code>matplotlib.mlab.frange([start, ]stop[, step, keywords]) → array of floats</code> </dt> <dd>
<p>Return a numpy ndarray containing a progression of floats. Similar to <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy.arange" title="(in NumPy v1.13)" target="_blank"><code>numpy.arange()</code></a>, but defaults to a closed interval.</p> <p><code>frange(x0, x1)</code> returns <code>[x0, x0+1, x0+2, ..., x1]</code>; <em>start</em> defaults to 0, and the endpoint <em>is included</em>. This behavior is different from that of <a class="reference external" href="https://docs.python.org/2/library/functions.html#range" title="(in Python v2.7)" target="_blank"><code>range()</code></a> and <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy.arange" title="(in NumPy v1.13)" target="_blank"><code>numpy.arange()</code></a>. This is deliberate, since <a class="reference internal" href="#matplotlib.mlab.frange" title="matplotlib.mlab.frange"><code>frange()</code></a> will probably be more useful for generating lists of points for function evaluation, and endpoints are often desired in this use. The usual behavior of <a class="reference external" href="https://docs.python.org/2/library/functions.html#range" title="(in Python v2.7)" target="_blank"><code>range()</code></a> can be obtained by setting the keyword <em>closed</em> = 0, in this case, <a class="reference internal" href="#matplotlib.mlab.frange" title="matplotlib.mlab.frange"><code>frange()</code></a> basically becomes :func:numpy.arange`.</p> <p>When <em>step</em> is given, it specifies the increment (or decrement). All arguments can be floating point numbers.</p> <p><code>frange(x0,x1,d)</code> returns <code>[x0,x0+d,x0+2d,...,xfin]</code> where <em>xfin</em> &lt;= <em>x1</em>.</p> <p><a class="reference internal" href="#matplotlib.mlab.frange" title="matplotlib.mlab.frange"><code>frange()</code></a> can also be called with the keyword <em>npts</em>. This sets the number of points the list should contain (and overrides the value <em>step</em> might have been given). <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy.arange" title="(in NumPy v1.13)" target="_blank"><code>numpy.arange()</code></a> doesn’t offer this option.</p> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; frange(3)
array([ 0.,  1.,  2.,  3.])
&gt;&gt;&gt; frange(3,closed=0)
array([ 0.,  1.,  2.])
&gt;&gt;&gt; frange(1,6,2)
array([1, 3, 5])   or 1,3,5,7, depending on floating point vagueries
&gt;&gt;&gt; frange(1,6.5,npts=5)
array([ 1.   ,  2.375,  3.75 ,  5.125,  6.5  ])
</pre> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.get_formatd">
<code>matplotlib.mlab.get_formatd(r, formatd=None)</code> </dt> <dd>
<p>build a formatd guaranteed to have a key for every dtype name</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.get_sparse_matrix">
<code>matplotlib.mlab.get_sparse_matrix(M, N, frac=0.1)</code> </dt> <dd>
<p>Return a <em>M</em> x <em>N</em> sparse matrix with <em>frac</em> elements randomly filled.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.get_xyz_where">
<code>matplotlib.mlab.get_xyz_where(Z, Cond)</code> </dt> <dd>
<p><em>Z</em> and <em>Cond</em> are <em>M</em> x <em>N</em> matrices. <em>Z</em> are data and <em>Cond</em> is a boolean matrix where some condition is satisfied. Return value is (<em>x</em>, <em>y</em>, <em>z</em>) where <em>x</em> and <em>y</em> are the indices into <em>Z</em> and <em>z</em> are the values of <em>Z</em> at those indices. <em>x</em>, <em>y</em>, and <em>z</em> are 1D arrays.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.griddata">
<code>matplotlib.mlab.griddata(x, y, z, xi, yi, interp='nn')</code> </dt> <dd>
<p>Interpolates from a nonuniformly spaced grid to some other grid.</p> <p>Fits a surface of the form z = f(<code>x</code>, <code>y</code>) to the data in the (usually) nonuniformly spaced vectors (<code>x</code>, <code>y</code>, <code>z</code>), then interpolates this surface at the points specified by (<code>xi</code>, <code>yi</code>) to produce <code>zi</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x, y, z</strong> : 1d array_like</p>  <p>Coordinates of grid points to interpolate from.</p>  <p><strong>xi, yi</strong> : 1d or 2d array_like</p>  <p>Coordinates of grid points to interpolate to.</p>  <p><strong>interp</strong> : string key from {‘nn’, ‘linear’}</p>  <p>Interpolation algorithm, either ‘nn’ for natural neighbor, or ‘linear’ for linear interpolation.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">2d float array</p>  <p>Array of values interpolated at (<code>xi</code>, <code>yi</code>) points. Array will be masked is any of (<code>xi</code>, <code>yi</code>) are outside the convex hull of (<code>x</code>, <code>y</code>).</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If <code>interp</code> is ‘nn’ (the default), uses natural neighbor interpolation based on Delaunay triangulation. This option is only available if the mpl_toolkits.natgrid module is installed. This can be downloaded from <a class="reference external" href="https://github.com/matplotlib/natgrid" target="_blank">https://github.com/matplotlib/natgrid</a>. The (<code>xi</code>, <code>yi</code>) grid must be regular and monotonically increasing in this case.</p> <p>If <code>interp</code> is ‘linear’, linear interpolation is used via matplotlib.tri.LinearTriInterpolator.</p> <p>Instead of using <a class="reference internal" href="#matplotlib.mlab.griddata" title="matplotlib.mlab.griddata"><code>griddata</code></a>, more flexible functionality and other interpolation options are available using a matplotlib.tri.Triangulation and a matplotlib.tri.TriInterpolator.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.identity">
<code>matplotlib.mlab.identity(n, rank=2, dtype='l', typecode=None)</code> </dt> <dd>
<p>Returns the identity matrix of shape (<em>n</em>, <em>n</em>, …, <em>n</em>) (rank <em>r</em>).</p> <p>For ranks higher than 2, this object is simply a multi-index Kronecker delta:</p> <pre data-language="python">                    /  1  if i0=i1=...=iR,
id[i0,i1,...,iR] = -|
                    \  0  otherwise.
</pre> <p>Optionally a <em>dtype</em> (or typecode) may be given (it defaults to ‘l’).</p> <p>Since rank defaults to 2, this function behaves in the default case (when only <em>n</em> is given) like <code>numpy.identity(n)</code> – but surprisingly, it is much faster.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.inside_poly">
<code>matplotlib.mlab.inside_poly(points, verts)</code> </dt> <dd>
<p><em>points</em> is a sequence of <em>x</em>, <em>y</em> points. <em>verts</em> is a sequence of <em>x</em>, <em>y</em> vertices of a polygon.</p> <p>Return value is a sequence of indices into points for the points that are inside the polygon.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.is_closed_polygon">
<code>matplotlib.mlab.is_closed_polygon(X)</code> </dt> <dd>
<p>Tests whether first and last object in a sequence are the same. These are presumably coordinates on a polygonal curve, in which case this function tests if that curve is closed.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.ispower2">
<code>matplotlib.mlab.ispower2(n)</code> </dt> <dd>
<p>Returns the log base 2 of <em>n</em> if <em>n</em> is a power of 2, zero otherwise.</p> <p>Note the potential ambiguity if <em>n</em> == 1: 2**0 == 1, interpret accordingly.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.isvector">
<code>matplotlib.mlab.isvector(X)</code> </dt> <dd>
<p>Like the MATLAB function with the same name, returns <em>True</em> if the supplied numpy array or matrix <em>X</em> looks like a vector, meaning it has a one non-singleton axis (i.e., it can have multiple axes, but all must have length 1, except for one of them).</p> <p>If you just want to see if the array has 1 axis, use X.ndim == 1.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.l1norm">
<code>matplotlib.mlab.l1norm(a)</code> </dt> <dd>
<p>Return the <em>l1</em> norm of <em>a</em>, flattened out.</p> <p>Implemented as a separate function (not a call to <code>norm()</code> for speed).</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.l2norm">
<code>matplotlib.mlab.l2norm(a)</code> </dt> <dd>
<p>Return the <em>l2</em> norm of <em>a</em>, flattened out.</p> <p>Implemented as a separate function (not a call to <code>norm()</code> for speed).</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.less_simple_linear_interpolation">
<code>matplotlib.mlab.less_simple_linear_interpolation(x, y, xi, extrap=False)</code> </dt> <dd>
<p>This function provides simple (but somewhat less so than <code>cbook.simple_linear_interpolation()</code>) linear interpolation. <code>simple_linear_interpolation()</code> will give a list of point between a start and an end, while this does true linear interpolation at an arbitrary set of points.</p> <p>This is very inefficient linear interpolation meant to be used only for a small number of points in relatively non-intensive use cases. For real linear interpolation, use scipy.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.log2">
<code>matplotlib.mlab.log2(x, ln2=0.6931471805599453)</code> </dt> <dd>
<p>Return the log(<em>x</em>) in base 2.</p> <p>This is a _slow_ function but which is guaranteed to return the correct integer value if the input is an integer exact power of 2.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.logspace">
<code>matplotlib.mlab.logspace(xmin, xmax, N)</code> </dt> <dd>
<p>Return N values logarithmically spaced between xmin and xmax.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.longest_contiguous_ones">
<code>matplotlib.mlab.longest_contiguous_ones(x)</code> </dt> <dd>
<p>Return the indices of the longest stretch of contiguous ones in <em>x</em>, assuming <em>x</em> is a vector of zeros and ones. If there are two equally long stretches, pick the first.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.longest_ones">
<code>matplotlib.mlab.longest_ones(x)</code> </dt> <dd>
<p>alias for longest_contiguous_ones</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.magnitude_spectrum">
<code>matplotlib.mlab.magnitude_spectrum(x, Fs=None, window=None, pad_to=None, sides=None)</code> </dt> <dd>
<p>Compute the magnitude (absolute value) of the frequency spectrum of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : 1-D array or sequence</p>  <p>Array or sequence containing the data</p>  <p><strong>Fs</strong> : scalar</p>  <p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p>  <p><strong>window</strong> : callable or ndarray</p>  <p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.13)" target="_blank"><code>numpy.blackman()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.13)" target="_blank"><code>numpy.hamming()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.13)" target="_blank"><code>numpy.bartlett()</code></a>, <code>scipy.signal()</code>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v0.19.1)" target="_blank"><code>scipy.signal.get_window()</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p>  <p><strong>sides</strong> : [ ‘default’ | ‘onesided’ | ‘twosided’ ]</p>  <p>Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. ‘onesided’ forces the return of a one-sided spectrum, while ‘twosided’ forces two-sided.</p>  <p><strong>pad_to</strong> : integer</p>  <p>The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>spectrum</strong> : 1-D array</p>  <p>The values for the magnitude spectrum (real valued)</p>  <p><strong>freqs</strong> : 1-D array</p>  <p>The frequencies corresponding to the elements in <em>spectrum</em></p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd()</code></a> returns the power spectral density.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum()</code></a>
</dt> <dd>This function returns the absolute value of <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum()</code></a>.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum()</code></a> returns the angles of the corresponding frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum()</code></a> returns the phase (unwrapped angle) of the corresponding frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram()</code></a> can return the magnitude spectrum of segments within the signal.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.movavg">
<code>matplotlib.mlab.movavg(x, n)</code> </dt> <dd>
<p>Compute the len(<em>n</em>) moving average of <em>x</em>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.norm_flat">
<code>matplotlib.mlab.norm_flat(a, p=2)</code> </dt> <dd>
<p>norm(a,p=2) -&gt; l-p norm of a.flat</p> <p>Return the l-p norm of <em>a</em>, considered as a flat array. This is NOT a true matrix norm, since arrays of arbitrary rank are always flattened.</p> <p><em>p</em> can be a number or the string ‘Infinity’ to get the L-infinity norm.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.normpdf">
<code>matplotlib.mlab.normpdf(x, *args)</code> </dt> <dd>
<p>Return the normal pdf evaluated at <em>x</em>; args provides <em>mu</em>, <em>sigma</em></p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.offset_line">
<code>matplotlib.mlab.offset_line(y, yerr)</code> </dt> <dd>
<p>Offsets an array <em>y</em> by +/- an error and returns a tuple (y - err, y + err).</p> <p>The error term can be:</p> <ul> <li>A scalar. In this case, the returned tuple is obvious. </li> <li>A vector of the same length as <em>y</em>. The quantities y +/- err are computed component-wise. </li> <li>
<p class="first">A tuple of length 2. In this case, yerr[0] is the error below <em>y</em> and yerr[1] is error above <em>y</em>. For example:</p> <pre data-language="python">from pylab import *
x = linspace(0, 2*pi, num=100, endpoint=True)
y = sin(x)
y_minus, y_plus = mlab.offset_line(y, 0.1)
plot(x, y)
fill_between(x, ym, y2=yp)
show()
</pre> </li> </ul> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.path_length">
<code>matplotlib.mlab.path_length(X)</code> </dt> <dd>
<p>Computes the distance travelled along a polygonal curve in <em>N</em> dimensions.</p> <p>Where <em>X</em> is an <em>M</em> x <em>N</em> array or matrix. Returns an array of length <em>M</em> consisting of the distance along the curve at each point (i.e., the rows of <em>X</em>).</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.phase_spectrum">
<code>matplotlib.mlab.phase_spectrum(x, Fs=None, window=None, pad_to=None, sides=None)</code> </dt> <dd>
<p>Compute the phase of the frequency spectrum (unwrapped angle spectrum) of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : 1-D array or sequence</p>  <p>Array or sequence containing the data</p>  <p><strong>Fs</strong> : scalar</p>  <p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p>  <p><strong>window</strong> : callable or ndarray</p>  <p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.13)" target="_blank"><code>numpy.blackman()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.13)" target="_blank"><code>numpy.hamming()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.13)" target="_blank"><code>numpy.bartlett()</code></a>, <code>scipy.signal()</code>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v0.19.1)" target="_blank"><code>scipy.signal.get_window()</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p>  <p><strong>sides</strong> : [ ‘default’ | ‘onesided’ | ‘twosided’ ]</p>  <p>Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. ‘onesided’ forces the return of a one-sided spectrum, while ‘twosided’ forces two-sided.</p>  <p><strong>pad_to</strong> : integer</p>  <p>The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>spectrum</strong> : 1-D array</p>  <p>The values for the phase spectrum in radians (real valued)</p>  <p><strong>freqs</strong> : 1-D array</p>  <p>The frequencies corresponding to the elements in <em>spectrum</em></p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum()</code></a>
</dt> <dd>This function returns the angle value of <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum()</code></a>.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum()</code></a> returns the magnitudes of the corresponding frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum()</code></a> returns the wrapped version of this function.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram()</code></a> can return the phase spectrum of segments within the signal.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.poly_below">
<code>matplotlib.mlab.poly_below(xmin, xs, ys)</code> </dt> <dd>
<p>Given a sequence of <em>xs</em> and <em>ys</em>, return the vertices of a polygon that has a horizontal base at <em>xmin</em> and an upper bound at the <em>ys</em>. <em>xmin</em> is a scalar.</p> <p>Intended for use with <a class="reference internal" href="../_as_gen/matplotlib.axes.axes.fill/#matplotlib.axes.Axes.fill" title="matplotlib.axes.Axes.fill"><code>matplotlib.axes.Axes.fill()</code></a>, e.g.,:</p> <pre data-language="python">xv, yv = poly_below(0, x, y)
ax.fill(xv, yv)
</pre> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.poly_between">
<code>matplotlib.mlab.poly_between(x, ylower, yupper)</code> </dt> <dd>
<p>Given a sequence of <em>x</em>, <em>ylower</em> and <em>yupper</em>, return the polygon that fills the regions between them. <em>ylower</em> or <em>yupper</em> can be scalar or iterable. If they are iterable, they must be equal in length to <em>x</em>.</p> <p>Return value is <em>x</em>, <em>y</em> arrays for use with <a class="reference internal" href="../_as_gen/matplotlib.axes.axes.fill/#matplotlib.axes.Axes.fill" title="matplotlib.axes.Axes.fill"><code>matplotlib.axes.Axes.fill()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.prctile">
<code>matplotlib.mlab.prctile(x, p=(0.0, 25.0, 50.0, 75.0, 100.0))</code> </dt> <dd>
<p>Return the percentiles of <em>x</em>. <em>p</em> can either be a sequence of percentile values or a scalar. If <em>p</em> is a sequence, the ith element of the return sequence is the <em>p*(i)-th percentile of *x</em>. If <em>p</em> is a scalar, the largest value of <em>x</em> less than or equal to the <em>p</em> percentage point in the sequence is returned.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.prctile_rank">
<code>matplotlib.mlab.prctile_rank(x, p)</code> </dt> <dd>
<p>Return the rank for each element in <em>x</em>, return the rank 0..len(<em>p</em>). e.g., if <em>p</em> = (25, 50, 75), the return value will be a len(<em>x</em>) array with values in [0,1,2,3] where 0 indicates the value is less than the 25th percentile, 1 indicates the value is &gt;= the 25th and &lt; 50th percentile, … and 3 indicates the value is above the 75th percentile cutoff.</p> <p><em>p</em> is either an array of percentiles in [0..100] or a scalar which indicates how many quantiles of data you want ranked.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.psd">
<code>matplotlib.mlab.psd(x, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None)</code> </dt> <dd>
<p>Compute the power spectral density.</p> <p>Call signature:</p> <pre data-language="python">psd(x, NFFT=256, Fs=2, detrend=mlab.detrend_none,
    window=mlab.window_hanning, noverlap=0, pad_to=None,
    sides='default', scale_by_freq=None)
</pre> <p>The power spectral density <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAWCAYAAADXYyzPAAAABHNCSVQICAgIfAhkiAAAAVlJREFUSInt1T1LXEEUxvFfNKImiinERoQlggFRCIIWC6t1ICiogVS2qdKlTiP4BSwtQmoj+AHElxSxE7SwyRYBC8FGsZAEhaSYWQuZu7uue02hTzMw/3vnOWfOmRn+k54k5tqxjiG8xDEOIutAP/bxGYd5BPUefzGXCGwNpyjkYbwcjfsS7G1ki40u3lKFlVDGSYJ1xbG72cY9GMWPDD4VxyzesN4IW/khwXqF+m5JN+edtBSNR27MDwlZruL5XQyeZsyXcImPMQBowwU+yWGLCcflN7bzWLyiVHONR/Pv921ciuNOnsapGlfqu1vj30kMYkIIshszwk33pxa/mXEbitgTGilLLzCAL/HbeXzDGa7q4NcqYAM/hS4+xyZmM4yfxSBhBQu35E3RLyE7wo1XF692V1fTtHDGXwtP5RE68a5OrrVB4yKGhWNXxiuM4atQw1r8UQ9A/wAVTEZIG479kAAAAABJRU5ErkJggg==" style="position: relative; bottom: -6px"> by Welch’s average periodogram method. The vector <em>x</em> is divided into <em>NFFT</em> length segments. Each segment is detrended by function <em>detrend</em> and windowed by function <em>window</em>. <em>noverlap</em> gives the length of the overlap between segments. The <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAAaCAMAAAAzFaRVAAAAvVBMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJQ2gvAAAAPnRSTlMAtZOIYIAFIKDgTRgm0r97AXb7qZoxcI5yRLsbyesM1WxzPkHcVq3mxFkRuM4vF1EJE/j2OUhGNilmOrLkpoqvrSAAAAGESURBVDjLzZRpW4JAEMdngcC45RCEPPBITU1Ry7Ta7/+xAoaz8EGfXtS8+LPLzG+HnR0W4A9MDJzPsDmMr30ruAAMaYS1Qz5k30qpd1sQ9zhmpFg7FtEyzWx4Sh7ybArQV6U8mrcjn4IxLSGGH3Rzkmpoo0NW8Wmv1pEel0V0tIAyKtEDF/h+qmMOHY/TyjbU1xLtiFCi7xMClUFa+KjWbOMV9HAEci3Nb3ZIt81qCUMjzKIXoiS1c3pM9hPSRh0SqhASrey5iXvNeF0MHCxS+mxQSkk59x3kSjF3L9knz+jOe1oHtth3bhfoPj0mux2D4mCgZV5P+zSpi6/bND1BdnkLnXYXo2TtRq6lg+jLz9gXPReQsFrX0LsT8NF59LAhROM51BqqNos9qaoMjKI+XOKJBivQsMUVrp5+Uajx0EWN+9uKkwV4UP487con6l/KXfcX97516hxuoMHkKlNvehMtrPTSzJ7rddF4O9QZxxbjrSo3RP+wTre4mQ6/uUZ5+F/2BQ6bHlvIndEyAAAAAElFTkSuQmCC" style="position: relative; bottom: -8px"> of each segment <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAASCAYAAABmQp92AAAABHNCSVQICAgIfAhkiAAAAJRJREFUKJGtzzEOAWEUReEPmU6n0ChUdIQtiG4SpTVodTahIFFbgEo9G1AodKJUCLEFCc0/yWRimuF2L+fk5j5KpIMbplD9ItRxx7lM+4/pY40EozyMsEEFS+xTkH4RY4c3xrjkG1pBHgZpULRjhVMRjPDEPNztvBDjhSYaWGRHQjfUPzDDFmoZ4YoJejjgWLTlz/kA1EYWGyDI+xEAAAAASUVORK5CYII=" style="position: relative; bottom: -3px"> are averaged to compute <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAWCAYAAADXYyzPAAAABHNCSVQICAgIfAhkiAAAAVlJREFUSInt1T1LXEEUxvFfNKImiinERoQlggFRCIIWC6t1ICiogVS2qdKlTiP4BSwtQmoj+AHElxSxE7SwyRYBC8FGsZAEhaSYWQuZu7uue02hTzMw/3vnOWfOmRn+k54k5tqxjiG8xDEOIutAP/bxGYd5BPUefzGXCGwNpyjkYbwcjfsS7G1ki40u3lKFlVDGSYJ1xbG72cY9GMWPDD4VxyzesN4IW/khwXqF+m5JN+edtBSNR27MDwlZruL5XQyeZsyXcImPMQBowwU+yWGLCcflN7bzWLyiVHONR/Pv921ciuNOnsapGlfqu1vj30kMYkIIshszwk33pxa/mXEbitgTGilLLzCAL/HbeXzDGa7q4NcqYAM/hS4+xyZmM4yfxSBhBQu35E3RLyE7wo1XF692V1fTtHDGXwtP5RE68a5OrrVB4yKGhWNXxiuM4atQw1r8UQ9A/wAVTEZIG479kAAAAABJRU5ErkJggg==" style="position: relative; bottom: -6px">.</p> <p>If len(<em>x</em>) &lt; <em>NFFT</em>, it will be zero padded to <em>NFFT</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : 1-D array or sequence</p>  <p>Array or sequence containing the data</p>  <p><strong>Fs</strong> : scalar</p>  <p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p>  <p><strong>window</strong> : callable or ndarray</p>  <p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.13)" target="_blank"><code>numpy.blackman()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.13)" target="_blank"><code>numpy.hamming()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.13)" target="_blank"><code>numpy.bartlett()</code></a>, <code>scipy.signal()</code>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v0.19.1)" target="_blank"><code>scipy.signal.get_window()</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p>  <p><strong>sides</strong> : [ ‘default’ | ‘onesided’ | ‘twosided’ ]</p>  <p>Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. ‘onesided’ forces the return of a one-sided spectrum, while ‘twosided’ forces two-sided.</p>  <p><strong>pad_to</strong> : integer</p>  <p>The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p>  <p><strong>NFFT</strong> : integer</p>  <p>The number of data points used in each block for the FFT. A power 2 is most efficient. The default value is 256. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect. Use <em>pad_to</em> for this instead.</p>  <p><strong>detrend</strong> : {‘default’, ‘constant’, ‘mean’, ‘linear’, ‘none’} or callable</p>  <p>The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in matplotlib is it a function. The <code>pylab</code> module defines <code>detrend_none()</code>, <code>detrend_mean()</code>, and <code>detrend_linear()</code>, but you can use a custom function as well. You can also use a string to choose one of the functions. ‘default’, ‘constant’, and ‘mean’ call <code>detrend_mean()</code>. ‘linear’ calls <code>detrend_linear()</code>. ‘none’ calls <code>detrend_none()</code>.</p>  <p><strong>scale_by_freq</strong> : boolean, optional</p>  <p>Specifies whether the resulting density values should be scaled by the scaling frequency, which gives density in units of Hz^-1. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p>  <p><strong>noverlap</strong> : integer</p>  <p>The number of points of overlap between segments. The default value is 0 (no overlap).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>Pxx</strong> : 1-D array</p>  <p>The values for the power spectrum <code>P_{xx}</code> (real valued)</p>  <p><strong>freqs</strong> : 1-D array</p>  <p>The frequencies corresponding to the elements in <em>Pxx</em></p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram()</code></a> differs in the default overlap; in not returning the mean of the segment periodograms; and in returning the times of the segments.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum()</code></a> returns the magnitude spectrum.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code>csd()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code>csd()</code></a> returns the spectral density between two signals.</dd> </dl> </div> <h4 class="rubric">References</h4> <p>Bendat &amp; Piersol – Random Data: Analysis and Measurement Procedures, John Wiley &amp; Sons (1986)</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.quad2cubic">
<code>matplotlib.mlab.quad2cubic(q0x, q0y, q1x, q1y, q2x, q2y)</code> </dt> <dd>
<p>Converts a quadratic Bezier curve to a cubic approximation.</p> <p>The inputs are the <em>x</em> and <em>y</em> coordinates of the three control points of a quadratic curve, and the output is a tuple of <em>x</em> and <em>y</em> coordinates of the four control points of the cubic curve.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.rec2csv">
<code>matplotlib.mlab.rec2csv(r, fname, delimiter=', ', formatd=None, missing='', missingd=None, withheader=True)</code> </dt> <dd>
<p>Save the data from numpy recarray <em>r</em> into a comma-/space-/tab-delimited file. The record array dtype names will be used for column headers.</p> <dl class="docutils"> <dt>
<em>fname</em>: can be a filename or a file handle. Support for gzipped</dt> <dd>files is automatic, if the filename ends in ‘.gz’</dd> <dt>
<em>withheader</em>: if withheader is False, do not write the attribute</dt> <dd>names in the first row</dd> </dl> <p>for formatd type FormatFloat, we override the precision to store full precision floats in the CSV file</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.csv2rec" title="matplotlib.mlab.csv2rec"><code>csv2rec()</code></a>
</dt> <dd>For information about <em>missing</em> and <em>missingd</em>, which can be used to fill in masked values into your CSV file.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.rec2txt">
<code>matplotlib.mlab.rec2txt(r, header=None, padding=3, precision=3, fields=None)</code> </dt> <dd>
<p>Returns a textual representation of a record array.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>r: numpy recarray</strong></p> <p><strong>header: list</strong></p>  <p>column headers</p>  <p><strong>padding:</strong></p>  <p>space between each column</p>  <p><strong>precision: number of decimal places to use for floats.</strong></p>  <p>Set to an integer to apply to all floats. Set to a list of integers to apply precision individually. Precision for non-floats is simply ignored.</p>  <p><strong>fields</strong> : list</p>  <p>If not None, a list of field names to print. fields can be a list of strings like [‘field1’, ‘field2’] or a single comma separated string like ‘field1,field2’</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <p>For <code>precision=[0,2,3]</code>, the output is</p> <pre data-language="python">ID    Price   Return
ABC   12.54    0.234
XYZ    6.32   -0.076
</pre> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.rec_append_fields">
<code>matplotlib.mlab.rec_append_fields(rec, names, arrs, dtypes=None)</code> </dt> <dd>
<p>Return a new record array with field names populated with data from arrays in <em>arrs</em>. If appending a single field, then <em>names</em>, <em>arrs</em> and <em>dtypes</em> do not have to be lists. They can just be the values themselves.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.rec_drop_fields">
<code>matplotlib.mlab.rec_drop_fields(rec, names)</code> </dt> <dd>
<p>Return a new numpy record array with fields in <em>names</em> dropped.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.rec_groupby">
<code>matplotlib.mlab.rec_groupby(r, groupby, stats)</code> </dt> <dd>
<p><em>r</em> is a numpy record array</p> <p><em>groupby</em> is a sequence of record array attribute names that together form the grouping key. e.g., (‘date’, ‘productcode’)</p> <p><em>stats</em> is a sequence of (<em>attr</em>, <em>func</em>, <em>outname</em>) tuples which will call <code>x = func(attr)</code> and assign <em>x</em> to the record array output with attribute <em>outname</em>. For example:</p> <pre data-language="python">stats = ( ('sales', len, 'numsales'), ('sales', np.mean, 'avgsale') )
</pre> <p>Return record array has <em>dtype</em> names for each attribute name in the <em>groupby</em> argument, with the associated group values, and for each outname name in the <em>stats</em> argument, with the associated stat summary output.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.rec_join">
<code>matplotlib.mlab.rec_join(key, r1, r2, jointype='inner', defaults=None, r1postfix='1', r2postfix='2')</code> </dt> <dd>
<p>Join record arrays <em>r1</em> and <em>r2</em> on <em>key</em>; <em>key</em> is a tuple of field names – if <em>key</em> is a string it is assumed to be a single attribute name. If <em>r1</em> and <em>r2</em> have equal values on all the keys in the <em>key</em> tuple, then their fields will be merged into a new record array containing the intersection of the fields of <em>r1</em> and <em>r2</em>.</p> <p><em>r1</em> (also <em>r2</em>) must not have any duplicate keys.</p> <p>The <em>jointype</em> keyword can be ‘inner’, ‘outer’, ‘leftouter’. To do a rightouter join just reverse <em>r1</em> and <em>r2</em>.</p> <p>The <em>defaults</em> keyword is a dictionary filled with <code>{column_name:default_value}</code> pairs.</p> <p>The keywords <em>r1postfix</em> and <em>r2postfix</em> are postfixed to column names (other than keys) that are both in <em>r1</em> and <em>r2</em>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.rec_keep_fields">
<code>matplotlib.mlab.rec_keep_fields(rec, names)</code> </dt> <dd>
<p>Return a new numpy record array with only fields listed in names</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.rec_summarize">
<code>matplotlib.mlab.rec_summarize(r, summaryfuncs)</code> </dt> <dd>
<p><em>r</em> is a numpy record array</p> <p><em>summaryfuncs</em> is a list of (<em>attr</em>, <em>func</em>, <em>outname</em>) tuples which will apply <em>func</em> to the array <em>r*[attr] and assign the output to a new attribute name *outname</em>. The returned record array is identical to <em>r</em>, with extra arrays for each element in <em>summaryfuncs</em>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.recs_join">
<code>matplotlib.mlab.recs_join(key, name, recs, jointype='outer', missing=0.0, postfixes=None)</code> </dt> <dd>
<p>Join a sequence of record arrays on single column key.</p> <p>This function only joins a single column of the multiple record arrays</p> <dl class="docutils"> <dt><em>key</em></dt> <dd>is the column name that acts as a key</dd> <dt><em>name</em></dt> <dd>is the name of the column that we want to join</dd> <dt><em>recs</em></dt> <dd>is a list of record arrays to join</dd> <dt><em>jointype</em></dt> <dd>is a string ‘inner’ or ‘outer’</dd> <dt><em>missing</em></dt> <dd>is what any missing field is replaced by</dd> <dt><em>postfixes</em></dt> <dd>if not None, a len recs sequence of postfixes</dd> </dl> <p>returns a record array with columns [rowkey, name0, name1, … namen-1]. or if postfixes [PF0, PF1, …, PFN-1] are supplied, [rowkey, namePF0, namePF1, … namePFN-1].</p> <p>Example:</p> <pre data-language="python">r = recs_join("date", "close", recs=[r0, r1], missing=0.)
</pre> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.rk4">
<code>matplotlib.mlab.rk4(derivs, y0, t)</code> </dt> <dd>
<p>Integrate 1D or ND system of ODEs using 4-th order Runge-Kutta. This is a toy implementation which may be useful if you find yourself stranded on a system w/o scipy. Otherwise use <code>scipy.integrate()</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>y0</strong></p>  <p>initial state vector</p>  <p><strong>t</strong></p>  <p>sample times</p>  <p><strong>derivs</strong></p>  <p>returns the derivative of the system and has the signature <code>dy = derivs(yi, ti)</code></p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <p>A 2D system:</p> <pre data-language="python">def derivs6(x,t):
    d1 =  x[0] + 2*x[1]
    d2 =  -3*x[0] + 4*x[1]
    return (d1, d2)
dt = 0.0005
t = arange(0.0, 2.0, dt)
y0 = (1,2)
yout = rk4(derivs6, y0, t)
</pre> <p>A 1D system:</p> <pre data-language="python">alpha = 2
def derivs(x,t):
    return -alpha*x + exp(-t)

y0 = 1
yout = rk4(derivs, y0, t)
</pre> <p>If you have access to scipy, you should probably be using the scipy.integrate tools rather than this function.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.rms_flat">
<code>matplotlib.mlab.rms_flat(a)</code> </dt> <dd>
<p>Return the root mean square of all the elements of <em>a</em>, flattened out.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.safe_isinf">
<code>matplotlib.mlab.safe_isinf(x)</code> </dt> <dd>
<p><code>numpy.isinf()</code> for arbitrary types</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.safe_isnan">
<code>matplotlib.mlab.safe_isnan(x)</code> </dt> <dd>
<p><code>numpy.isnan()</code> for arbitrary types</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.segments_intersect">
<code>matplotlib.mlab.segments_intersect(s1, s2)</code> </dt> <dd>
<p>Return <em>True</em> if <em>s1</em> and <em>s2</em> intersect. <em>s1</em> and <em>s2</em> are defined as:</p> <pre data-language="python">s1: (x1, y1), (x2, y2)
s2: (x3, y3), (x4, y4)
</pre> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.slopes">
<code>matplotlib.mlab.slopes(x, y)</code> </dt> <dd>
<p><a class="reference internal" href="#matplotlib.mlab.slopes" title="matplotlib.mlab.slopes"><code>slopes()</code></a> calculates the slope <em>y</em>’(<em>x</em>)</p> <p>The slope is estimated using the slope obtained from that of a parabola through any three consecutive points.</p> <p>This method should be superior to that described in the appendix of A CONSISTENTLY WELL BEHAVED METHOD OF INTERPOLATION by Russel W. Stineman (Creative Computing July 1980) in at least one aspect:</p>  Circles for interpolation demand a known aspect ratio between <em>x</em>- and <em>y</em>-values. For many functions, however, the abscissa are given in different dimensions, so an aspect ratio is completely arbitrary. <p>The parabola method gives very similar results to the circle method for most regular cases but behaves much better in special cases.</p> <p>Norbert Nemec, Institute of Theoretical Physics, University or Regensburg, April 2006 Norbert.Nemec at physik.uni-regensburg.de</p> <p>(inspired by a original implementation by Halldor Bjornsson, Icelandic Meteorological Office, March 2006 halldor at vedur.is)</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.specgram">
<code>matplotlib.mlab.specgram(x, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, mode=None)</code> </dt> <dd>
<p>Compute a spectrogram.</p> <p>Compute and plot a spectrogram of data in x. Data are split into NFFT length segments and the spectrum of each section is computed. The windowing function window is applied to each segment, and the amount of overlap of each segment is specified with noverlap.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array_like</p>  <p>1-D array or sequence.</p>  <p><strong>Fs</strong> : scalar</p>  <p>The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p>  <p><strong>window</strong> : callable or ndarray</p>  <p>A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.13)" target="_blank"><code>numpy.blackman()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.13)" target="_blank"><code>numpy.hamming()</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.13)" target="_blank"><code>numpy.bartlett()</code></a>, <code>scipy.signal()</code>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v0.19.1)" target="_blank"><code>scipy.signal.get_window()</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p>  <p><strong>sides</strong> : [ ‘default’ | ‘onesided’ | ‘twosided’ ]</p>  <p>Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. ‘onesided’ forces the return of a one-sided spectrum, while ‘twosided’ forces two-sided.</p>  <p><strong>pad_to</strong> : integer</p>  <p>The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p>  <p><strong>NFFT</strong> : integer</p>  <p>The number of data points used in each block for the FFT. A power 2 is most efficient. The default value is 256. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect. Use <em>pad_to</em> for this instead.</p>  <p><strong>detrend</strong> : {‘default’, ‘constant’, ‘mean’, ‘linear’, ‘none’} or callable</p>  <p>The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in matplotlib is it a function. The <code>pylab</code> module defines <code>detrend_none()</code>, <code>detrend_mean()</code>, and <code>detrend_linear()</code>, but you can use a custom function as well. You can also use a string to choose one of the functions. ‘default’, ‘constant’, and ‘mean’ call <code>detrend_mean()</code>. ‘linear’ calls <code>detrend_linear()</code>. ‘none’ calls <code>detrend_none()</code>.</p>  <p><strong>scale_by_freq</strong> : boolean, optional</p>  <p>Specifies whether the resulting density values should be scaled by the scaling frequency, which gives density in units of Hz^-1. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p>  <p><strong>noverlap</strong> : int, optional</p>  <p>The number of points of overlap between blocks. The default value is 128.</p>  <p><strong>mode</strong> : str, optional</p>  <dl class="docutils"> <dt>What sort of spectrum to use, default is ‘psd’.</dt> <dd>
<dl class="first last docutils"> <dt>‘psd’</dt> <dd>
<p class="first last">Returns the power spectral density.</p> </dd> <dt>‘complex’</dt> <dd>
<p class="first last">Returns the complex-valued frequency spectrum.</p> </dd> <dt>‘magnitude’</dt> <dd>
<p class="first last">Returns the magnitude spectrum.</p> </dd> <dt>‘angle’</dt> <dd>
<p class="first last">Returns the phase spectrum without unwrapping.</p> </dd> <dt>‘phase’</dt> <dd>
<p class="first last">Returns the phase spectrum with unwrapping.</p> </dd> </dl> </dd> </dl>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>spectrum</strong> : array_like</p>  <p>2-D array, columns are the periodograms of successive segments.</p>  <p><strong>freqs</strong> : array_like</p>  <p>1-D array, frequencies corresponding to the rows in <em>spectrum</em>.</p>  <p><strong>t</strong> : array_like</p>  <p>1-D array, the times corresponding to midpoints of segments (i.e the columns in <em>spectrum</em>).</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a>
</dt> <dd>differs in the overlap and in the return values.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>
</dt> <dd>similar, but with complex valued frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a>
</dt> <dd>similar single segment when mode is ‘magnitude’.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a>
</dt> <dd>similar to single segment when mode is ‘angle’.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a>
</dt> <dd>similar to single segment when mode is ‘phase’.</dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>detrend and scale_by_freq only apply when <em>mode</em> is set to ‘psd’.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.stineman_interp">
<code>matplotlib.mlab.stineman_interp(xi, x, y, yp=None)</code> </dt> <dd>
<p>Given data vectors <em>x</em> and <em>y</em>, the slope vector <em>yp</em> and a new abscissa vector <em>xi</em>, the function <a class="reference internal" href="#matplotlib.mlab.stineman_interp" title="matplotlib.mlab.stineman_interp"><code>stineman_interp()</code></a> uses Stineman interpolation to calculate a vector <em>yi</em> corresponding to <em>xi</em>.</p> <p>Here’s an example that generates a coarse sine curve, then interpolates over a finer abscissa:</p> <pre data-language="python">x = linspace(0,2*pi,20);  y = sin(x); yp = cos(x)
xi = linspace(0,2*pi,40);
yi = stineman_interp(xi,x,y,yp);
plot(x,y,'o',xi,yi)
</pre> <p>The interpolation method is described in the article A CONSISTENTLY WELL BEHAVED METHOD OF INTERPOLATION by Russell W. Stineman. The article appeared in the July 1980 issue of Creative Computing with a note from the editor stating that while they were:</p>  not an academic journal but once in a while something serious and original comes in adding that this was “apparently a real solution” to a well known problem. <p>For <em>yp</em> = <em>None</em>, the routine automatically determines the slopes using the <a class="reference internal" href="#matplotlib.mlab.slopes" title="matplotlib.mlab.slopes"><code>slopes()</code></a> routine.</p> <p><em>x</em> is assumed to be sorted in increasing order.</p> <p>For values <code>xi[j] &lt; x[0]</code> or <code>xi[j] &gt; x[-1]</code>, the routine tries an extrapolation. The relevance of the data obtained from this, of course, is questionable…</p> <p>Original implementation by Halldor Bjornsson, Icelandic Meteorolocial Office, March 2006 halldor at vedur.is</p> <p>Completely reworked and optimized for Python by Norbert Nemec, Institute of Theoretical Physics, University or Regensburg, April 2006 Norbert.Nemec at physik.uni-regensburg.de</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.stride_repeat">
<code>matplotlib.mlab.stride_repeat(x, n, axis=0)</code> </dt> <dd>
<p>Repeat the values in an array in a memory-efficient manner. Array x is stacked vertically n times.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">It is not safe to write to the output array. Multiple elements may point to the same piece of memory, so modifying one value may change others.</p> </div> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : 1D array or sequence</p>  <p>Array or sequence containing the data.</p>  <p><strong>n</strong> : integer</p>  <p>The number of time to repeat the array.</p>  <p><strong>axis</strong> : integer</p>  <p>The axis along which the data will run.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <p><a class="reference external" href="http://stackoverflow.com/a/5568169" target="_blank">stackoverflow: Repeat NumPy array without replicating data?</a></p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.stride_windows">
<code>matplotlib.mlab.stride_windows(x, n, noverlap=None, axis=0)</code> </dt> <dd>
<p>Get all windows of x with length n as a single array, using strides to avoid data duplication.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">It is not safe to write to the output array. Multiple elements may point to the same piece of memory, so modifying one value may change others.</p> </div> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : 1D array or sequence</p>  <p>Array or sequence containing the data.</p>  <p><strong>n</strong> : integer</p>  <p>The number of data points in each window.</p>  <p><strong>noverlap</strong> : integer</p>  <p>The overlap between adjacent windows. Default is 0 (no overlap)</p>  <p><strong>axis</strong> : integer</p>  <p>The axis along which the windows will run.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <p><a class="reference external" href="http://stackoverflow.com/a/6811241" target="_blank">stackoverflow: Rolling window for 1D arrays in Numpy?</a> <a class="reference external" href="http://stackoverflow.com/a/4947453" target="_blank">stackoverflow: Using strides for an efficient moving average filter</a></p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.vector_lengths">
<code>matplotlib.mlab.vector_lengths(X, P=2.0, axis=None)</code> </dt> <dd>
<p>Finds the length of a set of vectors in <em>n</em> dimensions. This is like the <code>numpy.norm()</code> function for vectors, but has the ability to work over a particular axis of the supplied array or matrix.</p> <p>Computes <code>(sum((x_i)^P))^(1/P)</code> for each <code>{x_i}</code> being the elements of <em>X</em> along the given axis. If <em>axis</em> is <em>None</em>, compute over all elements of <em>X</em>.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.window_hanning">
<code>matplotlib.mlab.window_hanning(x)</code> </dt> <dd>
<p>Return x times the hanning window of len(x).</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none()</code></a> is another window algorithm.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.window_none">
<code>matplotlib.mlab.window_none(x)</code> </dt> <dd>
<p>No window function; simply return x.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning()</code></a> is another window algorithm.</dd> </dl> </div> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/2.1.0/api/mlab_api.html" class="_attribution-link" target="_blank">http://matplotlib.org/2.1.0/api/mlab_api.html</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
