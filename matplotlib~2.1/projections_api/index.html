
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Projections - Matplotlib 2.1 - W3cubDocs</title>
  
  <meta name="description" content=" Bases&#58; object ">
  <meta name="keywords" content="projections, -, matplotlib, matplotlib~2.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~2.1/projections_api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/matplotlib~2.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~2.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 2.1</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
				
<h1 id="projections">projections</h1>  <h2 id="matplotlib-projections">matplotlib.projections</h2> <dl class="class" id="module-matplotlib.projections"> <dt id="matplotlib.projections.ProjectionRegistry">
<code>class matplotlib.projections.ProjectionRegistry</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Manages the set of projections available to the system.</p> <dl class="method"> <dt id="matplotlib.projections.ProjectionRegistry.get_projection_class">
<code>get_projection_class(name)</code> </dt> <dd>
<p>Get a projection class from its <em>name</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.ProjectionRegistry.get_projection_names">
<code>get_projection_names()</code> </dt> <dd>
<p>Get a list of the names of all projections currently registered.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.ProjectionRegistry.register">
<code>register(*projections)</code> </dt> <dd>
<p>Register a new set of projection(s).</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.projections.get_projection_class">
<code>matplotlib.projections.get_projection_class(projection=None)</code> </dt> <dd>
<p>Get a projection class from its name.</p> <p>If <em>projection</em> is None, a standard rectilinear projection is returned.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.projections.get_projection_names">
<code>matplotlib.projections.get_projection_names()</code> </dt> <dd>
<p>Get a list of acceptable projection names.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.projections.process_projection_requirements">
<code>matplotlib.projections.process_projection_requirements(figure, *args, **kwargs)</code> </dt> <dd>
<p>Handle the args/kwargs to for add_axes/add_subplot/gca, returning:</p> <pre data-language="python">(axes_proj_class, proj_class_kwargs, proj_stack_key)
</pre> <p>Which can be used for new axes initialization/identification.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><strong>kwargs</strong> is modified in place.</p> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.projections.register_projection">
<code>matplotlib.projections.register_projection(cls)</code> </dt> 
</dl>   <h2 id="matplotlib-projections-polar">matplotlib.projections.polar</h2> <dl class="class" id="module-matplotlib.projections.polar"> <dt id="matplotlib.projections.polar.InvertedPolarTransform">
<code>class matplotlib.projections.polar.InvertedPolarTransform(axis=None, use_rmin=True, _apply_theta_transforms=True)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>The inverse of the polar transform, mapping Cartesian coordinate space <em>x</em> and <em>y</em> back to <em>theta</em> and <em>r</em>.</p> <dl class="attribute"> <dt id="matplotlib.projections.polar.InvertedPolarTransform.input_dims">
<code>input_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.InvertedPolarTransform.inverted">
<code>inverted()</code> </dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.projections.polar.InvertedPolarTransform.is_separable">
<code>is_separable = False</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.projections.polar.InvertedPolarTransform.output_dims">
<code>output_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.InvertedPolarTransform.transform_non_affine">
<code>transform_non_affine(xy)</code> </dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.projections.polar.InvertedPolarTransform.input_dims" title="matplotlib.projections.polar.InvertedPolarTransform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.projections.polar.InvertedPolarTransform.output_dims" title="matplotlib.projections.polar.InvertedPolarTransform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.projections.polar.InvertedPolarTransform.input_dims" title="matplotlib.projections.polar.InvertedPolarTransform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.projections.polar.InvertedPolarTransform.output_dims" title="matplotlib.projections.polar.InvertedPolarTransform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.PolarAffine">
<code>class matplotlib.projections.polar.PolarAffine(scale_transform, limits)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../transformations/#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>The affine part of the polar projection. Scales the output so that maximum radius rests on the edge of the axes circle.</p> <p><em>limits</em> is the view limit of the data. The only part of its bounds that is used is the y limits (for the radius limits). The theta range is handled by the non-affine transform.</p> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAffine.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.PolarAxes">
<code>class matplotlib.projections.polar.PolarAxes(*args, **kwargs)</code> </dt> <dd>
<p>Bases: <code>matplotlib.axes._axes.Axes</code></p> <p>A polar graph projection, where the input dimensions are <em>theta</em>, <em>r</em>.</p> <p>Theta starts pointing east and goes anti-clockwise.</p> <dl class="class"> <dt id="matplotlib.projections.polar.PolarAxes.InvertedPolarTransform">
<code>class InvertedPolarTransform(axis=None, use_rmin=True, _apply_theta_transforms=True)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>The inverse of the polar transform, mapping Cartesian coordinate space <em>x</em> and <em>y</em> back to <em>theta</em> and <em>r</em>.</p> <dl class="attribute"> <dt id="matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.input_dims">
<code>input_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.inverted">
<code>inverted()</code> </dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.is_separable">
<code>is_separable = False</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.output_dims">
<code>output_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.transform_non_affine">
<code>transform_non_affine(xy)</code> </dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.input_dims" title="matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.output_dims" title="matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.input_dims" title="matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.output_dims" title="matplotlib.projections.polar.PolarAxes.InvertedPolarTransform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.PolarAxes.PolarAffine">
<code>class PolarAffine(scale_transform, limits)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../transformations/#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>The affine part of the polar projection. Scales the output so that maximum radius rests on the edge of the axes circle.</p> <p><em>limits</em> is the view limit of the data. The only part of its bounds that is used is the y limits (for the radius limits). The theta range is handled by the non-affine transform.</p> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.PolarAffine.get_matrix">
<code>get_matrix()</code> </dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.PolarAxes.PolarTransform">
<code>class PolarTransform(axis=None, use_rmin=True, _apply_theta_transforms=True)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>The base polar transform. This handles projection <em>theta</em> and <em>r</em> into Cartesian coordinate space <em>x</em> and <em>y</em>, but does not perform the ultimate affine transformation into the correct position.</p> <dl class="attribute"> <dt id="matplotlib.projections.polar.PolarAxes.PolarTransform.input_dims">
<code>input_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.PolarTransform.inverted">
<code>inverted()</code> </dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.projections.polar.PolarAxes.PolarTransform.is_separable">
<code>is_separable = False</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.projections.polar.PolarAxes.PolarTransform.output_dims">
<code>output_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.PolarTransform.transform_non_affine">
<code>transform_non_affine(tr)</code> </dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.projections.polar.PolarAxes.PolarTransform.input_dims" title="matplotlib.projections.polar.PolarAxes.PolarTransform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.projections.polar.PolarAxes.PolarTransform.output_dims" title="matplotlib.projections.polar.PolarAxes.PolarTransform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.projections.polar.PolarAxes.PolarTransform.input_dims" title="matplotlib.projections.polar.PolarAxes.PolarTransform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.projections.polar.PolarAxes.PolarTransform.output_dims" title="matplotlib.projections.polar.PolarAxes.PolarTransform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.PolarTransform.transform_path_non_affine">
<code>transform_path_non_affine(path)</code> </dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.PolarAxes.RadialLocator">
<code>class RadialLocator(base, axes=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../ticker_api/#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Used to locate radius ticks.</p> <p>Ensures that all ticks are strictly positive. For all other tasks, it delegates to the base <a class="reference internal" href="../ticker_api/#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>Locator</code></a> (which may be different depending on the scale of the <em>r</em>-axis.</p> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.RadialLocator.autoscale">
<code>autoscale()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.RadialLocator.pan">
<code>pan(numsteps)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.RadialLocator.refresh">
<code>refresh()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.RadialLocator.view_limits">
<code>view_limits(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.RadialLocator.zoom">
<code>zoom(direction)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.PolarAxes.ThetaFormatter">
<code>class ThetaFormatter</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../ticker_api/#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Used to format the <em>theta</em> tick labels. Converts the native unit of radians into degrees and adds a degree symbol.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.PolarAxes.ThetaLocator">
<code>class ThetaLocator(base)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../ticker_api/#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Used to locate theta ticks.</p> <p>This will work the same as the base locator except in the case that the view spans the entire circle. In such cases, the previously used default locations of every 45 degrees are returned.</p> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.ThetaLocator.autoscale">
<code>autoscale()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.ThetaLocator.pan">
<code>pan(numsteps)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.ThetaLocator.refresh">
<code>refresh()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.ThetaLocator.set_axis">
<code>set_axis(axis)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.ThetaLocator.view_limits">
<code>view_limits(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.ThetaLocator.zoom">
<code>zoom(direction)</code> </dt> 
</dl> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.can_pan">
<code>can_pan()</code> </dt> <dd>
<p>Return <em>True</em> if this axes supports the pan/zoom button functionality.</p> <p>For polar axes, this is slightly misleading. Both panning and zooming are performed by the same button. Panning is performed in azimuth while zooming is done along the radial.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.can_zoom">
<code>can_zoom()</code> </dt> <dd>
<p>Return <em>True</em> if this axes supports the zoom box button functionality.</p> <p>Polar axes do not support zoom boxes.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.cla">
<code>cla()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.drag_pan">
<code>drag_pan(button, key, x, y)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.draw">
<code>draw(*args, **kwargs)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.end_pan">
<code>end_pan()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.format_coord">
<code>format_coord(theta, r)</code> </dt> <dd>
<p>Return a format string formatting the coordinate using Unicode characters.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_data_ratio">
<code>get_data_ratio()</code> </dt> <dd>
<p>Return the aspect ratio of the data itself. For a polar plot, this should always be 1.0</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_rlabel_position">
<code>get_rlabel_position()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">float</p>  <p>The theta position of the radius labels in degrees.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_rmax">
<code>get_rmax()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_rmin">
<code>get_rmin()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_rorigin">
<code>get_rorigin()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_theta_direction">
<code>get_theta_direction()</code> </dt> <dd>
<p>Get the direction in which theta increases.</p> <dl class="docutils"> <dt>-1:</dt> <dd>Theta increases in the clockwise direction</dd> <dt>1:</dt> <dd>Theta increases in the counterclockwise direction</dd> </dl> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_theta_offset">
<code>get_theta_offset()</code> </dt> <dd>
<p>Get the offset for the location of 0 in radians.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_thetamax">
<code>get_thetamax()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_thetamin">
<code>get_thetamin()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_xaxis_text1_transform">
<code>get_xaxis_text1_transform(pad)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_xaxis_text2_transform">
<code>get_xaxis_text2_transform(pad)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_xaxis_transform">
<code>get_xaxis_transform(which='grid')</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_yaxis_text1_transform">
<code>get_yaxis_text1_transform(pad)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_yaxis_text2_transform">
<code>get_yaxis_text2_transform(pad)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.get_yaxis_transform">
<code>get_yaxis_transform(which='grid')</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.projections.polar.PolarAxes.name">
<code>name = 'polar'</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_rgrids">
<code>set_rgrids(radii, labels=None, angle=None, fmt=None, **kwargs)</code> </dt> <dd>
<p>Set the radial locations and labels of the <em>r</em> grids.</p> <p>The labels will appear at radial distances <em>radii</em> at the given <em>angle</em> in degrees.</p> <p><em>labels</em>, if not None, is a <code>len(radii)</code> list of strings of the labels to use at each radius.</p> <p>If <em>labels</em> is None, the built-in formatter will be used.</p> <p>Return value is a list of tuples (<em>line</em>, <em>label</em>), where <em>line</em> is <a class="reference internal" href="../_as_gen/matplotlib.lines.line2d/#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a> instances and the <em>label</em> is <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>Text</code></a> instances.</p> <p>kwargs are optional text properties for the labels:</p>  <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Property</th> <th class="head">Description</th> </tr> </thead>  <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_agg_filter/#matplotlib.artist.Artist.set_agg_filter" title="matplotlib.artist.Artist.set_agg_filter"><code>agg_filter</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_alpha/#matplotlib.artist.Artist.set_alpha" title="matplotlib.artist.Artist.set_alpha"><code>alpha</code></a></td> <td>float (0.0 transparent through 1.0 opaque)</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_animated/#matplotlib.artist.Artist.set_animated" title="matplotlib.artist.Artist.set_animated"><code>animated</code></a></td> <td>[True | False]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_backgroundcolor" title="matplotlib.text.Text.set_backgroundcolor"><code>backgroundcolor</code></a></td> <td>any matplotlib color</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_bbox" title="matplotlib.text.Text.set_bbox"><code>bbox</code></a></td> <td>FancyBboxPatch prop dict</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_clip_box" title="matplotlib.text.Text.set_clip_box"><code>clip_box</code></a></td> <td>a <a class="reference internal" href="../transformations/#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>matplotlib.transforms.Bbox</code></a> instance</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_clip_on" title="matplotlib.text.Text.set_clip_on"><code>clip_on</code></a></td> <td>[True | False]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_clip_path" title="matplotlib.text.Text.set_clip_path"><code>clip_path</code></a></td> <td>[ (<a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="../_as_gen/matplotlib.patches.patch/#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None ]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_color" title="matplotlib.text.Text.set_color"><code>color</code></a></td> <td>any matplotlib color</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_contains/#matplotlib.artist.Artist.set_contains" title="matplotlib.artist.Artist.set_contains"><code>contains</code></a></td> <td>a callable function</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_family" title="matplotlib.text.Text.set_family"><code>family</code></a> or fontfamily or fontname or name</td> <td>[FONTNAME | ‘serif’ | ‘sans-serif’ | ‘cursive’ | ‘fantasy’ | ‘monospace’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_figure/#matplotlib.artist.Artist.set_figure" title="matplotlib.artist.Artist.set_figure"><code>figure</code></a></td> <td>a <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a> instance</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_fontproperties" title="matplotlib.text.Text.set_fontproperties"><code>fontproperties</code></a> or font_properties</td> <td>a <a class="reference internal" href="../font_manager_api/#matplotlib.font_manager.FontProperties" title="matplotlib.font_manager.FontProperties"><code>matplotlib.font_manager.FontProperties</code></a> instance</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_gid/#matplotlib.artist.Artist.set_gid" title="matplotlib.artist.Artist.set_gid"><code>gid</code></a></td> <td>an id string</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_horizontalalignment" title="matplotlib.text.Text.set_horizontalalignment"><code>horizontalalignment</code></a> or ha</td> <td>[ ‘center’ | ‘right’ | ‘left’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_label/#matplotlib.artist.Artist.set_label" title="matplotlib.artist.Artist.set_label"><code>label</code></a></td> <td>string or anything printable with ‘%s’ conversion.</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_linespacing" title="matplotlib.text.Text.set_linespacing"><code>linespacing</code></a></td> <td>float (multiple of font size)</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_multialignment" title="matplotlib.text.Text.set_multialignment"><code>multialignment</code></a></td> <td>[‘left’ | ‘right’ | ‘center’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_path_effects/#matplotlib.artist.Artist.set_path_effects" title="matplotlib.artist.Artist.set_path_effects"><code>path_effects</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_picker/#matplotlib.artist.Artist.set_picker" title="matplotlib.artist.Artist.set_picker"><code>picker</code></a></td> <td>[None|float|boolean|callable]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_position" title="matplotlib.text.Text.set_position"><code>position</code></a></td> <td>(x,y)</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_rasterized/#matplotlib.artist.Artist.set_rasterized" title="matplotlib.artist.Artist.set_rasterized"><code>rasterized</code></a></td> <td>[True | False | None]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_rotation" title="matplotlib.text.Text.set_rotation"><code>rotation</code></a></td> <td>[ angle in degrees | ‘vertical’ | ‘horizontal’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_rotation_mode" title="matplotlib.text.Text.set_rotation_mode"><code>rotation_mode</code></a></td> <td>unknown</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_size" title="matplotlib.text.Text.set_size"><code>size</code></a> or fontsize</td> <td>[size in points | ‘xx-small’ | ‘x-small’ | ‘small’ | ‘medium’ | ‘large’ | ‘x-large’ | ‘xx-large’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_sketch_params/#matplotlib.artist.Artist.set_sketch_params" title="matplotlib.artist.Artist.set_sketch_params"><code>sketch_params</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_snap/#matplotlib.artist.Artist.set_snap" title="matplotlib.artist.Artist.set_snap"><code>snap</code></a></td> <td>unknown</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_stretch" title="matplotlib.text.Text.set_stretch"><code>stretch</code></a> or fontstretch</td> <td>[a numeric value in range 0-1000 | ‘ultra-condensed’ | ‘extra-condensed’ | ‘condensed’ | ‘semi-condensed’ | ‘normal’ | ‘semi-expanded’ | ‘expanded’ | ‘extra-expanded’ | ‘ultra-expanded’ ]</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_style" title="matplotlib.text.Text.set_style"><code>style</code></a> or fontstyle</td> <td>[ ‘normal’ | ‘italic’ | ‘oblique’]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_text" title="matplotlib.text.Text.set_text"><code>text</code></a></td> <td>string or anything printable with ‘%s’ conversion.</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_transform/#matplotlib.artist.Artist.set_transform" title="matplotlib.artist.Artist.set_transform"><code>transform</code></a></td> <td>
<a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_url/#matplotlib.artist.Artist.set_url" title="matplotlib.artist.Artist.set_url"><code>url</code></a></td> <td>a url string</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_usetex" title="matplotlib.text.Text.set_usetex"><code>usetex</code></a></td> <td>unknown</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_variant" title="matplotlib.text.Text.set_variant"><code>variant</code></a> or fontvariant</td> <td>[ ‘normal’ | ‘small-caps’ ]</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_verticalalignment" title="matplotlib.text.Text.set_verticalalignment"><code>verticalalignment</code></a> or ma or va</td> <td>[ ‘center’ | ‘top’ | ‘bottom’ | ‘baseline’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_visible/#matplotlib.artist.Artist.set_visible" title="matplotlib.artist.Artist.set_visible"><code>visible</code></a></td> <td>[True | False]</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_weight" title="matplotlib.text.Text.set_weight"><code>weight</code></a> or fontweight</td> <td>[a numeric value in range 0-1000 | ‘ultralight’ | ‘light’ | ‘normal’ | ‘regular’ | ‘book’ | ‘medium’ | ‘roman’ | ‘semibold’ | ‘demibold’ | ‘demi’ | ‘bold’ | ‘heavy’ | ‘extra bold’ | ‘black’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_wrap" title="matplotlib.text.Text.set_wrap"><code>wrap</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_x" title="matplotlib.text.Text.set_x"><code>x</code></a></td> <td>float</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_y" title="matplotlib.text.Text.set_y"><code>y</code></a></td> <td>float</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_zorder/#matplotlib.artist.Artist.set_zorder" title="matplotlib.artist.Artist.set_zorder"><code>zorder</code></a></td> <td>any number</td> </tr>  </table>  <p>ACCEPTS: sequence of floats</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_rlabel_position">
<code>set_rlabel_position(value)</code> </dt> <dd>
<p>Updates the theta position of the radius labels.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>value</strong> : number</p>  <p>The angular position of the radius labels in degrees.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_rlim">
<code>set_rlim(*args, **kwargs)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_rmax">
<code>set_rmax(rmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_rmin">
<code>set_rmin(rmin)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_rorigin">
<code>set_rorigin(rorigin)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_rscale">
<code>set_rscale(*args, **kwargs)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_rticks">
<code>set_rticks(*args, **kwargs)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_theta_direction">
<code>set_theta_direction(direction)</code> </dt> <dd>
<p>Set the direction in which theta increases.</p> <dl class="docutils"> <dt>clockwise, -1:</dt> <dd>Theta increases in the clockwise direction</dd> <dt>counterclockwise, anticlockwise, 1:</dt> <dd>Theta increases in the counterclockwise direction</dd> </dl> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_theta_offset">
<code>set_theta_offset(offset)</code> </dt> <dd>
<p>Set the offset for the location of 0 in radians.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_theta_zero_location">
<code>set_theta_zero_location(loc, offset=0.0)</code> </dt> <dd>
<p>Sets the location of theta’s zero. (Calls set_theta_offset with the correct value in radians under the hood.)</p> <dl class="docutils"> <dt>
<code>loc : str</code> </dt> <dd>May be one of “N”, “NW”, “W”, “SW”, “S”, “SE”, “E”, or “NE”.</dd> <dt>
<code>offset : float, optional</code> </dt> <dd>An offset in degrees to apply from the specified <code>loc</code>. <strong>Note:</strong> this offset is <em>always</em> applied counter-clockwise regardless of the direction setting.</dd> </dl> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_thetagrids">
<code>set_thetagrids(angles, labels=None, frac=None, fmt=None, **kwargs)</code> </dt> <dd>
<p>Set the angles at which to place the theta grids (these gridlines are equal along the theta dimension). <em>angles</em> is in degrees.</p> <p><em>labels</em>, if not None, is a <code>len(angles)</code> list of strings of the labels to use at each angle.</p> <p>If <em>labels</em> is None, the labels will be <code>fmt % angle</code></p> <p><em>frac</em> is the fraction of the polar axes radius at which to place the label (1 is the edge). e.g., 1.05 is outside the axes and 0.95 is inside the axes.</p> <p>Return value is a list of tuples (<em>line</em>, <em>label</em>), where <em>line</em> is <a class="reference internal" href="../_as_gen/matplotlib.lines.line2d/#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a> instances and the <em>label</em> is <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>Text</code></a> instances.</p> <p>kwargs are optional text properties for the labels:</p>  <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Property</th> <th class="head">Description</th> </tr> </thead>  <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_agg_filter/#matplotlib.artist.Artist.set_agg_filter" title="matplotlib.artist.Artist.set_agg_filter"><code>agg_filter</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_alpha/#matplotlib.artist.Artist.set_alpha" title="matplotlib.artist.Artist.set_alpha"><code>alpha</code></a></td> <td>float (0.0 transparent through 1.0 opaque)</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_animated/#matplotlib.artist.Artist.set_animated" title="matplotlib.artist.Artist.set_animated"><code>animated</code></a></td> <td>[True | False]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_backgroundcolor" title="matplotlib.text.Text.set_backgroundcolor"><code>backgroundcolor</code></a></td> <td>any matplotlib color</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_bbox" title="matplotlib.text.Text.set_bbox"><code>bbox</code></a></td> <td>FancyBboxPatch prop dict</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_clip_box" title="matplotlib.text.Text.set_clip_box"><code>clip_box</code></a></td> <td>a <a class="reference internal" href="../transformations/#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>matplotlib.transforms.Bbox</code></a> instance</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_clip_on" title="matplotlib.text.Text.set_clip_on"><code>clip_on</code></a></td> <td>[True | False]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_clip_path" title="matplotlib.text.Text.set_clip_path"><code>clip_path</code></a></td> <td>[ (<a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>) | <a class="reference internal" href="../_as_gen/matplotlib.patches.patch/#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None ]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_color" title="matplotlib.text.Text.set_color"><code>color</code></a></td> <td>any matplotlib color</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_contains/#matplotlib.artist.Artist.set_contains" title="matplotlib.artist.Artist.set_contains"><code>contains</code></a></td> <td>a callable function</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_family" title="matplotlib.text.Text.set_family"><code>family</code></a> or fontfamily or fontname or name</td> <td>[FONTNAME | ‘serif’ | ‘sans-serif’ | ‘cursive’ | ‘fantasy’ | ‘monospace’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_figure/#matplotlib.artist.Artist.set_figure" title="matplotlib.artist.Artist.set_figure"><code>figure</code></a></td> <td>a <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a> instance</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_fontproperties" title="matplotlib.text.Text.set_fontproperties"><code>fontproperties</code></a> or font_properties</td> <td>a <a class="reference internal" href="../font_manager_api/#matplotlib.font_manager.FontProperties" title="matplotlib.font_manager.FontProperties"><code>matplotlib.font_manager.FontProperties</code></a> instance</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_gid/#matplotlib.artist.Artist.set_gid" title="matplotlib.artist.Artist.set_gid"><code>gid</code></a></td> <td>an id string</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_horizontalalignment" title="matplotlib.text.Text.set_horizontalalignment"><code>horizontalalignment</code></a> or ha</td> <td>[ ‘center’ | ‘right’ | ‘left’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_label/#matplotlib.artist.Artist.set_label" title="matplotlib.artist.Artist.set_label"><code>label</code></a></td> <td>string or anything printable with ‘%s’ conversion.</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_linespacing" title="matplotlib.text.Text.set_linespacing"><code>linespacing</code></a></td> <td>float (multiple of font size)</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_multialignment" title="matplotlib.text.Text.set_multialignment"><code>multialignment</code></a></td> <td>[‘left’ | ‘right’ | ‘center’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_path_effects/#matplotlib.artist.Artist.set_path_effects" title="matplotlib.artist.Artist.set_path_effects"><code>path_effects</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_picker/#matplotlib.artist.Artist.set_picker" title="matplotlib.artist.Artist.set_picker"><code>picker</code></a></td> <td>[None|float|boolean|callable]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_position" title="matplotlib.text.Text.set_position"><code>position</code></a></td> <td>(x,y)</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_rasterized/#matplotlib.artist.Artist.set_rasterized" title="matplotlib.artist.Artist.set_rasterized"><code>rasterized</code></a></td> <td>[True | False | None]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_rotation" title="matplotlib.text.Text.set_rotation"><code>rotation</code></a></td> <td>[ angle in degrees | ‘vertical’ | ‘horizontal’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_rotation_mode" title="matplotlib.text.Text.set_rotation_mode"><code>rotation_mode</code></a></td> <td>unknown</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_size" title="matplotlib.text.Text.set_size"><code>size</code></a> or fontsize</td> <td>[size in points | ‘xx-small’ | ‘x-small’ | ‘small’ | ‘medium’ | ‘large’ | ‘x-large’ | ‘xx-large’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_sketch_params/#matplotlib.artist.Artist.set_sketch_params" title="matplotlib.artist.Artist.set_sketch_params"><code>sketch_params</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_snap/#matplotlib.artist.Artist.set_snap" title="matplotlib.artist.Artist.set_snap"><code>snap</code></a></td> <td>unknown</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_stretch" title="matplotlib.text.Text.set_stretch"><code>stretch</code></a> or fontstretch</td> <td>[a numeric value in range 0-1000 | ‘ultra-condensed’ | ‘extra-condensed’ | ‘condensed’ | ‘semi-condensed’ | ‘normal’ | ‘semi-expanded’ | ‘expanded’ | ‘extra-expanded’ | ‘ultra-expanded’ ]</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_style" title="matplotlib.text.Text.set_style"><code>style</code></a> or fontstyle</td> <td>[ ‘normal’ | ‘italic’ | ‘oblique’]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_text" title="matplotlib.text.Text.set_text"><code>text</code></a></td> <td>string or anything printable with ‘%s’ conversion.</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_transform/#matplotlib.artist.Artist.set_transform" title="matplotlib.artist.Artist.set_transform"><code>transform</code></a></td> <td>
<a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_url/#matplotlib.artist.Artist.set_url" title="matplotlib.artist.Artist.set_url"><code>url</code></a></td> <td>a url string</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_usetex" title="matplotlib.text.Text.set_usetex"><code>usetex</code></a></td> <td>unknown</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_variant" title="matplotlib.text.Text.set_variant"><code>variant</code></a> or fontvariant</td> <td>[ ‘normal’ | ‘small-caps’ ]</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_verticalalignment" title="matplotlib.text.Text.set_verticalalignment"><code>verticalalignment</code></a> or ma or va</td> <td>[ ‘center’ | ‘top’ | ‘bottom’ | ‘baseline’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_visible/#matplotlib.artist.Artist.set_visible" title="matplotlib.artist.Artist.set_visible"><code>visible</code></a></td> <td>[True | False]</td> </tr> <tr>
<td>
<a class="reference internal" href="../text_api/#matplotlib.text.Text.set_weight" title="matplotlib.text.Text.set_weight"><code>weight</code></a> or fontweight</td> <td>[a numeric value in range 0-1000 | ‘ultralight’ | ‘light’ | ‘normal’ | ‘regular’ | ‘book’ | ‘medium’ | ‘roman’ | ‘semibold’ | ‘demibold’ | ‘demi’ | ‘bold’ | ‘heavy’ | ‘extra bold’ | ‘black’ ]</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_wrap" title="matplotlib.text.Text.set_wrap"><code>wrap</code></a></td> <td>unknown</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_x" title="matplotlib.text.Text.set_x"><code>x</code></a></td> <td>float</td> </tr> <tr>
<td><a class="reference internal" href="../text_api/#matplotlib.text.Text.set_y" title="matplotlib.text.Text.set_y"><code>y</code></a></td> <td>float</td> </tr> <tr>
<td><a class="reference internal" href="../_as_gen/matplotlib.artist.artist.set_zorder/#matplotlib.artist.Artist.set_zorder" title="matplotlib.artist.Artist.set_zorder"><code>zorder</code></a></td> <td>any number</td> </tr>  </table>  <p>ACCEPTS: sequence of floats</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_thetalim">
<code>set_thetalim(*args, **kwargs)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_thetamax">
<code>set_thetamax(thetamax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_thetamin">
<code>set_thetamin(thetamin)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_xscale">
<code>set_xscale(scale, *args, **kwargs)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.set_yscale">
<code>set_yscale(*args, **kwargs)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarAxes.start_pan">
<code>start_pan(x, y, button)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.PolarTransform">
<code>class matplotlib.projections.polar.PolarTransform(axis=None, use_rmin=True, _apply_theta_transforms=True)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../transformations/#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>The base polar transform. This handles projection <em>theta</em> and <em>r</em> into Cartesian coordinate space <em>x</em> and <em>y</em>, but does not perform the ultimate affine transformation into the correct position.</p> <dl class="attribute"> <dt id="matplotlib.projections.polar.PolarTransform.input_dims">
<code>input_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarTransform.inverted">
<code>inverted()</code> </dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.projections.polar.PolarTransform.is_separable">
<code>is_separable = False</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.projections.polar.PolarTransform.output_dims">
<code>output_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarTransform.transform_non_affine">
<code>transform_non_affine(tr)</code> </dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.projections.polar.PolarTransform.input_dims" title="matplotlib.projections.polar.PolarTransform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.projections.polar.PolarTransform.output_dims" title="matplotlib.projections.polar.PolarTransform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.projections.polar.PolarTransform.input_dims" title="matplotlib.projections.polar.PolarTransform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.projections.polar.PolarTransform.output_dims" title="matplotlib.projections.polar.PolarTransform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.PolarTransform.transform_path_non_affine">
<code>transform_path_non_affine(path)</code> </dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.RadialAxis">
<code>class matplotlib.projections.polar.RadialAxis(axes, pickradius=15)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../axis_api/#matplotlib.axis.YAxis" title="matplotlib.axis.YAxis"><code>matplotlib.axis.YAxis</code></a></p> <p>A radial Axis.</p> <p>This overrides certain properties of a <code>YAxis</code> to provide special-casing for a radial axis.</p> <p>Init the axis with the parent Axes instance</p> <dl class="attribute"> <dt id="matplotlib.projections.polar.RadialAxis.axis_name">
<code>axis_name = 'radius'</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.RadialAxis.cla">
<code>cla()</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.RadialLocator">
<code>class matplotlib.projections.polar.RadialLocator(base, axes=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../ticker_api/#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Used to locate radius ticks.</p> <p>Ensures that all ticks are strictly positive. For all other tasks, it delegates to the base <a class="reference internal" href="../ticker_api/#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>Locator</code></a> (which may be different depending on the scale of the <em>r</em>-axis.</p> <dl class="method"> <dt id="matplotlib.projections.polar.RadialLocator.autoscale">
<code>autoscale()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.RadialLocator.pan">
<code>pan(numsteps)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.RadialLocator.refresh">
<code>refresh()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.RadialLocator.view_limits">
<code>view_limits(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.RadialLocator.zoom">
<code>zoom(direction)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.RadialTick">
<code>class matplotlib.projections.polar.RadialTick(axes, loc, label, size=None, width=None, color=None, tickdir=None, pad=None, labelsize=None, labelcolor=None, zorder=None, gridOn=None, tick1On=True, tick2On=True, label1On=True, label2On=False, major=True, labelrotation=0)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../axis_api/#matplotlib.axis.YTick" title="matplotlib.axis.YTick"><code>matplotlib.axis.YTick</code></a></p> <p>A radial-axis tick.</p> <p>This subclass of <code>YTick</code> provides radial ticks with some small modification to their re-positioning such that ticks are rotated based on axes limits. This results in ticks that are correctly perpendicular to the spine. Labels are also rotated to be perpendicular to the spine, when ‘auto’ rotation is enabled.</p> <p>bbox is the Bound2D bounding box in display coords of the Axes loc is the tick location in data coords size is the tick size in points</p> <dl class="method"> <dt id="matplotlib.projections.polar.RadialTick.update_position">
<code>update_position(loc)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.ThetaAxis">
<code>class matplotlib.projections.polar.ThetaAxis(axes, pickradius=15)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../axis_api/#matplotlib.axis.XAxis" title="matplotlib.axis.XAxis"><code>matplotlib.axis.XAxis</code></a></p> <p>A theta Axis.</p> <p>This overrides certain properties of an <code>XAxis</code> to provide special-casing for an angular axis.</p> <p>Init the axis with the parent Axes instance</p> <dl class="attribute"> <dt id="matplotlib.projections.polar.ThetaAxis.axis_name">
<code>axis_name = 'theta'</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.ThetaAxis.cla">
<code>cla()</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.ThetaFormatter">
<code>class matplotlib.projections.polar.ThetaFormatter</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../ticker_api/#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Used to format the <em>theta</em> tick labels. Converts the native unit of radians into degrees and adds a degree symbol.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.ThetaLocator">
<code>class matplotlib.projections.polar.ThetaLocator(base)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../ticker_api/#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Used to locate theta ticks.</p> <p>This will work the same as the base locator except in the case that the view spans the entire circle. In such cases, the previously used default locations of every 45 degrees are returned.</p> <dl class="method"> <dt id="matplotlib.projections.polar.ThetaLocator.autoscale">
<code>autoscale()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.ThetaLocator.pan">
<code>pan(numsteps)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.ThetaLocator.refresh">
<code>refresh()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.ThetaLocator.set_axis">
<code>set_axis(axis)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.ThetaLocator.view_limits">
<code>view_limits(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.projections.polar.ThetaLocator.zoom">
<code>zoom(direction)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.projections.polar.ThetaTick">
<code>class matplotlib.projections.polar.ThetaTick(axes, *args, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="../axis_api/#matplotlib.axis.XTick" title="matplotlib.axis.XTick"><code>matplotlib.axis.XTick</code></a></p> <p>A theta-axis tick.</p> <p>This subclass of <code>XTick</code> provides angular ticks with some small modification to their re-positioning such that ticks are rotated based on tick location. This results in ticks that are correctly perpendicular to the arc spine.</p> <p>When ‘auto’ rotation is enabled, labels are also rotated to be parallel to the spine. The label padding is also applied here since it’s not possible to use a generic axes transform to produce tick-specific padding.</p> <dl class="method"> <dt id="matplotlib.projections.polar.ThetaTick.update_position">
<code>update_position(loc)</code> </dt> 
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/2.1.0/api/projections_api.html" class="_attribution-link" target="_blank">http://matplotlib.org/2.1.0/api/projections_api.html</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
