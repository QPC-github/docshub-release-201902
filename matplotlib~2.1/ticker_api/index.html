
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ticker - Matplotlib 2.1 - W3cubDocs</title>
  
  <meta name="description" content="This module contains classes to support completely configurable tick locating and formatting. Although the locators know nothing about major or &hellip;">
  <meta name="keywords" content="ticker, -, matplotlib, matplotlib~2.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~2.1/ticker_api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/matplotlib~2.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~2.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 2.1</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
				
<h1 id="ticker">ticker</h1>  <h2 id="matplotlib-ticker">matplotlib.ticker</h2>  <h3 id="module-matplotlib.ticker">Tick locating and formatting</h3> <p>This module contains classes to support completely configurable tick locating and formatting. Although the locators know nothing about major or minor ticks, they are used by the Axis class to support major and minor tick locating and formatting. Generic tick locators and formatters are provided, as well as domain specific custom ones.</p>  <h4 id="default-formatter">Default Formatter</h4> <p>The default formatter identifies when the x-data being plotted is a small range on top of a large off set. To reduce the chances that the ticklabels overlap the ticks are labeled as deltas from a fixed offset. For example:</p> <pre data-language="python">ax.plot(np.arange(2000, 2010), range(10))
</pre> <p>will have tick of 0-9 with an offset of +2e3. If this is not desired turn off the use of the offset on the default formatter:</p> <pre data-language="python">ax.get_xaxis().get_major_formatter().set_useOffset(False)
</pre> <p>set the rcParam <code>axes.formatter.useoffset=False</code> to turn it off globally, or set a different formatter.</p>   <h4 id="tick-locating">Tick locating</h4> <p>The Locator class is the base class for all tick locators. The locators handle autoscaling of the view limits based on the data limits, and the choosing of tick locations. A useful semi-automatic tick locator is <a class="reference internal" href="#matplotlib.ticker.MultipleLocator" title="matplotlib.ticker.MultipleLocator"><code>MultipleLocator</code></a>. It is initialized with a base, e.g., 10, and it picks axis limits and ticks that are multiples of that base.</p> <p>The Locator subclasses defined here are</p> <dl class="docutils"> <dt>
 <a class="reference internal" href="#matplotlib.ticker.NullLocator" title="matplotlib.ticker.NullLocator"><code>NullLocator</code></a>
</dt> <dd>No ticks</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.FixedLocator" title="matplotlib.ticker.FixedLocator"><code>FixedLocator</code></a>
</dt> <dd>Tick locations are fixed</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.IndexLocator" title="matplotlib.ticker.IndexLocator"><code>IndexLocator</code></a>
</dt> <dd>locator for index plots (e.g., where x = range(len(y)))</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.LinearLocator" title="matplotlib.ticker.LinearLocator"><code>LinearLocator</code></a>
</dt> <dd>evenly spaced ticks from min to max</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.LogLocator" title="matplotlib.ticker.LogLocator"><code>LogLocator</code></a>
</dt> <dd>logarithmically ticks from min to max</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.SymmetricalLogLocator" title="matplotlib.ticker.SymmetricalLogLocator"><code>SymmetricalLogLocator</code></a>
</dt> <dd>locator for use with with the symlog norm, works like the <a class="reference internal" href="#matplotlib.ticker.LogLocator" title="matplotlib.ticker.LogLocator"><code>LogLocator</code></a> for the part outside of the threshold and add 0 if inside the limits</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.MultipleLocator" title="matplotlib.ticker.MultipleLocator"><code>MultipleLocator</code></a>
</dt> <dd>ticks and range are a multiple of base; either integer or float</dd> <dt>
<code>OldAutoLocator</code> </dt> <dd>choose a MultipleLocator and dyamically reassign it for intelligent ticking during navigation</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.MaxNLocator" title="matplotlib.ticker.MaxNLocator"><code>MaxNLocator</code></a>
</dt> <dd>finds up to a max number of ticks at nice locations</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.AutoLocator" title="matplotlib.ticker.AutoLocator"><code>AutoLocator</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.ticker.MaxNLocator" title="matplotlib.ticker.MaxNLocator"><code>MaxNLocator</code></a> with simple defaults. This is the default tick locator for most plotting.</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.AutoMinorLocator" title="matplotlib.ticker.AutoMinorLocator"><code>AutoMinorLocator</code></a>
</dt> <dd>locator for minor ticks when the axis is linear and the major ticks are uniformly spaced. It subdivides the major tick interval into a specified number of minor intervals, defaulting to 4 or 5 depending on the major interval.</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.LogitLocator" title="matplotlib.ticker.LogitLocator"><code>LogitLocator</code></a>
</dt> <dd>Locator for logit scaling.</dd> </dl> <p>There are a number of locators specialized for date locations - see the dates module</p> <p>You can define your own locator by deriving from Locator. You must override the <code>__call__</code> method, which returns a sequence of locations, and you will probably want to override the autoscale method to set the view limits from the data limits.</p> <p>If you want to override the default locator, use one of the above or a custom locator and pass it to the x or y axis instance. The relevant methods are:</p> <pre data-language="python">ax.xaxis.set_major_locator( xmajorLocator )
ax.xaxis.set_minor_locator( xminorLocator )
ax.yaxis.set_major_locator( ymajorLocator )
ax.yaxis.set_minor_locator( yminorLocator )
</pre> <p>The default minor locator is the NullLocator, e.g., no minor ticks on by default.</p>   <h4 id="tick-formatting">Tick formatting</h4> <p>Tick formatting is controlled by classes derived from Formatter. The formatter operates on a single tick value and returns a string to the axis.</p> <dl class="docutils"> <dt>
 <a class="reference internal" href="#matplotlib.ticker.NullFormatter" title="matplotlib.ticker.NullFormatter"><code>NullFormatter</code></a>
</dt> <dd>No labels on the ticks</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.IndexFormatter" title="matplotlib.ticker.IndexFormatter"><code>IndexFormatter</code></a>
</dt> <dd>Set the strings from a list of labels</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.FixedFormatter" title="matplotlib.ticker.FixedFormatter"><code>FixedFormatter</code></a>
</dt> <dd>Set the strings manually for the labels</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.FuncFormatter" title="matplotlib.ticker.FuncFormatter"><code>FuncFormatter</code></a>
</dt> <dd>User defined function sets the labels</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.StrMethodFormatter" title="matplotlib.ticker.StrMethodFormatter"><code>StrMethodFormatter</code></a>
</dt> <dd>Use string <a class="reference external" href="https://docs.python.org/2/library/functions.html#format" title="(in Python v2.7)" target="_blank"><code>format</code></a> method</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.FormatStrFormatter" title="matplotlib.ticker.FormatStrFormatter"><code>FormatStrFormatter</code></a>
</dt> <dd>Use an old-style sprintf format string</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.ScalarFormatter" title="matplotlib.ticker.ScalarFormatter"><code>ScalarFormatter</code></a>
</dt> <dd>Default formatter for scalars: autopick the format string</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.LogFormatter" title="matplotlib.ticker.LogFormatter"><code>LogFormatter</code></a>
</dt> <dd>Formatter for log axes</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.LogFormatterExponent" title="matplotlib.ticker.LogFormatterExponent"><code>LogFormatterExponent</code></a>
</dt> <dd>Format values for log axis using <code>exponent = log_base(value)</code>.</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.LogFormatterMathtext" title="matplotlib.ticker.LogFormatterMathtext"><code>LogFormatterMathtext</code></a>
</dt> <dd>Format values for log axis using <code>exponent = log_base(value)</code> using Math text.</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.LogFormatterSciNotation" title="matplotlib.ticker.LogFormatterSciNotation"><code>LogFormatterSciNotation</code></a>
</dt> <dd>Format values for log axis using scientific notation.</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.LogitFormatter" title="matplotlib.ticker.LogitFormatter"><code>LogitFormatter</code></a>
</dt> <dd>Probability formatter.</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.EngFormatter" title="matplotlib.ticker.EngFormatter"><code>EngFormatter</code></a>
</dt> <dd>Format labels in engineering notation</dd> <dt>
 <a class="reference internal" href="#matplotlib.ticker.PercentFormatter" title="matplotlib.ticker.PercentFormatter"><code>PercentFormatter</code></a>
</dt> <dd>Format labels as a percentage</dd> </dl> <p>You can derive your own formatter from the Formatter base class by simply overriding the <code>__call__</code> method. The formatter class has access to the axis view and data limits.</p> <p>To control the major and minor tick label formats, use one of the following methods:</p> <pre data-language="python">ax.xaxis.set_major_formatter( xmajorFormatter )
ax.xaxis.set_minor_formatter( xminorFormatter )
ax.yaxis.set_major_formatter( ymajorFormatter )
ax.yaxis.set_minor_formatter( yminorFormatter )
</pre> <p>See <a class="reference internal" href="http://matplotlib.org/2.1.0/gallery/ticks_and_spines/major_minor_demo.html#sphx-glr-gallery-ticks-and-spines-major-minor-demo-py" target="_blank"><span class="std std-ref">Major Minor Demo</span></a> for an example of setting major and minor ticks. See the <a class="reference internal" href="../dates_api/#module-matplotlib.dates" title="matplotlib.dates"><code>matplotlib.dates</code></a> module for more information and examples of using date locators and formatters.</p> <dl class="class"> <dt id="matplotlib.ticker.TickHelper">
<code>class matplotlib.ticker.TickHelper</code> </dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <dl class="attribute"> <dt id="matplotlib.ticker.TickHelper.axis">
<code>axis = None</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.TickHelper.create_dummy_axis">
<code>create_dummy_axis(**kwargs)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.TickHelper.set_axis">
<code>set_axis(axis)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.TickHelper.set_bounds">
<code>set_bounds(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.TickHelper.set_data_interval">
<code>set_data_interval(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.TickHelper.set_view_interval">
<code>set_view_interval(vmin, vmax)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.Formatter">
<code>class matplotlib.ticker.Formatter</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.TickHelper" title="matplotlib.ticker.TickHelper"><code>matplotlib.ticker.TickHelper</code></a></p> <p>Create a string based on a tick value and location.</p> <dl class="method"> <dt id="matplotlib.ticker.Formatter.fix_minus">
<code>fix_minus(s)</code> </dt> <dd>
<p>Some classes may want to replace a hyphen for minus with the proper unicode symbol (U+2212) for typographical correctness. The default is to not replace it.</p> <p>Note, if you use this method, e.g., in <a class="reference internal" href="#matplotlib.ticker.Formatter.format_data" title="matplotlib.ticker.Formatter.format_data"><code>format_data()</code></a> or call, you probably don’t want to use it for <a class="reference internal" href="#matplotlib.ticker.Formatter.format_data_short" title="matplotlib.ticker.Formatter.format_data_short"><code>format_data_short()</code></a> since the toolbar uses this for interactive coord reporting and I doubt we can expect GUIs across platforms will handle the unicode correctly. So for now the classes that override <a class="reference internal" href="#matplotlib.ticker.Formatter.fix_minus" title="matplotlib.ticker.Formatter.fix_minus"><code>fix_minus()</code></a> should have an explicit <a class="reference internal" href="#matplotlib.ticker.Formatter.format_data_short" title="matplotlib.ticker.Formatter.format_data_short"><code>format_data_short()</code></a> method</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.Formatter.format_data">
<code>format_data(value)</code> </dt> <dd>
<p>Returns the full string representation of the value with the position unspecified.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.Formatter.format_data_short">
<code>format_data_short(value)</code> </dt> <dd>
<p>Return a short string version of the tick value.</p> <p>Defaults to the position-independent long value.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.Formatter.get_offset">
<code>get_offset()</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.ticker.Formatter.locs">
<code>locs = []</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.Formatter.set_locs">
<code>set_locs(locs)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.FixedFormatter">
<code>class matplotlib.ticker.FixedFormatter(seq)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Return fixed strings for tick labels based only on position, not value.</p> <p>Set the sequence of strings that will be used for labels.</p> <dl class="method"> <dt id="matplotlib.ticker.FixedFormatter.get_offset">
<code>get_offset()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.FixedFormatter.set_offset_string">
<code>set_offset_string(ofs)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.NullFormatter">
<code>class matplotlib.ticker.NullFormatter</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Always return the empty string.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.FuncFormatter">
<code>class matplotlib.ticker.FuncFormatter(func)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Use a user-defined function for formatting.</p> <p>The function should take in two inputs (a tick value <code>x</code> and a position <code>pos</code>), and return a string containing the corresponding tick label.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.FormatStrFormatter">
<code>class matplotlib.ticker.FormatStrFormatter(fmt)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Use an old-style (‘%’ operator) format string to format the tick.</p> <p>The format string should have a single variable format (%) in it. It will be applied to the value (not the position) of the tick.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.StrMethodFormatter">
<code>class matplotlib.ticker.StrMethodFormatter(fmt)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Use a new-style format string (as used by <code>str.format()</code>) to format the tick.</p> <p>The field used for the value must be labeled <code>x</code> and the field used for the position must be labeled <code>pos</code>.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.ScalarFormatter">
<code>class matplotlib.ticker.ScalarFormatter(useOffset=None, useMathText=None, useLocale=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Format tick values as a number.</p> <p>Tick value is interpreted as a plain old number. If <code>useOffset==True</code> and the data range is much smaller than the data average, then an offset will be determined such that the tick labels are meaningful. Scientific notation is used for <code>data &lt; 10^-n</code> or <code>data &gt;= 10^m</code>, where <code>n</code> and <code>m</code> are the power limits set using <code>set_powerlimits((n,m))</code>. The defaults for these are controlled by the <code>axes.formatter.limits</code> rc parameter.</p> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.fix_minus">
<code>fix_minus(s)</code> </dt> <dd>
<p>Replace hyphens with a unicode minus.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.format_data">
<code>format_data(value)</code> </dt> <dd>
<p>Return a formatted string representation of a number.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.format_data_short">
<code>format_data_short(value)</code> </dt> <dd>
<p>Return a short formatted string representation of a number.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.get_offset">
<code>get_offset()</code> </dt> <dd>
<p>Return scientific notation, plus offset.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.get_useLocale">
<code>get_useLocale()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.get_useMathText">
<code>get_useMathText()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.get_useOffset">
<code>get_useOffset()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.pprint_val">
<code>pprint_val(x)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.set_locs">
<code>set_locs(locs)</code> </dt> <dd>
<p>Set the locations of the ticks.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.set_powerlimits">
<code>set_powerlimits(lims)</code> </dt> <dd>
<p>Sets size thresholds for scientific notation.</p> <p><code>lims</code> is a two-element sequence containing the powers of 10 that determine the switchover threshold. Numbers below <code>10**lims[0]</code> and above <code>10**lims[1]</code> will be displayed in scientific notation.</p> <p>For example, <code>formatter.set_powerlimits((-3, 4))</code> sets the pre-2007 default in which scientific notation is used for numbers less than 1e-3 or greater than 1e4.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">Method <a class="reference internal" href="#matplotlib.ticker.ScalarFormatter.set_scientific" title="matplotlib.ticker.ScalarFormatter.set_scientific"><code>set_scientific()</code></a></p> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.set_scientific">
<code>set_scientific(b)</code> </dt> <dd>
<p>Turn scientific notation on or off.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">Method <a class="reference internal" href="#matplotlib.ticker.ScalarFormatter.set_powerlimits" title="matplotlib.ticker.ScalarFormatter.set_powerlimits"><code>set_powerlimits()</code></a></p> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.set_useLocale">
<code>set_useLocale(val)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.set_useMathText">
<code>set_useMathText(val)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.ScalarFormatter.set_useOffset">
<code>set_useOffset(val)</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.ticker.ScalarFormatter.useLocale">
<code>useLocale</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.ticker.ScalarFormatter.useMathText">
<code>useMathText</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.ticker.ScalarFormatter.useOffset">
<code>useOffset</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.LogFormatter">
<code>class matplotlib.ticker.LogFormatter(base=10.0, labelOnlyBase=False, minor_thresholds=None, linthresh=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Base class for formatting ticks on a log or symlog scale.</p> <p>It may be instantiated directly, or subclassed.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>base</strong> : float, optional, default: 10.</p>  <p>Base of the logarithm used in all calculations.</p>  <p><strong>labelOnlyBase</strong> : bool, optional, default: False</p>  <p>If True, label ticks only at integer powers of base. This is normally True for major ticks and False for minor ticks.</p>  <p><strong>minor_thresholds</strong> : (subset, all), optional, default: (1, 0.4)</p>  <p>If labelOnlyBase is False, these two numbers control the labeling of ticks that are not at integer powers of base; normally these are the minor ticks. The controlling parameter is the log of the axis data range. In the typical case where base is 10 it is the number of decades spanned by the axis, so we can call it ‘numdec’. If <code>numdec &lt;= all</code>, all minor ticks will be labeled. If <code>all &lt; numdec &lt;= subset</code>, then only a subset of minor ticks will be labeled, so as to avoid crowding. If <code>numdec &gt; subset</code> then no minor ticks will be labeled.</p>  <p><strong>linthresh</strong> : None or float, optional, default: None</p>  <p>If a symmetric log scale is in use, its <code>linthresh</code> parameter must be supplied here.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The <a class="reference internal" href="#matplotlib.ticker.LogFormatter.set_locs" title="matplotlib.ticker.LogFormatter.set_locs"><code>set_locs</code></a> method must be called to enable the subsetting logic controlled by the <code>minor_thresholds</code> parameter.</p> <p>In some cases such as the colorbar, there is no distinction between major and minor ticks; the tick locations might be set manually, or by a locator that puts ticks at integer powers of base and at intermediate locations. For this situation, disable the minor_thresholds logic by using <code>minor_thresholds=(np.inf, np.inf)</code>, so that all ticks will be labeled.</p> <p>To disable labeling of minor ticks when ‘labelOnlyBase’ is False, use <code>minor_thresholds=(0, 0)</code>. This is the default for the “classic” style.</p> <h4 class="rubric">Examples</h4> <p>To label a subset of minor ticks when the view limits span up to 2 decades, and all of the ticks when zoomed in to 0.5 decades or less, use <code>minor_thresholds=(2, 0.5)</code>.</p> <p>To label all minor ticks when the view limits span up to 1.5 decades, use <code>minor_thresholds=(1.5, 1.5)</code>.</p> <dl class="method"> <dt id="matplotlib.ticker.LogFormatter.base">
<code>base(base)</code> </dt> <dd>
<p>change the <a class="reference internal" href="#matplotlib.ticker.LogFormatter.base" title="matplotlib.ticker.LogFormatter.base"><code>base</code></a> for labeling.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Should always match the base used for <a class="reference internal" href="#matplotlib.ticker.LogLocator" title="matplotlib.ticker.LogLocator"><code>LogLocator</code></a></p> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogFormatter.format_data">
<code>format_data(value)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogFormatter.format_data_short">
<code>format_data_short(value)</code> </dt> <dd>
<p>Return a short formatted string representation of a number.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogFormatter.label_minor">
<code>label_minor(labelOnlyBase)</code> </dt> <dd>
<p>Switch minor tick labeling on or off.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>labelOnlyBase</strong> : bool</p>  <p>If True, label ticks only at integer powers of base.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogFormatter.pprint_val">
<code>pprint_val(x, d)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogFormatter.set_locs">
<code>set_locs(locs=None)</code> </dt> <dd>
<p>Use axis view limits to control which ticks are labeled.</p> <p>The <code>locs</code> parameter is ignored in the present algorithm.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.LogFormatterExponent">
<code>class matplotlib.ticker.LogFormatterExponent(base=10.0, labelOnlyBase=False, minor_thresholds=None, linthresh=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.LogFormatter" title="matplotlib.ticker.LogFormatter"><code>matplotlib.ticker.LogFormatter</code></a></p> <p>Format values for log axis using <code>exponent = log_base(value)</code>.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.LogFormatterMathtext">
<code>class matplotlib.ticker.LogFormatterMathtext(base=10.0, labelOnlyBase=False, minor_thresholds=None, linthresh=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.LogFormatter" title="matplotlib.ticker.LogFormatter"><code>matplotlib.ticker.LogFormatter</code></a></p> <p>Format values for log axis using <code>exponent = log_base(value)</code>.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.IndexFormatter">
<code>class matplotlib.ticker.IndexFormatter(labels)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Format the position x to the nearest i-th label where i=int(x+0.5)</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.LogFormatterSciNotation">
<code>class matplotlib.ticker.LogFormatterSciNotation(base=10.0, labelOnlyBase=False, minor_thresholds=None, linthresh=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.LogFormatterMathtext" title="matplotlib.ticker.LogFormatterMathtext"><code>matplotlib.ticker.LogFormatterMathtext</code></a></p> <p>Format values following scientific notation in a logarithmic axis</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.LogitFormatter">
<code>class matplotlib.ticker.LogitFormatter</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Probability formatter (using Math text).</p> <dl class="method"> <dt id="matplotlib.ticker.LogitFormatter.format_data_short">
<code>format_data_short(value)</code> </dt> <dd>
<p>return a short formatted string representation of a number</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.EngFormatter">
<code>class matplotlib.ticker.EngFormatter(unit='', places=None, sep=' ')</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Formats axis values using engineering prefixes to represent powers of 1000, plus a specified unit, e.g., 10 MHz instead of 1e7.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>unit</strong> : str (default: “”)</p>  <p>Unit symbol to use, suitable for use with single-letter representations of powers of 1000. For example, ‘Hz’ or ‘m’.</p>  <p><strong>places</strong> : int (default: None)</p>  <p>Precision with which to display the number, specified in digits after the decimal point (there will be between one and three digits before the decimal point). If it is None, the formatting falls back to the floating point format ‘%g’, which displays up to 6 <em>significant</em> digits, i.e. the equivalent value for <em>places</em> varies between 0 and 5 (inclusive).</p>  <p><strong>sep</strong> : str (default: ” “)</p>  <p>Separator used between the value and the prefix/unit. For example, one get ‘3.14 mV’ if <code>sep</code> is ” ” (default) and ‘3.14mV’ if <code>sep</code> is “”. Besides the default behavior, some other useful options may be:</p> <ul class="simple"> <li>
<code>sep=""</code> to append directly the prefix/unit to the value;</li> <li>
<code>sep="\N{THIN SPACE}"</code> (<code>U+2009</code>);</li> <li>
<code>sep="\N{NARROW NO-BREAK SPACE}"</code> (<code>U+202F</code>);</li> <li>
<code>sep="\N{NO-BREAK SPACE}"</code> (<code>U+00A0</code>).</li> </ul>  </td> </tr>  </table> <dl class="attribute"> <dt id="matplotlib.ticker.EngFormatter.ENG_PREFIXES">
<code>ENG_PREFIXES = {-24: 'y', -21: 'z', -18: 'a', -15: 'f', -12: 'p', -9: 'n', -6: 'μ', -3: 'm', 0: '', 3: 'k', 6: 'M', 9: 'G', 12: 'T', 15: 'P', 18: 'E', 21: 'Z', 24: 'Y'}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.EngFormatter.format_eng">
<code>format_eng(num)</code> </dt> <dd>
<p>Formats a number in engineering notation, appending a letter representing the power of 1000 of the original number. Some examples:</p> <pre data-language="python">&gt;&gt;&gt; format_eng(0)       # for self.places = 0
'0'
</pre> <pre data-language="python">&gt;&gt;&gt; format_eng(1000000) # for self.places = 1
'1.0 M'
</pre> <pre data-language="python">&gt;&gt;&gt; format_eng("-1e-6") # for self.places = 2
u'-1.00 μ'
</pre> <p><code>num</code> may be a numeric value or a string that can be converted to a numeric value with <code>float(num)</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.PercentFormatter">
<code>class matplotlib.ticker.PercentFormatter(xmax=100, decimals=None, symbol='%', is_latex=False)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Format numbers as a percentage.</p> <p>How the number is converted into a percentage is determined by the <code>xmax</code> parameter. <code>xmax</code> is the data value that corresponds to 100%. Percentages are computed as <code>x / xmax * 100</code>. So if the data is already scaled to be percentages, <code>xmax</code> will be 100. Another common situation is where <code>xmax</code> is 1.0.</p> <p><a class="reference internal" href="#matplotlib.ticker.PercentFormatter.symbol" title="matplotlib.ticker.PercentFormatter.symbol"><code>symbol</code></a> is a string which will be appended to the label. It may be <a class="reference external" href="https://docs.python.org/2/library/constants.html#None" title="(in Python v2.7)" target="_blank"><code>None</code></a> or empty to indicate that no symbol should be used. LaTeX special characters are escaped in <a class="reference internal" href="#matplotlib.ticker.PercentFormatter.symbol" title="matplotlib.ticker.PercentFormatter.symbol"><code>symbol</code></a> whenever latex mode is enabled, unless <code>is_latex</code> is <a class="reference external" href="https://docs.python.org/2/library/constants.html#True" title="(in Python v2.7)" target="_blank"><code>True</code></a>.</p> <p><code>decimals</code> is the number of decimal places to place after the point. If it is set to <a class="reference external" href="https://docs.python.org/2/library/constants.html#None" title="(in Python v2.7)" target="_blank"><code>None</code></a> (the default), the number will be computed automatically.</p> <dl class="method"> <dt id="matplotlib.ticker.PercentFormatter.convert_to_pct">
<code>convert_to_pct(x)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.PercentFormatter.format_pct">
<code>format_pct(x, display_range)</code> </dt> <dd>
<p>Formats the number as a percentage number with the correct number of decimals and adds the percent symbol, if any.</p> <p>If <code>self.decimals</code> is <a class="reference external" href="https://docs.python.org/2/library/constants.html#None" title="(in Python v2.7)" target="_blank"><code>None</code></a>, the number of digits after the decimal point is set based on the <code>display_range</code> of the axis as follows:</p> <table class="docutils">   <tr>
<td>display_range</td> <td>decimals</td> <td>sample</td> </tr> <tr>
<td>&gt;50</td> <td>0</td> <td>
<code>x = 34.5</code> =&gt; 35%</td> </tr> <tr>
<td>&gt;5</td> <td>1</td> <td>
<code>x = 34.5</code> =&gt; 34.5%</td> </tr> <tr>
<td>&gt;0.5</td> <td>2</td> <td>
<code>x = 34.5</code> =&gt; 34.50%</td> </tr> <tr>
<td>…</td> <td>…</td> <td>…</td> </tr>  </table> <p>This method will not be very good for tiny axis ranges or extremely large ones. It assumes that the values on the chart are percentages displayed on a reasonable scale.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.ticker.PercentFormatter.symbol">
<code>symbol</code> </dt> <dd>
<p>The configured percent symbol as a string.</p> <p>If LaTeX is enabled via <code>rcParams['text.usetex']</code>, the special characters <code>{'#', '$', '%', '&amp;', '~', '_', '^', '', '{', '}'}</code> are automatically escaped in the string.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.Locator">
<code>class matplotlib.ticker.Locator</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.TickHelper" title="matplotlib.ticker.TickHelper"><code>matplotlib.ticker.TickHelper</code></a></p> <p>Determine the tick locations;</p> <p>Note, you should not use the same locator between different <a class="reference internal" href="../axis_api/#matplotlib.axis.Axis" title="matplotlib.axis.Axis"><code>Axis</code></a> because the locator stores references to the Axis data and view limits</p> <dl class="attribute"> <dt id="matplotlib.ticker.Locator.MAXTICKS">
<code>MAXTICKS = 1000</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.Locator.autoscale">
<code>autoscale()</code> </dt> <dd>
<p>autoscale the view limits</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.Locator.pan">
<code>pan(numsteps)</code> </dt> <dd>
<p>Pan numticks (can be positive or negative)</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.Locator.raise_if_exceeds">
<code>raise_if_exceeds(locs)</code> </dt> <dd>
<p>raise a RuntimeError if Locator attempts to create more than MAXTICKS locs</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.Locator.refresh">
<code>refresh()</code> </dt> <dd>
<p>refresh internal information based on current lim</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.Locator.set_params">
<code>set_params(**kwargs)</code> </dt> <dd>
<p>Do nothing, and rase a warning. Any locator class not supporting the set_params() function will call this.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.Locator.tick_values">
<code>tick_values(vmin, vmax)</code> </dt> <dd>
<p>Return the values of the located ticks given <strong>vmin</strong> and <strong>vmax</strong>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>To get tick locations with the vmin and vmax values defined automatically for the associated <code>axis</code> simply call the Locator instance:</p> <pre data-language="python">&gt;&gt;&gt; print((type(loc)))
&lt;type 'Locator'&gt;
&gt;&gt;&gt; print((loc()))
[1, 2, 3, 4]
</pre> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.Locator.view_limits">
<code>view_limits(vmin, vmax)</code> </dt> <dd>
<p>select a scale for the range from vmin to vmax</p> <p>Normally this method is overridden by subclasses to change locator behaviour.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.Locator.zoom">
<code>zoom(direction)</code> </dt> <dd>
<p>Zoom in/out on axis; if direction is &gt;0 zoom in, else zoom out</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.IndexLocator">
<code>class matplotlib.ticker.IndexLocator(base, offset)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Place a tick on every multiple of some base number of points plotted, e.g., on every 5th point. It is assumed that you are doing index plotting; i.e., the axis is 0, len(data). This is mainly useful for x ticks.</p> <p>place ticks on the i-th data points where (i-offset)%base==0</p> <dl class="method"> <dt id="matplotlib.ticker.IndexLocator.set_params">
<code>set_params(base=None, offset=None)</code> </dt> <dd>
<p>Set parameters within this locator</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.IndexLocator.tick_values">
<code>tick_values(vmin, vmax)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.FixedLocator">
<code>class matplotlib.ticker.FixedLocator(locs, nbins=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Tick locations are fixed. If nbins is not None, the array of possible positions will be subsampled to keep the number of ticks &lt;= nbins +1. The subsampling will be done so as to include the smallest absolute value; for example, if zero is included in the array of possibilities, then it is guaranteed to be one of the chosen ticks.</p> <dl class="method"> <dt id="matplotlib.ticker.FixedLocator.set_params">
<code>set_params(nbins=None)</code> </dt> <dd>
<p>Set parameters within this locator.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.FixedLocator.tick_values">
<code>tick_values(vmin, vmax)</code> </dt> <dd>
<p>” Return the locations of the ticks.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Because the values are fixed, vmin and vmax are not used in this method.</p> </div> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.NullLocator">
<code>class matplotlib.ticker.NullLocator</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>No ticks</p> <dl class="method"> <dt id="matplotlib.ticker.NullLocator.tick_values">
<code>tick_values(vmin, vmax)</code> </dt> <dd>
<p>” Return the locations of the ticks.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Because the values are Null, vmin and vmax are not used in this method.</p> </div> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.LinearLocator">
<code>class matplotlib.ticker.LinearLocator(numticks=None, presets=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Determine the tick locations</p> <p>The first time this function is called it will try to set the number of ticks to make a nice tick partitioning. Thereafter the number of ticks will be fixed so that interactive navigation will be nice</p> <p>Use presets to set locs based on lom. A dict mapping vmin, vmax-&gt;locs</p> <dl class="method"> <dt id="matplotlib.ticker.LinearLocator.set_params">
<code>set_params(numticks=None, presets=None)</code> </dt> <dd>
<p>Set parameters within this locator.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.LinearLocator.tick_values">
<code>tick_values(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.LinearLocator.view_limits">
<code>view_limits(vmin, vmax)</code> </dt> <dd>
<p>Try to choose the view limits intelligently</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.LogLocator">
<code>class matplotlib.ticker.LogLocator(base=10.0, subs=(1.0, ), numdecs=4, numticks=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Determine the tick locations for log axes</p> <p>Place ticks on the locations : subs[j] * base**i</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>subs</strong> : None, string, or sequence of float, optional, default (1.0,)</p>  <p>Gives the multiples of integer powers of the base at which to place ticks. The default places ticks only at integer powers of the base. The permitted string values are <code>'auto'</code> and <code>'all'</code>, both of which use an algorithm based on the axis view limits to determine whether and how to put ticks between integer powers of the base. With <code>'auto'</code>, ticks are placed only between integer powers; with <code>'all'</code>, the integer powers are included. A value of None is equivalent to <code>'auto'</code>.</p>  </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.ticker.LogLocator.base">
<code>base(base)</code> </dt> <dd>
<p>set the base of the log scaling (major tick every base**i, i integer)</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogLocator.nonsingular">
<code>nonsingular(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogLocator.set_params">
<code>set_params(base=None, subs=None, numdecs=None, numticks=None)</code> </dt> <dd>
<p>Set parameters within this locator.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogLocator.subs">
<code>subs(subs)</code> </dt> <dd>
<p>set the minor ticks for the log scaling every base**i*subs[j]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogLocator.tick_values">
<code>tick_values(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogLocator.view_limits">
<code>view_limits(vmin, vmax)</code> </dt> <dd>
<p>Try to choose the view limits intelligently</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.AutoLocator">
<code>class matplotlib.ticker.AutoLocator</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.MaxNLocator" title="matplotlib.ticker.MaxNLocator"><code>matplotlib.ticker.MaxNLocator</code></a></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.MultipleLocator">
<code>class matplotlib.ticker.MultipleLocator(base=1.0)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Set a tick on every integer that is multiple of base in the view interval</p> <dl class="method"> <dt id="matplotlib.ticker.MultipleLocator.set_params">
<code>set_params(base)</code> </dt> <dd>
<p>Set parameters within this locator.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.MultipleLocator.tick_values">
<code>tick_values(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.MultipleLocator.view_limits">
<code>view_limits(dmin, dmax)</code> </dt> <dd>
<p>Set the view limits to the nearest multiples of base that contain the data</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.MaxNLocator">
<code>class matplotlib.ticker.MaxNLocator(*args, **kwargs)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Select no more than N intervals at nice locations.</p> <p>Keyword args:</p> <dl class="docutils"> <dt><em>nbins</em></dt> <dd>Maximum number of intervals; one less than max number of ticks. If the string <code>'auto'</code>, the number of bins will be automatically determined based on the length of the axis.</dd> <dt><em>steps</em></dt> <dd>Sequence of nice numbers starting with 1 and ending with 10; e.g., [1, 2, 4, 5, 10]</dd> <dt><em>integer</em></dt> <dd>If True, ticks will take only integer values, provided at least <code>min_n_ticks</code> integers are found within the view limits.</dd> <dt><em>symmetric</em></dt> <dd>If True, autoscaling will result in a range symmetric about zero.</dd> <dt><em>prune</em></dt> <dd>[‘lower’ | ‘upper’ | ‘both’ | None] Remove edge ticks – useful for stacked or ganged plots where the upper tick of one axes overlaps with the lower tick of the axes above it, primarily when <code>rcParams['axes.autolimit_mode']</code> is <code>'round_numbers'</code>. If <code>prune=='lower'</code>, the smallest tick will be removed. If <code>prune=='upper'</code>, the largest tick will be removed. If <code>prune=='both'</code>, the largest and smallest ticks will be removed. If <code>prune==None</code>, no ticks will be removed.</dd> <dt><em>min_n_ticks</em></dt> <dd>Relax <code>nbins</code> and <code>integer</code> constraints if necessary to obtain this minimum number of ticks.</dd> </dl> <dl class="method"> <dt id="matplotlib.ticker.MaxNLocator.bin_boundaries">
<code>bin_boundaries(vmin, vmax)</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified">Deprecated since version 2.0: </span>The bin_boundaries function was deprecated in version 2.0.</p> </div>  </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.ticker.MaxNLocator.default_params">
<code>default_params = {'nbins': 10, 'steps': None, 'integer': False, 'symmetric': False, 'prune': None, 'min_n_ticks': 2}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.MaxNLocator.set_params">
<code>set_params(**kwargs)</code> </dt> <dd>
<p>Set parameters within this locator.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.MaxNLocator.tick_values">
<code>tick_values(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.MaxNLocator.view_limits">
<code>view_limits(dmin, dmax)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.AutoMinorLocator">
<code>class matplotlib.ticker.AutoMinorLocator(n=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Dynamically find minor tick positions based on the positions of major ticks. The scale must be linear with major ticks evenly spaced.</p> <p><em>n</em> is the number of subdivisions of the interval between major ticks; e.g., n=2 will place a single minor tick midway between major ticks.</p> <p>If <em>n</em> is omitted or None, it will be set to 5 or 4.</p> <dl class="method"> <dt id="matplotlib.ticker.AutoMinorLocator.tick_values">
<code>tick_values(vmin, vmax)</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.SymmetricalLogLocator">
<code>class matplotlib.ticker.SymmetricalLogLocator(transform=None, subs=None, linthresh=None, base=None)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Determine the tick locations for symmetric log axes</p> <p>place ticks on the location= base**i*subs[j]</p> <dl class="method"> <dt id="matplotlib.ticker.SymmetricalLogLocator.set_params">
<code>set_params(subs=None, numticks=None)</code> </dt> <dd>
<p>Set parameters within this locator.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.SymmetricalLogLocator.tick_values">
<code>tick_values(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.SymmetricalLogLocator.view_limits">
<code>view_limits(vmin, vmax)</code> </dt> <dd>
<p>Try to choose the view limits intelligently</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.ticker.LogitLocator">
<code>class matplotlib.ticker.LogitLocator(minor=False)</code> </dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Determine the tick locations for logit axes</p> <p>place ticks on the logit locations</p> <dl class="method"> <dt id="matplotlib.ticker.LogitLocator.nonsingular">
<code>nonsingular(vmin, vmax)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogitLocator.set_params">
<code>set_params(minor=None)</code> </dt> <dd>
<p>Set parameters within this locator.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.ticker.LogitLocator.tick_values">
<code>tick_values(vmin, vmax)</code> </dt> 
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/2.1.0/api/ticker_api.html" class="_attribution-link" target="_blank">http://matplotlib.org/2.1.0/api/ticker_api.html</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
