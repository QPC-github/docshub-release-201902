
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>CSV - Ruby 2.5 - W3cubDocs</title>
  
  <meta name="description" content="This class provides a complete interface to CSV files and data. It offers tools to enable you to read and write to and from Strings or IO objects, &hellip;">
  <meta name="keywords" content="class, csv, -, ruby, ruby~2.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/ruby~2.5/csv/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/ruby~2.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.5/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.5</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rdoc">
				
				
<h1 id="class-CSV" class="class"> class CSV </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../object/">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="../enumerable/">Enumerable</a></dd>
</dl> <section class="description"> <p>This class provides a complete interface to <a href="../csv/">CSV</a> files and data. It offers tools to enable you to read and write to and from Strings or <a href="../io/">IO</a> objects, as needed.</p> <h2 id="class-CSV-label-Reading">Reading</h2> <h3 id="class-CSV-label-From+a+File">From a <a href="../file/">File</a>
</h3> <h4 id="class-CSV-label-A+Line+at+a+Time">A Line at a <a href="../time/">Time</a>
</h4> <pre class="ruby" data-language="ruby">CSV.foreach("path/to/file.csv") do |row|
  # use row here...
end
</pre> <h4 id="class-CSV-label-All+at+Once">All at Once</h4> <pre class="ruby" data-language="ruby">arr_of_arrs = CSV.read("path/to/file.csv")
</pre> <h3 id="class-CSV-label-From+a+String">From a String</h3> <h4 id="class-CSV-label-A+Line+at+a+Time">A Line at a <a href="../time/">Time</a>
</h4> <pre class="ruby" data-language="ruby">CSV.parse("CSV,data,String") do |row|
  # use row here...
end
</pre> <h4 id="class-CSV-label-All+at+Once">All at Once</h4> <pre class="ruby" data-language="ruby">arr_of_arrs = CSV.parse("CSV,data,String")
</pre> <h2 id="class-CSV-label-Writing">Writing</h2> <h3 id="class-CSV-label-To+a+File">To a <a href="../file/">File</a>
</h3> <pre class="ruby" data-language="ruby">CSV.open("path/to/file.csv", "wb") do |csv|
  csv &lt;&lt; ["row", "of", "CSV", "data"]
  csv &lt;&lt; ["another", "row"]
  # ...
end
</pre> <h3 id="class-CSV-label-To+a+String">To a String</h3> <pre class="ruby" data-language="ruby">csv_string = CSV.generate do |csv|
  csv &lt;&lt; ["row", "of", "CSV", "data"]
  csv &lt;&lt; ["another", "row"]
  # ...
end
</pre> <h2 id="class-CSV-label-Convert+a+Single+Line">Convert a Single Line</h2> <pre class="ruby" data-language="ruby">csv_string = ["CSV", "data"].to_csv   # to CSV
csv_array  = "CSV,String".parse_csv   # from CSV
</pre> <h2 id="class-CSV-label-Shortcut+Interface">Shortcut Interface</h2> <pre class="ruby" data-language="ruby">CSV             { |csv_out| csv_out &lt;&lt; %w{my data here} }  # to $stdout
CSV(csv = "")   { |csv_str| csv_str &lt;&lt; %w{my data here} }  # to a String
CSV($stderr)    { |csv_err| csv_err &lt;&lt; %w{my data here} }  # to $stderr
CSV($stdin)     { |csv_in|  csv_in.each { |row| p row } }  # from $stdin
</pre> <h2 id="class-CSV-label-Advanced+Usage">Advanced Usage</h2> <h3 id="class-CSV-label-Wrap+an+IO+Object">Wrap an <a href="../io/">IO</a> <a href="../object/">Object</a>
</h3> <pre class="ruby" data-language="ruby">csv = CSV.new(io, options)
# ... read (with gets() or each()) from and write (with &lt;&lt;) to csv here ...
</pre> <h2 id="class-CSV-label-CSV+and+Character+Encodings+-28M17n+or+Multilingualization-29">
<a href="../csv/">CSV</a> and Character Encodings (M17n or Multilingualization)</h2> <p>This new <a href="../csv/">CSV</a> parser is m17n savvy. The parser works in the <a href="../encoding/">Encoding</a> of the <a href="../io/">IO</a> or String object being read from or written to. Your data is never transcoded (unless you ask Ruby to transcode it for you) and will literally be parsed in the <a href="../encoding/">Encoding</a> it is in. Thus <a href="../csv/">CSV</a> will return Arrays or Rows of Strings in the <a href="../encoding/">Encoding</a> of your data. This is accomplished by transcoding the parser itself into your <a href="../encoding/">Encoding</a>.</p> <p>Some transcoding must take place, of course, to accomplish this multiencoding support. For example, <code>:col_sep</code>, <code>:row_sep</code>, and <code>:quote_char</code> must be transcoded to match your data. Hopefully this makes the entire process feel transparent, since CSV's defaults should just magically work for your data. However, you can set these values manually in the target <a href="../encoding/">Encoding</a> to avoid the translation.</p> <p>It's also important to note that while all of CSV's core parser is now <a href="../encoding/">Encoding</a> agnostic, some features are not. For example, the built-in converters will try to transcode data to UTF-8 before making conversions. Again, you can provide custom converters that are aware of your Encodings to avoid this translation. It's just too hard for me to support native conversions in all of Ruby's Encodings.</p> <p>Anyway, the practical side of this is simple: make sure <a href="../io/">IO</a> and String objects passed into <a href="../csv/">CSV</a> have the proper <a href="../encoding/">Encoding</a> set and everything should just work. <a href="../csv/">CSV</a> methods that allow you to open <a href="../io/">IO</a> objects (CSV::foreach(), <a href="../csv/#method-c-open">::open</a>, <a href="../csv/#method-c-read">::read</a>, and <a href="../csv/#method-c-readlines">::readlines</a>) do allow you to specify the <a href="../encoding/">Encoding</a>.</p> <p>One minor exception comes when generating <a href="../csv/">CSV</a> into a String with an <a href="../encoding/">Encoding</a> that is not ASCII compatible. There's no existing data for <a href="../csv/">CSV</a> to use to prepare itself and thus you will probably need to manually specify the desired <a href="../encoding/">Encoding</a> for most of those cases. It will try to guess using the fields in a row of output though, when using <a href="../csv/#method-c-generate_line">::generate_line</a> or Array#to_csv().</p> <p>I try to point out any other <a href="../encoding/">Encoding</a> issues in the documentation of methods as they come up.</p> <p>This has been tested to the best of my ability with all non-“dummy” Encodings Ruby ships with. However, it is brave new code and may have some bugs. Please feel free to <a href="../mailto:james@grayproductions.net/">report</a> any issues you find with it.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="ConverterEncoding">ConverterEncoding </dt>
<dd>
<p>The encoding used by all converters.</p> </dd>
<dt id="Converters">Converters </dt>
<dd>
<p>This <a href="../hash/">Hash</a> holds the built-in converters of <a href="../csv/">CSV</a> that can be accessed by name. You can select <a href="../csv/#Converters">Converters</a> with <a href="../csv/#method-i-convert">#convert</a> or through the <code>options</code> <a href="../hash/">Hash</a> passed to <a href="../csv/#method-c-new">::new</a>.</p> <dl class="rdoc-list note-list">
<dt>
<strong><code>:integer</code></strong> </dt>
<dd> <p>Converts any field Integer() accepts.</p> </dd>
<dt>
<strong><code>:float</code></strong> </dt>
<dd> <p>Converts any field Float() accepts.</p> </dd>
<dt>
<strong><code>:numeric</code></strong> </dt>
<dd> <p>A combination of <code>:integer</code> and <code>:float</code>.</p> </dd>
<dt>
<strong><code>:date</code></strong> </dt>
<dd> <p>Converts any field <a href="../date/#method-c-parse">Date.parse</a> accepts.</p> </dd>
<dt>
<strong><code>:date_time</code></strong> </dt>
<dd> <p>Converts any field <a href="../datetime/#method-c-parse">DateTime.parse</a> accepts.</p> </dd>
<dt>
<strong><code>:all</code></strong> </dt>
<dd> <p>All built-in converters. A combination of <code>:date_time</code> and <code>:numeric</code>.</p> </dd>
</dl> <p>All built-in converters transcode field data to UTF-8 before attempting a conversion. If your data cannot be transcoded to UTF-8 the conversion will fail and the field will remain unchanged.</p> <p>This <a href="../hash/">Hash</a> is intentionally left unfrozen and users should feel free to add values to it that can be accessed by all <a href="../csv/">CSV</a> objects.</p> <p>To add a combo field, the value should be an Array of names. Combo fields can be nested with other combo fields.</p> </dd>
<dt id="DEFAULT_OPTIONS">DEFAULT_OPTIONS </dt>
<dd>
<p>The options used when no overrides are given by calling code. They are:</p> <dl class="rdoc-list note-list">
<dt>
<strong><code>:col_sep</code></strong> </dt>
<dd> <p><code>","</code></p> </dd>
<dt>
<strong><code>:row_sep</code></strong> </dt>
<dd> <p><code>:auto</code></p> </dd>
<dt>
<strong><code>:quote_char</code></strong> </dt>
<dd> <p><code>'"'</code></p> </dd>
<dt>
<strong><code>:field_size_limit</code></strong> </dt>
<dd> <p><code>nil</code></p> </dd>
<dt>
<strong><code>:converters</code></strong> </dt>
<dd> <p><code>nil</code></p> </dd>
<dt>
<strong><code>:unconverted_fields</code></strong> </dt>
<dd> <p><code>nil</code></p> </dd>
<dt>
<strong><code>:headers</code></strong> </dt>
<dd> <p><code>false</code></p> </dd>
<dt>
<strong><code>:return_headers</code></strong> </dt>
<dd> <p><code>false</code></p> </dd>
<dt>
<strong><code>:header_converters</code></strong> </dt>
<dd> <p><code>nil</code></p> </dd>
<dt>
<strong><code>:skip_blanks</code></strong> </dt>
<dd> <p><code>false</code></p> </dd>
<dt>
<strong><code>:force_quotes</code></strong> </dt>
<dd> <p><code>false</code></p> </dd>
<dt>
<strong><code>:skip_lines</code></strong> </dt>
<dd> <p><code>nil</code></p> </dd>
<dt>
<strong><code>:liberal_parsing</code></strong> </dt>
<dd> <p><code>false</code></p> </dd>
</dl> </dd>
<dt id="DateMatcher">DateMatcher </dt>
<dd>
<p>A <a href="../regexp/">Regexp</a> used to find and convert some common <a href="../date/">Date</a> formats.</p> </dd>
<dt id="DateTimeMatcher">DateTimeMatcher </dt>
<dd>
<p>A <a href="../regexp/">Regexp</a> used to find and convert some common <a href="../datetime/">DateTime</a> formats.</p> </dd>
<dt id="FieldInfo">FieldInfo </dt>
<dd>
<p>A <a href="../csv/#FieldInfo">FieldInfo</a> <a href="../struct/">Struct</a> contains details about a field's position in the data source it was read from. <a href="../csv/">CSV</a> will pass this <a href="../struct/">Struct</a> to some blocks that make decisions based on field structure. See <a href="../csv/#method-i-convert_fields">#convert_fields</a> for an example.</p> <dl class="rdoc-list note-list">
<dt>
<strong><code>index</code></strong> </dt>
<dd> <p>The zero-based index of the field in its row.</p> </dd>
<dt>
<strong><code>line</code></strong> </dt>
<dd> <p>The line of the data source this row is from.</p> </dd>
<dt>
<strong><code>header</code></strong> </dt>
<dd> <p>The header for the column, when available.</p> </dd>
</dl> </dd>
<dt id="HeaderConverters">HeaderConverters </dt>
<dd>
<p>This <a href="../hash/">Hash</a> holds the built-in header converters of <a href="../csv/">CSV</a> that can be accessed by name. You can select <a href="../csv/#HeaderConverters">HeaderConverters</a> with <a href="../csv/#method-i-header_convert">#header_convert</a> or through the <code>options</code> <a href="../hash/">Hash</a> passed to <a href="../csv/#method-c-new">::new</a>.</p> <dl class="rdoc-list note-list">
<dt>
<strong><code>:downcase</code></strong> </dt>
<dd> <p>Calls downcase() on the header String.</p> </dd>
<dt>
<strong><code>:symbol</code></strong> </dt>
<dd> <p>Leading/trailing spaces are dropped, string is downcased, remaining spaces are replaced with underscores, non-word characters are dropped, and finally to_sym() is called.</p> </dd>
</dl> <p>All built-in header converters transcode header data to UTF-8 before attempting a conversion. If your data cannot be transcoded to UTF-8 the conversion will fail and the header will remain unchanged.</p> <p>This <a href="../hash/">Hash</a> is intentionally left unfrozen and users should feel free to add values to it that can be accessed by all <a href="../csv/">CSV</a> objects.</p> <p>To add a combo field, the value should be an Array of names. Combo fields can be nested with other combo fields.</p> </dd>
<dt id="VERSION">VERSION </dt>
<dd>
<p>The version of the installed library.</p> </dd>
</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-col_sep"> <span class="method-name">col_sep</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The encoded <code>:col_sep</code> used in parsing and writing. See <a href="../csv/#method-c-new">::new</a> for details.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-encoding"> <span class="method-name">encoding</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The <a href="../encoding/">Encoding</a> <a href="../csv/">CSV</a> is parsing or writing in. This will be the <a href="../encoding/">Encoding</a> you receive parsed data in and/or the <a href="../encoding/">Encoding</a> data will be written in.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-field_size_limit"> <span class="method-name">field_size_limit</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The limit for field size, if any. See <a href="../csv/#method-c-new">::new</a> for details.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-line"> <span class="method-name">line</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The line number of the last row read from this file. Fields with nested line-end characters will not affect this count.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-lineno"> <span class="method-name">lineno</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The line number of the last row read from this file. Fields with nested line-end characters will not affect this count.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-quote_char"> <span class="method-name">quote_char</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The encoded <code>:quote_char</code> used in parsing and writing. See <a href="../csv/#method-c-new">::new</a> for details.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-row_sep"> <span class="method-name">row_sep</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The encoded <code>:row_sep</code> used in parsing and writing. See <a href="../csv/#method-c-new">::new</a> for details.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-skip_lines"> <span class="method-name">skip_lines</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The regex marking a line as a comment. See <a href="../csv/#method-c-new">::new</a> for details</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-filter"> <span class="method-callseq"> filter( **options ) { |row| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> filter( input, **options ) { |row| ... } </span> </div> <div class="method-heading"> <span class="method-callseq"> filter( input, output, **options ) { |row| ... } </span> </div> <div class="method-description">
<div class="method-source-code" id="filter-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1098
def self.filter(input=nil, output=nil, **options)
  # parse options for input, output, or both
  in_options, out_options = Hash.new, {row_sep: $INPUT_RECORD_SEPARATOR}
  options.each do |key, value|
    case key.to_s
    when /\Ain(?:put)?_(.+)\Z/
      in_options[$1.to_sym] = value
    when /\Aout(?:put)?_(.+)\Z/
      out_options[$1.to_sym] = value
    else
      in_options[key]  = value
      out_options[key] = value
    end
  end
  # build input and output wrappers
  input  = new(input  || ARGF,    in_options)
  output = new(output || $stdout, out_options)

  # read, yield, write
  input.each do |row|
    yield row
    output &lt;&lt; row
  end
end</pre> </div> <p>This method is a convenience for building Unix-like filters for <a href="../csv/">CSV</a> data. Each row is yielded to the provided block which can alter it as needed. After the block returns, the row is appended to <code>output</code> altered or not.</p> <p>The <code>input</code> and <code>output</code> arguments can be anything <a href="../csv/#method-c-new">::new</a> accepts (generally String or <a href="../io/">IO</a> objects). If not given, they default to <code>ARGF</code> and <code>$stdout</code>.</p> <p>The <code>options</code> parameter is also filtered down to <a href="../csv/#method-c-new">::new</a> after some clever key parsing. Any key beginning with <code>:in_</code> or <code>:input_</code> will have that leading identifier stripped and will only be used in the <code>options</code> <a href="../hash/">Hash</a> for the <code>input</code> object. Keys starting with <code>:out_</code> or <code>:output_</code> affect only <code>output</code>. All other keys are assigned to both objects.</p> <p>The <code>:output_row_sep</code> <code>option</code> defaults to <code>$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-foreach"> <span class="method-name">foreach</span><span class="method-args">(path, **options, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="foreach-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1137
def self.foreach(path, **options, &amp;block)
  return to_enum(__method__, path, options) unless block
  open(path, options) do |csv|
    csv.each(&amp;block)
  end
end</pre> </div> <p>This method is intended as the primary interface for reading <a href="../csv/">CSV</a> files. You pass a <code>path</code> and any <code>options</code> you wish to set for the read. Each row of file will be passed to the provided <code>block</code> in turn.</p> <p>The <code>options</code> parameter can be anything <a href="../csv/#method-c-new">::new</a> understands. This method also understands an additional <code>:encoding</code> parameter that you can use to specify the <a href="../encoding/">Encoding</a> of the data in the file to be read. You must provide this unless your data is in <a href="../encoding/#method-c-default_external">Encoding.default_external</a>. <a href="../csv/">CSV</a> will use this to determine how to parse the data. You may provide a second <a href="../encoding/">Encoding</a> to have the data transcoded as it is read. For example, <code>encoding:
"UTF-32BE:UTF-8"</code> would read UTF-32BE data from the file but transcode it to UTF-8 before <a href="../csv/">CSV</a> parses it.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-generate"> <span class="method-callseq"> generate( str, **options ) { |csv| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> generate( **options ) { |csv| ... } </span> </div> <div class="method-description">
<div class="method-source-code" id="generate-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1162
def self.generate(str=nil, **options)
  # add a default empty String, if none was given
  if str
    io = StringIO.new(str)
    io.seek(0, IO::SEEK_END)
  else
    encoding = options[:encoding]
    str      = String.new
    str.force_encoding(encoding) if encoding
  end
  csv = new(str, options) # wrap
  yield csv         # yield for appending
  csv.string        # return final String
end</pre> </div> <p>This method wraps a String you provide, or an empty default String, in a <a href="../csv/">CSV</a> object which is passed to the provided block. You can use the block to append <a href="../csv/">CSV</a> rows to the String and when the block exits, the final String will be returned.</p> <p>Note that a passed String <strong>is</strong> modified by this method. Call dup() before passing if you need a new String.</p> <p>The <code>options</code> parameter can be anything <a href="../csv/#method-c-new">::new</a> understands. This method understands an additional <code>:encoding</code> parameter when not passed a String to set the base <a href="../encoding/">Encoding</a> for the output. <a href="../csv/">CSV</a> needs this hint if you plan to output non-ASCII compatible data.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-generate_line"> <span class="method-name">generate_line</span><span class="method-args">(row, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="generate_line-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1190
def self.generate_line(row, **options)
  options = {row_sep: $INPUT_RECORD_SEPARATOR}.merge(options)
  str = String.new
  if options[:encoding]
    str.force_encoding(options[:encoding])
  elsif field = row.find { |f| not f.nil? }
    str.force_encoding(String(field).encoding)
  end
  (new(str, options) &lt;&lt; row).string
end</pre> </div> <p>This method is a shortcut for converting a single row (Array) into a <a href="../csv/">CSV</a> String.</p> <p>The <code>options</code> parameter can be anything <a href="../csv/#method-c-new">::new</a> understands. This method understands an additional <code>:encoding</code> parameter to set the base <a href="../encoding/">Encoding</a> for the output. This method will try to guess your <a href="../encoding/">Encoding</a> from the first non-<code>nil</code> field in <code>row</code>, if possible, but you may need to use this parameter as a backup plan.</p> <p>The <code>:row_sep</code> <code>option</code> defaults to <code>$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>) when calling this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-instance"> <span class="method-name">instance</span><span class="method-args">(data = $stdout, **options) { |instance| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="instance-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1058
def self.instance(data = $stdout, **options)
  # create a _signature_ for this method call, data object and options
  sig = [data.object_id] +
        options.values_at(*DEFAULT_OPTIONS.keys.sort_by { |sym| sym.to_s })

  # fetch or create the instance for this signature
  @@instances ||= Hash.new
  instance = (@@instances[sig] ||= new(data, options))

  if block_given?
    yield instance  # run block, if given, returning result
  else
    instance        # or return the instance
  end
end</pre> </div> <p>This method will return a <a href="../csv/">CSV</a> instance, just like <a href="../csv/#method-c-new">::new</a>, but the instance will be cached and returned for all future calls to this method for the same <code>data</code> object (tested by <a href="../object/#method-i-object_id">Object#object_id</a>) with the same <code>options</code>.</p> <p>If a block is given, the instance is passed to the block and the return value becomes the return value of the block.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(data, col_sep: ",", row_sep: :auto, quote_char: '"', field_size_limit: nil, converters: nil, unconverted_fields: nil, headers: false, return_headers: false, write_headers: nil, header_converters: nil, skip_blanks: false, force_quotes: false, skip_lines: nil, liberal_parsing: false, internal_encoding: nil, external_encoding: nil, encoding: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1517
def initialize(data, col_sep: ",", row_sep: :auto, quote_char: '"', field_size_limit:   nil,
               converters: nil, unconverted_fields: nil, headers: false, return_headers: false,
               write_headers: nil, header_converters: nil, skip_blanks: false, force_quotes: false,
               skip_lines: nil, liberal_parsing: false, internal_encoding: nil, external_encoding: nil, encoding: nil)
  raise ArgumentError.new("Cannot parse nil as CSV") if data.nil?

  # create the IO object we will read from
  @io = data.is_a?(String) ? StringIO.new(data) : data
  # honor the IO encoding if we can, otherwise default to ASCII-8BIT
  internal_encoding = Encoding.find(internal_encoding) if internal_encoding
  external_encoding = Encoding.find(external_encoding) if external_encoding
  if encoding
    encoding, = encoding.split(":", 2) if encoding.is_a?(String)
    encoding = Encoding.find(encoding)
  end
  @encoding = raw_encoding(nil) || internal_encoding || encoding ||
              Encoding.default_internal || Encoding.default_external
  #
  # prepare for building safe regular expressions in the target encoding,
  # if we can transcode the needed characters
  #
  @re_esc   = "\\".encode(@encoding).freeze rescue ""
  @re_chars = /#{%"[-\\]\\[\\.^$?*+{}()|# \r\n\t\f\v]".encode(@encoding)}/
  @unconverted_fields = unconverted_fields

  # Stores header row settings and loads header converters, if needed.
  @use_headers    = headers
  @return_headers = return_headers
  @write_headers  = write_headers

  # headers must be delayed until shift(), in case they need a row of content
  @headers = nil

  init_separators(col_sep, row_sep, quote_char, force_quotes)
  init_parsers(skip_blanks, field_size_limit, liberal_parsing)
  init_converters(converters, :@converters, :convert)
  init_converters(header_converters, :@header_converters, :header_convert)
  init_comments(skip_lines)

  @force_encoding = !!encoding

  # track our own lineno since IO gets confused about line-ends is CSV fields
  @lineno = 0

  # make sure headers have been assigned
  if header_row? and [Array, String].include? @use_headers.class and @write_headers
    parse_headers  # won't read data for Array or String
    self &lt;&lt; @headers
  end
end</pre> </div> <p>This constructor will wrap either a String or <a href="../io/">IO</a> object passed in <code>data</code> for reading and/or writing. In addition to the <a href="../csv/">CSV</a> instance methods, several <a href="../io/">IO</a> methods are delegated. (See <a href="../csv/#method-c-open">::open</a> for a complete list.) If you pass a String for <code>data</code>, you can later retrieve it (after writing to it, for example) with CSV.string().</p> <p>Note that a wrapped String will be positioned at the beginning (for reading). If you want it at the end (for writing), use <a href="../csv/#method-c-generate">::generate</a>. If you want any other positioning, pass a preset <a href="../stringio/">StringIO</a> object instead.</p> <p>You may set any reading and/or writing preferences in the <code>options</code> <a href="../hash/">Hash</a>. Available options are:</p> <dl class="rdoc-list note-list">
<dt>
<strong><code>:col_sep</code></strong> </dt>
<dd> <p>The String placed between each field. This String will be transcoded into the data's <a href="../encoding/">Encoding</a> before parsing.</p> </dd>
<dt>
<strong><code>:row_sep</code></strong> </dt>
<dd> <p>The String appended to the end of each row. This can be set to the special <code>:auto</code> setting, which requests that <a href="../csv/">CSV</a> automatically discover this from the data. Auto-discovery reads ahead in the data looking for the next <code>"\r\n"</code>, <code>"\n"</code>, or <code>"\r"</code> sequence. A sequence will be selected even if it occurs in a quoted field, assuming that you would have the same line endings there. If none of those sequences is found, <code>data</code> is <code>ARGF</code>, <code>STDIN</code>, <code>STDOUT</code>, or <code>STDERR</code>, or the stream is only available for output, the default <code>$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>) is used. Obviously, discovery takes a little time. <a href="../set/">Set</a> manually if speed is important. Also note that <a href="../io/">IO</a> objects should be opened in binary mode on Windows if this feature will be used as the line-ending translation can cause problems with resetting the document position to where it was before the read ahead. This String will be transcoded into the data's <a href="../encoding/">Encoding</a> before parsing.</p> </dd>
<dt>
<strong><code>:quote_char</code></strong> </dt>
<dd> <p>The character used to quote fields. This has to be a single character String. This is useful for application that incorrectly use <code>'</code> as the quote character instead of the correct <code>"</code>. <a href="../csv/">CSV</a> will always consider a double sequence of this character to be an escaped quote. This String will be transcoded into the data's <a href="../encoding/">Encoding</a> before parsing.</p> </dd>
<dt>
<strong><code>:field_size_limit</code></strong> </dt>
<dd> <p>This is a maximum size <a href="../csv/">CSV</a> will read ahead looking for the closing quote for a field. (In truth, it reads to the first line ending beyond this size.) If a quote cannot be found within the limit <a href="../csv/">CSV</a> will raise a <a href="../csv/malformedcsverror/">MalformedCSVError</a>, assuming the data is faulty. You can use this limit to prevent what are effectively DoS attacks on the parser. However, this limit can cause a legitimate parse to fail and thus is set to <code>nil</code>, or off, by default.</p> </dd>
<dt>
<strong><code>:converters</code></strong> </dt>
<dd> <p>An Array of names from the <a href="../csv/#Converters">Converters</a> <a href="../hash/">Hash</a> and/or lambdas that handle custom conversion. A single converter doesn't have to be in an Array. All built-in converters try to transcode fields to UTF-8 before converting. The conversion will fail if the data cannot be transcoded, leaving the field unchanged.</p> </dd>
<dt>
<strong><code>:unconverted_fields</code></strong> </dt>
<dd> <p>If set to <code>true</code>, an unconverted_fields() method will be added to all returned rows (Array or <a href="../csv/row/">CSV::Row</a>) that will return the fields as they were before conversion. Note that <code>:headers</code> supplied by Array or String were not fields of the document and thus will have an empty Array attached.</p> </dd>
<dt>
<strong><code>:headers</code></strong> </dt>
<dd> <p>If set to <code>:first_row</code> or <code>true</code>, the initial row of the <a href="../csv/">CSV</a> file will be treated as a row of headers. If set to an Array, the contents will be used as the headers. If set to a String, the String is run through a call of <a href="../csv/#method-c-parse_line">::parse_line</a> with the same <code>:col_sep</code>, <code>:row_sep</code>, and <code>:quote_char</code> as this instance to produce an Array of headers. This setting causes <a href="../csv/#method-i-shift">#shift</a> to return rows as <a href="../csv/row/">CSV::Row</a> objects instead of Arrays and <a href="../csv/#method-i-read">#read</a> to return <a href="../csv/table/">CSV::Table</a> objects instead of an Array of Arrays.</p> </dd>
<dt>
<strong><code>:return_headers</code></strong> </dt>
<dd> <p>When <code>false</code>, header rows are silently swallowed. If set to <code>true</code>, header rows are returned in a <a href="../csv/row/">CSV::Row</a> object with identical headers and fields (save that the fields do not go through the converters).</p> </dd>
<dt>
<strong><code>:write_headers</code></strong> </dt>
<dd> <p>When <code>true</code> and <code>:headers</code> is set, a header row will be added to the output.</p> </dd>
<dt>
<strong><code>:header_converters</code></strong> </dt>
<dd> <p>Identical in functionality to <code>:converters</code> save that the conversions are only made to header rows. All built-in converters try to transcode headers to UTF-8 before converting. The conversion will fail if the data cannot be transcoded, leaving the header unchanged.</p> </dd>
<dt>
<strong><code>:skip_blanks</code></strong> </dt>
<dd> <p>When set to a <code>true</code> value, <a href="../csv/">CSV</a> will skip over any empty rows. Note that this setting will not skip rows that contain column separators, even if the rows contain no actual data. If you want to skip rows that contain separators but no content, consider using <code>:skip_lines</code>, or inspecting fields.compact.empty? on each row.</p> </dd>
<dt>
<strong><code>:force_quotes</code></strong> </dt>
<dd> <p>When set to a <code>true</code> value, <a href="../csv/">CSV</a> will quote all <a href="../csv/">CSV</a> fields it creates.</p> </dd>
<dt>
<strong><code>:skip_lines</code></strong> </dt>
<dd> <p>When set to an object responding to <code>match</code>, every line matching it is considered a comment and ignored during parsing. When set to a String, it is first converted to a <a href="../regexp/">Regexp</a>. When set to <code>nil</code> no line is considered a comment. If the passed object does not respond to <code>match</code>, <code>ArgumentError</code> is thrown.</p> </dd>
<dt>
<strong><code>:liberal_parsing</code></strong> </dt>
<dd> <p>When set to a <code>true</code> value, <a href="../csv/">CSV</a> will attempt to parse input not conformant with RFC 4180, such as double quotes in unquoted fields.</p> </dd>
</dl> <p>See <a href="../csv/#DEFAULT_OPTIONS">CSV::DEFAULT_OPTIONS</a> for the default settings.</p> <p>Options cannot be overridden in the instance methods for performance reasons, so be sure to set what you want here.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-open"> <span class="method-callseq"> open( filename, mode = "rb", **options ) { |faster_csv| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> open( filename, **options ) { |faster_csv| ... } </span> </div> <div class="method-heading"> <span class="method-callseq"> open( filename, mode = "rb", **options ) </span> </div> <div class="method-heading"> <span class="method-callseq"> open( filename, **options ) </span> </div> <div class="method-description">
<div class="method-source-code" id="open-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1264
def self.open(filename, mode="r", **options)
  # wrap a File opened with the remaining +args+ with no newline
  # decorator
  file_opts = {universal_newline: false}.merge(options)

  begin
    f = File.open(filename, mode, file_opts)
  rescue ArgumentError =&gt; e
    raise unless /needs binmode/ =~ e.message and mode == "r"
    mode = "rb"
    file_opts = {encoding: Encoding.default_external}.merge(file_opts)
    retry
  end
  begin
    csv = new(f, options)
  rescue Exception
    f.close
    raise
  end

  # handle blocks like Ruby's open(), not like the CSV library
  if block_given?
    begin
      yield csv
    ensure
      csv.close
    end
  else
    csv
  end
end</pre> </div> <p>This method opens an <a href="../io/">IO</a> object, and wraps that with <a href="../csv/">CSV</a>. This is intended as the primary interface for writing a <a href="../csv/">CSV</a> file.</p> <p>You must pass a <code>filename</code> and may optionally add a <code>mode</code> for Ruby's open(). You may also pass an optional <a href="../hash/">Hash</a> containing any <code>options</code> <a href="../csv/#method-c-new">::new</a> understands as the final argument.</p> <p>This method works like Ruby's open() call, in that it will pass a <a href="../csv/">CSV</a> object to a provided block and close it when the block terminates, or it will return the <a href="../csv/">CSV</a> object when no block is provided. (<strong>Note</strong>: This is different from the Ruby 1.8 <a href="../csv/">CSV</a> library which passed rows to the block. Use <a href="../csv/#method-c-foreach">::foreach</a> for that behavior.)</p> <p>You must provide a <code>mode</code> with an embedded <a href="../encoding/">Encoding</a> designator unless your data is in <a href="../encoding/#method-c-default_external">Encoding.default_external</a>. <a href="../csv/">CSV</a> will check the <a href="../encoding/">Encoding</a> of the underlying <a href="../io/">IO</a> object (set by the <code>mode</code> you pass) to determine how to parse the data. You may provide a second <a href="../encoding/">Encoding</a> to have the data transcoded as it is read just as you can with a normal call to <a href="../io/#method-c-open">IO.open</a>. For example, <code>"rb:UTF-32BE:UTF-8"</code> would read UTF-32BE data from the file but transcode it to UTF-8 before <a href="../csv/">CSV</a> parses it.</p> <p>An opened <a href="../csv/">CSV</a> object will delegate to many <a href="../io/">IO</a> methods for convenience. You may call:</p> <ul>
<li> <p>binmode()</p> </li>
<li> <p>binmode?()</p> </li>
<li> <p>close()</p> </li>
<li> <p>close_read()</p> </li>
<li> <p>close_write()</p> </li>
<li> <p>closed?()</p> </li>
<li> <p>eof()</p> </li>
<li> <p>eof?()</p> </li>
<li> <p>external_encoding()</p> </li>
<li> <p>fcntl()</p> </li>
<li> <p>fileno()</p> </li>
<li> <p>flock()</p> </li>
<li> <p>flush()</p> </li>
<li> <p>fsync()</p> </li>
<li> <p>internal_encoding()</p> </li>
<li> <p>ioctl()</p> </li>
<li> <p>isatty()</p> </li>
<li> <p>path()</p> </li>
<li> <p>pid()</p> </li>
<li> <p>pos()</p> </li>
<li> <p>pos=()</p> </li>
<li> <p>reopen()</p> </li>
<li> <p>seek()</p> </li>
<li> <p>stat()</p> </li>
<li> <p>sync()</p> </li>
<li> <p>sync=()</p> </li>
<li> <p>tell()</p> </li>
<li> <p>to_i()</p> </li>
<li> <p>to_io()</p> </li>
<li> <p>truncate()</p> </li>
<li> <p>tty?()</p> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-parse"> <span class="method-callseq"> parse( str, **options ) { |row| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> parse( str, **options ) </span> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1308
def self.parse(*args, &amp;block)
  csv = new(*args)
  if block.nil?  # slurp contents, if no block is given
    begin
      csv.read
    ensure
      csv.close
    end
  else           # or pass each row to a provided block
    csv.each(&amp;block)
  end
end</pre> </div> <p>This method can be used to easily parse <a href="../csv/">CSV</a> out of a String. You may either provide a <code>block</code> which will be called with each row of the String in turn, or just use the returned Array of Arrays (when no <code>block</code> is given).</p> <p>You pass your <code>str</code> to read from, and an optional <code>options</code> containing anything <a href="../csv/#method-c-new">::new</a> understands.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-parse_line"> <span class="method-name">parse_line</span><span class="method-args">(line, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parse_line-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1328
def self.parse_line(line, **options)
  new(line, options).shift
end</pre> </div> <p>This method is a shortcut for converting a single line of a <a href="../csv/">CSV</a> String into an Array. Note that if <code>line</code> contains multiple rows, anything beyond the first row is ignored.</p> <p>The <code>options</code> parameter can be anything <a href="../csv/#method-c-new">::new</a> understands.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-read"> <span class="method-name">read</span><span class="method-args">(path, *options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="read-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1343
def self.read(path, *options)
  open(path, *options) { |csv| csv.read }
end</pre> </div> <p>Use to slurp a <a href="../csv/">CSV</a> file into an Array of Arrays. Pass the <code>path</code> to the file and any <code>options</code> <a href="../csv/#method-c-new">::new</a> understands. This method also understands an additional <code>:encoding</code> parameter that you can use to specify the <a href="../encoding/">Encoding</a> of the data in the file to be read. You must provide this unless your data is in <a href="../encoding/#method-c-default_external">Encoding.default_external</a>. <a href="../csv/">CSV</a> will use this to determine how to parse the data. You may provide a second <a href="../encoding/">Encoding</a> to have the data transcoded as it is read. For example, <code>encoding:
"UTF-32BE:UTF-8"</code> would read UTF-32BE data from the file but transcode it to UTF-8 before <a href="../csv/">CSV</a> parses it.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-readlines"> <span class="method-name">readlines</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="readlines-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1348
def self.readlines(*args)
  read(*args)
end</pre> </div> <p>Alias for <a href="../csv/#method-c-read">::read</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-table"> <span class="method-name">table</span><span class="method-args">(path, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="table-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1359
def self.table(path, **options)
  read( path, { headers:           true,
                converters:        :numeric,
                header_converters: :symbol }.merge(options) )
end</pre> </div> <p>A shortcut for:</p> <pre class="ruby" data-language="ruby">CSV.read( path, { headers:           true,
                  converters:        :numeric,
                  header_converters: :symbol }.merge(options) )
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3C"> <span class="method-name">&lt;&lt;</span><span class="method-args">(row)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1680
def &lt;&lt;(row)
  # make sure headers have been assigned
  if header_row? and [Array, String].include? @use_headers.class and !@write_headers
    parse_headers  # won't read data for Array or String
  end

  # handle CSV::Row objects and Hashes
  row = case row
        when self.class::Row then row.fields
        when Hash            then @headers.map { |header| row[header] }
        else                      row
        end

  @headers =  row if header_row?
  @lineno  += 1

  output = row.map(&amp;@quote).join(@col_sep) + @row_sep  # quote and separate
  if @io.is_a?(StringIO)             and
     output.encoding != (encoding = raw_encoding)
    if @force_encoding
      output = output.encode(encoding)
    elsif (compatible_encoding = Encoding.compatible?(@io.string, output))
      @io.set_encoding(compatible_encoding)
      @io.seek(0, IO::SEEK_END)
    end
  end
  @io &lt;&lt; output

  self  # for chaining
end</pre> </div> <p>The primary write method for wrapped Strings and IOs, <code>row</code> (an Array or <a href="../csv/row/">CSV::Row</a>) is converted to <a href="../csv/">CSV</a> and appended to the data source. When a <a href="../csv/row/">CSV::Row</a> is passed, only the row's fields() are appended to the output.</p> <p>The data source must be open for writing.</p>  </div> <div class="aliases"> Also aliased as: <a href="../csv/#method-i-add_row">add_row</a>, <a href="../csv/#method-i-puts">puts</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-add_row"> <span class="method-name">add_row</span><span class="method-args">(row)</span> </div>  <div class="aliases"> Alias for: <a href="../csv/#method-i-3C-3C">&lt;&lt;</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-convert"> <span class="method-callseq"> convert( name ) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> convert { |field| ... } </span> </div> <div class="method-heading"> <span class="method-callseq"> convert { |field, field_info| ... } </span> </div> <div class="method-description">
<div class="method-source-code" id="convert-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1728
def convert(name = nil, &amp;converter)
  add_converter(:@converters, self.class::Converters, name, &amp;converter)
end</pre> </div> <p>You can use this method to install a <a href="../csv/#Converters">CSV::Converters</a> built-in, or provide a block that handles a custom conversion.</p> <p>If you provide a block that takes one argument, it will be passed the field and is expected to return the converted value or the field itself. If your block takes two arguments, it will also be passed a <a href="../csv/#FieldInfo">CSV::FieldInfo</a> <a href="../struct/">Struct</a>, containing details about the field. Again, the block should return a converted field or the field itself.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-converters"> <span class="method-name">converters</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="converters-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1594
def converters
  @converters.map do |converter|
    name = Converters.rassoc(converter)
    name ? name.first : converter
  end
end</pre> </div> <p>Returns the current list of converters in effect. See <a href="../csv/#method-c-new">::new</a> for details. Built-in converters will be returned by name, while others will be returned as is.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-name">each</span><span class="method-args">() { |row| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1759
def each
  if block_given?
    while row = shift
      yield row
    end
  else
    to_enum
  end
end</pre> </div> <p>Yields each row of the data source in turn.</p> <p>Support for <a href="../enumerable/">Enumerable</a>.</p> <p>The data source must be open for reading.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-force_quotes-3F"> <span class="method-name">force_quotes?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="force_quotes-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1637
def force_quotes?()       @force_quotes       end</pre> </div> <p>Returns <code>true</code> if all output fields are quoted. See <a href="../csv/#method-c-new">::new</a> for details.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-gets"> <span class="method-name">gets</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../csv/#method-i-shift">shift</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-header_convert"> <span class="method-callseq"> header_convert( name ) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> header_convert { |field| ... } </span> </div> <div class="method-heading"> <span class="method-callseq"> header_convert { |field, field_info| ... } </span> </div> <div class="method-description">
<div class="method-source-code" id="header_convert-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1743
def header_convert(name = nil, &amp;converter)
  add_converter( :@header_converters,
                 self.class::HeaderConverters,
                 name,
                 &amp;converter )
end</pre> </div> <p>Identical to <a href="../csv/#method-i-convert">#convert</a>, but for header rows.</p> <p>Note that this method must be called before header rows are read to have any effect.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-header_converters"> <span class="method-name">header_converters</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="header_converters-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1625
def header_converters
  @header_converters.map do |converter|
    name = HeaderConverters.rassoc(converter)
    name ? name.first : converter
  end
end</pre> </div> <p>Returns the current list of converters in effect for headers. See <a href="../csv/#method-c-new">::new</a> for details. Built-in converters will be returned by name, while others will be returned as is.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-header_row-3F"> <span class="method-name">header_row?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="header_row-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1785
def header_row?
  @use_headers and @headers.nil?
end</pre> </div> <p>Returns <code>true</code> if the next row read will be a header row.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-headers"> <span class="method-name">headers</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="headers-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1610
def headers
  @headers || true if @use_headers
end</pre> </div> <p>Returns <code>nil</code> if headers will not be used, <code>true</code> if they will but have not yet been read, or the actual headers after they have been read. See <a href="../csv/#method-c-new">::new</a> for details.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-name">inspect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1959
def inspect
  str = ["&lt;#", self.class.to_s, " io_type:"]
  # show type of wrapped IO
  if    @io == $stdout then str &lt;&lt; "$stdout"
  elsif @io == $stdin  then str &lt;&lt; "$stdin"
  elsif @io == $stderr then str &lt;&lt; "$stderr"
  else                      str &lt;&lt; @io.class.to_s
  end
  # show IO.path(), if available
  if @io.respond_to?(:path) and (p = @io.path)
    str &lt;&lt; " io_path:" &lt;&lt; p.inspect
  end
  # show encoding
  str &lt;&lt; " encoding:" &lt;&lt; @encoding.name
  # show other attributes
  %w[ lineno     col_sep     row_sep
      quote_char skip_blanks liberal_parsing ].each do |attr_name|
    if a = instance_variable_get("@#{attr_name}")
      str &lt;&lt; " " &lt;&lt; attr_name &lt;&lt; ":" &lt;&lt; a.inspect
    end
  end
  if @use_headers
    str &lt;&lt; " headers:" &lt;&lt; headers.inspect
  end
  str &lt;&lt; "&gt;"
  begin
    str.join('')
  rescue  # any encoding error
    str.map do |s|
      e = Encoding::Converter.asciicompat_encoding(s.encoding)
      e ? s.encode(e) : s.force_encoding("ASCII-8BIT")
    end.join('')
  end
end</pre> </div> <p>Returns a simplified description of the key <a href="../csv/">CSV</a> attributes in an ASCII compatible String.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-liberal_parsing-3F"> <span class="method-name">liberal_parsing?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="liberal_parsing-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1639
def liberal_parsing?()    @liberal_parsing    end</pre> </div> <p>Returns <code>true</code> if illegal input is handled. See <a href="../csv/#method-c-new">::new</a> for details.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-puts"> <span class="method-name">puts</span><span class="method-args">(row)</span> </div>  <div class="aliases"> Alias for: <a href="../csv/#method-i-3C-3C">&lt;&lt;</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-read"> <span class="method-name">read</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="read-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1774
def read
  rows = to_a
  if @use_headers
    Table.new(rows)
  else
    rows
  end
end</pre> </div> <p>Slurps the remaining rows and returns an Array of Arrays.</p> <p>The data source must be open for reading.</p>  </div> <div class="aliases"> Also aliased as: <a href="../csv/#method-i-readlines">readlines</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-readline"> <span class="method-name">readline</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../csv/#method-i-shift">shift</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-readlines"> <span class="method-name">readlines</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../csv/#method-i-read">read</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-return_headers-3F"> <span class="method-name">return_headers?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="return_headers-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1617
def return_headers?()     @return_headers     end</pre> </div> <p>Returns <code>true</code> if headers will be returned as a row of results. See <a href="../csv/#method-c-new">::new</a> for details.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rewind"> <span class="method-name">rewind</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rewind-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1664
def rewind
  @headers = nil
  @lineno  = 0

  @io.rewind
end</pre> </div> <p>Rewinds the underlying <a href="../io/">IO</a> object and resets CSV's lineno() counter.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-shift"> <span class="method-name">shift</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="shift-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1796
def shift
  #########################################################################
  ### This method is purposefully kept a bit long as simple conditional ###
  ### checks are faster than numerous (expensive) method calls.         ###
  #########################################################################

  # handle headers not based on document content
  if header_row? and @return_headers and
     [Array, String].include? @use_headers.class
    if @unconverted_fields
      return add_unconverted_fields(parse_headers, Array.new)
    else
      return parse_headers
    end
  end

  #
  # it can take multiple calls to &lt;tt&gt;@io.gets()&lt;/tt&gt; to get a full line,
  # because of \r and/or \n characters embedded in quoted fields
  #
  in_extended_col = false
  csv             = Array.new

  loop do
    # add another read to the line
    unless parse = @io.gets(@row_sep)
      return nil
    end

    if in_extended_col
      @line.concat(parse)
    else
      @line = parse.clone
    end

    parse.sub!(@parsers[:line_end], "")

    if csv.empty?
      #
      # I believe a blank line should be an &lt;tt&gt;Array.new&lt;/tt&gt;, not Ruby 1.8
      # CSV's &lt;tt&gt;[nil]&lt;/tt&gt;
      #
      if parse.empty?
        @lineno += 1
        if @skip_blanks
          next
        elsif @unconverted_fields
          return add_unconverted_fields(Array.new, Array.new)
        elsif @use_headers
          return self.class::Row.new(Array.new, Array.new)
        else
          return Array.new
        end
      end
    end

    next if @skip_lines and @skip_lines.match parse

    parts =  parse.split(@col_sep, -1)
    if parts.empty?
      if in_extended_col
        csv[-1] &lt;&lt; @col_sep   # will be replaced with a @row_sep after the parts.each loop
      else
        csv &lt;&lt; nil
      end
    end

    # This loop is the hot path of csv parsing. Some things may be non-dry
    # for a reason. Make sure to benchmark when refactoring.
    parts.each do |part|
      if in_extended_col
        # If we are continuing a previous column
        if part.end_with?(@quote_char) &amp;&amp; part.count(@quote_char) % 2 != 0
          # extended column ends
          csv.last &lt;&lt; part[0..-2]
          if csv.last =~ @parsers[:stray_quote]
            raise MalformedCSVError,
                  "Missing or stray quote in line #{lineno + 1}"
          end
          csv.last.gsub!(@double_quote_char, @quote_char)
          in_extended_col = false
        else
          csv.last &lt;&lt; part &lt;&lt; @col_sep
        end
      elsif part.start_with?(@quote_char)
        # If we are starting a new quoted column
        if part.count(@quote_char) % 2 != 0
          # start an extended column
          csv &lt;&lt; (part[1..-1] &lt;&lt; @col_sep)
          in_extended_col =  true
        elsif part.end_with?(@quote_char)
          # regular quoted column
          csv &lt;&lt; part[1..-2]
          if csv.last =~ @parsers[:stray_quote]
            raise MalformedCSVError,
                  "Missing or stray quote in line #{lineno + 1}"
          end
          csv.last.gsub!(@double_quote_char, @quote_char)
        elsif @liberal_parsing
          csv &lt;&lt; part
        else
          raise MalformedCSVError,
                "Missing or stray quote in line #{lineno + 1}"
        end
      elsif part =~ @parsers[:quote_or_nl]
        # Unquoted field with bad characters.
        if part =~ @parsers[:nl_or_lf]
          raise MalformedCSVError, "Unquoted fields do not allow " +
                                   "\\r or \\n (line #{lineno + 1})."
        else
          if @liberal_parsing
            csv &lt;&lt; part
          else
            raise MalformedCSVError, "Illegal quoting in line #{lineno + 1}."
          end
        end
      else
        # Regular ole unquoted field.
        csv &lt;&lt; (part.empty? ? nil : part)
      end
    end

    # Replace tacked on @col_sep with @row_sep if we are still in an extended
    # column.
    csv[-1][-1] = @row_sep if in_extended_col

    if in_extended_col
      # if we're at eof?(), a quoted field wasn't closed...
      if @io.eof?
        raise MalformedCSVError,
              "Unclosed quoted field on line #{lineno + 1}."
      elsif @field_size_limit and csv.last.size &gt;= @field_size_limit
        raise MalformedCSVError, "Field size exceeded on line #{lineno + 1}."
      end
      # otherwise, we need to loop and pull some more data to complete the row
    else
      @lineno += 1

      # save fields unconverted fields, if needed...
      unconverted = csv.dup if @unconverted_fields

      # convert fields, if needed...
      csv = convert_fields(csv) unless @use_headers or @converters.empty?
      # parse out header rows and handle CSV::Row conversions...
      csv = parse_headers(csv)  if     @use_headers

      # inject unconverted fields and accessor, if requested...
      if @unconverted_fields and not csv.respond_to? :unconverted_fields
        add_unconverted_fields(csv, unconverted)
      end

      # return the results
      break csv
    end
  end
end</pre> </div> <p>The primary read method for wrapped Strings and IOs, a single row is pulled from the data source, parsed and returned as an Array of fields (if header rows are not used) or a <a href="../csv/row/">CSV::Row</a> (when header rows are used).</p> <p>The data source must be open for reading.</p>  </div> <div class="aliases"> Also aliased as: <a href="../csv/#method-i-gets">gets</a>, <a href="../csv/#method-i-readline">readline</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-skip_blanks-3F"> <span class="method-name">skip_blanks?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="skip_blanks-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1635
def skip_blanks?()        @skip_blanks        end</pre> </div> <p>Returns <code>true</code> blank lines are skipped by the parser. See <a href="../csv/#method-c-new">::new</a> for details.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-unconverted_fields-3F"> <span class="method-name">unconverted_fields?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="unconverted_fields-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1604
def unconverted_fields?() @unconverted_fields end</pre> </div> <p>Returns <code>true</code> if unconverted_fields() to parsed results. See <a href="../csv/#method-c-new">::new</a> for details.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_headers-3F"> <span class="method-name">write_headers?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="write_headers-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1619
def write_headers?()      @write_headers      end</pre> </div> <p>Returns <code>true</code> if headers are written in output. See <a href="../csv/#method-c-new">::new</a> for details.</p>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-add_converter"> <span class="method-name">add_converter</span><span class="method-args">(var_name, const, name = nil, &amp;converter)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_converter-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2176
def add_converter(var_name, const, name = nil, &amp;converter)
  if name.nil?  # custom converter
    instance_variable_get(var_name) &lt;&lt; converter
  else          # named converter
    combo = const[name]
    case combo
    when Array  # combo converter
      combo.each do |converter_name|
        add_converter(var_name, const, converter_name)
      end
    else        # individual named converter
      instance_variable_get(var_name) &lt;&lt; combo
    end
  end
end</pre> </div> <p>The actual work method for adding converters, used by both <a href="../csv/#method-i-convert">#convert</a> and <a href="../csv/#method-i-header_convert">#header_convert</a>.</p> <p>This method requires the <code>var_name</code> of the instance variable to place the converters in, the <code>const</code> <a href="../hash/">Hash</a> to lookup named converters in, and the normal parameters of the <a href="../csv/#method-i-convert">#convert</a> and <a href="../csv/#method-i-header_convert">#header_convert</a> methods.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_unconverted_fields"> <span class="method-name">add_unconverted_fields</span><span class="method-args">(row, fields)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_unconverted_fields-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2263
def add_unconverted_fields(row, fields)
  class &lt;&lt; row
    attr_reader :unconverted_fields
  end
  row.instance_variable_set(:@unconverted_fields, fields)
  row
end</pre> </div> <p>This method injects an instance variable <code>unconverted_fields</code> into <code>row</code> and an accessor method for <code>row</code> called unconverted_fields(). The variable is set to the contents of <code>fields</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-convert_fields"> <span class="method-name">convert_fields</span><span class="method-args">(fields, headers = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="convert_fields-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2199
def convert_fields(fields, headers = false)
  # see if we are converting headers or fields
  converters = headers ? @header_converters : @converters

  fields.map.with_index do |field, index|
    converters.each do |converter|
      break if headers &amp;&amp; field.nil?
      field = if converter.arity == 1  # straight field converter
        converter[field]
      else                             # FieldInfo converter
        header = @use_headers &amp;&amp; !headers ? @headers[index] : nil
        converter[field, FieldInfo.new(index, lineno, header)]
      end
      break unless field.is_a? String  # short-circuit pipeline for speed
    end
    field  # final state of each field, converted or original
  end
end</pre> </div> <p>Processes <code>fields</code> with <code>@converters</code>, or <code>@header_converters</code> if <code>headers</code> is passed as <code>true</code>, returning the converted field set. Any converter that changes the field into something other than a String halts the pipeline of conversion for that field. This is primarily an efficiency shortcut.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-encode_re"> <span class="method-name">encode_re</span><span class="method-args">(*chunks)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="encode_re-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2286
def encode_re(*chunks)
  Regexp.new(encode_str(*chunks))
end</pre> </div> <p>Builds a regular expression in <code>@encoding</code>. All <code>chunks</code> will be transcoded to that encoding.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-encode_str"> <span class="method-name">encode_str</span><span class="method-args">(*chunks)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="encode_str-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2294
def encode_str(*chunks)
  chunks.map { |chunk| chunk.encode(@encoding.name) }.join('')
end</pre> </div> <p>Builds a String in <code>@encoding</code>. All <code>chunks</code> will be transcoded to that encoding.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-escape_re"> <span class="method-name">escape_re</span><span class="method-args">(str)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="escape_re-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2278
def escape_re(str)
  str.gsub(@re_chars) {|c| @re_esc + c}
end</pre> </div> <p>This method is an encoding safe version of <a href="../regexp/#method-c-escape">Regexp.escape</a>. It will escape any characters that would change the meaning of a regular expression in the encoding of <code>str</code>. Regular expression characters that cannot be transcoded to the target encoding will be skipped and no escaping will be performed if a backslash cannot be transcoded.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-init_comments"> <span class="method-name">init_comments</span><span class="method-args">(skip_lines)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="init_comments-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2161
def init_comments(skip_lines)
  @skip_lines = skip_lines
  @skip_lines = Regexp.new(Regexp.escape(@skip_lines)) if @skip_lines.is_a? String
  if @skip_lines and not @skip_lines.respond_to?(:match)
    raise ArgumentError, ":skip_lines has to respond to matches"
  end
end</pre> </div> <p>Stores the pattern of comments to skip from the provided options.</p> <p>The pattern must respond to <code>.match</code>, else <a href="../argumenterror/">ArgumentError</a> is raised. Strings are converted to a <a href="../regexp/">Regexp</a>.</p> <p>See also <a href="../csv/#method-c-new">::new</a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-init_converters"> <span class="method-name">init_converters</span><span class="method-args">(converters, ivar_name, convert_method)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="init_converters-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2136
def init_converters(converters, ivar_name, convert_method)
  converters = case converters
               when nil then []
               when Array then converters
               else [converters]
               end
  instance_variable_set(ivar_name, [])
  convert = method(convert_method)

  # load converters
  converters.each do |converter|
    if converter.is_a? Proc  # custom code block
      convert.call(&amp;converter)
    else                     # by name
      convert.call(converter)
    end
  end
end</pre> </div> <p>Loads any converters requested during construction.</p> <p>If <code>field_name</code> is set <code>:converters</code> (the default) field converters are set. When <code>field_name</code> is <code>:header_converters</code> header converters are added instead.</p> <p>The <code>:unconverted_fields</code> option is also activated for <code>:converters</code> calls, if requested.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-init_parsers"> <span class="method-name">init_parsers</span><span class="method-args">(skip_blanks, field_size_limit, liberal_parsing)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="init_parsers-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2104
def init_parsers(skip_blanks, field_size_limit, liberal_parsing)
  # store the parser behaviors
  @skip_blanks      = skip_blanks
  @field_size_limit = field_size_limit
  @liberal_parsing  = liberal_parsing

  # prebuild Regexps for faster parsing
  esc_row_sep = escape_re(@row_sep)
  esc_quote   = escape_re(@quote_char)
  @parsers = {
    # for detecting parse errors
    quote_or_nl:    encode_re("[", esc_quote, "\r\n]"),
    nl_or_lf:       encode_re("[\r\n]"),
    stray_quote:    encode_re( "[^", esc_quote, "]", esc_quote,
                               "[^", esc_quote, "]" ),
    # safer than chomp!()
    line_end:       encode_re(esc_row_sep, "\\z"),
    # illegal unquoted characters
    return_newline: encode_str("\r\n")
  }
end</pre> </div> <p>Pre-compiles parsers and stores them by name for access during reads.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-init_separators"> <span class="method-name">init_separators</span><span class="method-args">(col_sep, row_sep, quote_char, force_quotes)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="init_separators-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2006
def init_separators(col_sep, row_sep, quote_char, force_quotes)
  # store the selected separators
  @col_sep    = col_sep.to_s.encode(@encoding)
  @row_sep    = row_sep # encode after resolving :auto
  @quote_char = quote_char.to_s.encode(@encoding)
  @double_quote_char = @quote_char * 2

  if @quote_char.length != 1
    raise ArgumentError, ":quote_char has to be a single character String"
  end

  #
  # automatically discover row separator when requested
  # (not fully encoding safe)
  #
  if @row_sep == :auto
    if [ARGF, STDIN, STDOUT, STDERR].include?(@io) or
       (defined?(Zlib) and @io.class == Zlib::GzipWriter)
      @row_sep = $INPUT_RECORD_SEPARATOR
    else
      begin
        #
        # remember where we were (pos() will raise an exception if @io is pipe
        # or not opened for reading)
        #
        saved_pos = @io.pos
        while @row_sep == :auto
          #
          # if we run out of data, it's probably a single line
          # (ensure will set default value)
          #
          break unless sample = @io.gets(nil, 1024)
          # extend sample if we're unsure of the line ending
          if sample.end_with? encode_str("\r")
            sample &lt;&lt; (@io.gets(nil, 1) || "")
          end

          # try to find a standard separator
          if sample =~ encode_re("\r\n?|\n")
            @row_sep = $&amp;
            break
          end
        end

        # tricky seek() clone to work around GzipReader's lack of seek()
        @io.rewind
        # reset back to the remembered position
        while saved_pos &gt; 1024  # avoid loading a lot of data into memory
          @io.read(1024)
          saved_pos -= 1024
        end
        @io.read(saved_pos) if saved_pos.nonzero?
      rescue IOError         # not opened for reading
        # do nothing:  ensure will set default
      rescue NoMethodError   # Zlib::GzipWriter doesn't have some IO methods
        # do nothing:  ensure will set default
      rescue SystemCallError # pipe
        # do nothing:  ensure will set default
      ensure
        #
        # set default if we failed to detect
        # (stream not opened for reading, a pipe, or a single line of data)
        #
        @row_sep = $INPUT_RECORD_SEPARATOR if @row_sep == :auto
      end
    end
  end
  @row_sep = @row_sep.to_s.encode(@encoding)

  # establish quoting rules
  @force_quotes = force_quotes
  do_quote = lambda do |field|
    field = String(field)
    encoded_quote = @quote_char.encode(field.encoding)
    encoded_quote + field.gsub(encoded_quote, encoded_quote * 2) + encoded_quote
  end
  quotable_chars = encode_str("\r\n", @col_sep, @quote_char)
  @quote         = if @force_quotes
    do_quote
  else
    lambda do |field|
      if field.nil?  # represent +nil+ fields as empty unquoted fields
        ""
      else
        field = String(field)  # Stringify fields
        # represent empty fields as empty quoted fields
        if field.empty? or
           field.count(quotable_chars).nonzero?
          do_quote.call(field)
        else
          field  # unquoted field
        end
      end
    end
  end
end</pre> </div> <p>Stores the indicated separators for later use.</p> <p>If auto-discovery was requested for <code>@row_sep</code>, this method will read ahead in the <code>@io</code> and try to find one. <code>ARGF</code>, <code>STDIN</code>, <code>STDOUT</code>, <code>STDERR</code> and any stream open for output only with a default <code>@row_sep</code> of <code>$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>).</p> <p>This method also establishes the quoting rules used for <a href="../csv/">CSV</a> output.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parse_headers"> <span class="method-name">parse_headers</span><span class="method-args">(row = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parse_headers-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2228
def parse_headers(row = nil)
  if @headers.nil?                # header row
    @headers = case @use_headers  # save headers
               # Array of headers
               when Array then @use_headers
               # CSV header String
               when String
                 self.class.parse_line( @use_headers,
                                        col_sep:    @col_sep,
                                        row_sep:    @row_sep,
                                        quote_char: @quote_char )
               # first row is headers
               else            row
               end

    # prepare converted and unconverted copies
    row      = @headers                       if row.nil?
    @headers = convert_fields(@headers, true)
    @headers.each { |h| h.freeze if h.is_a? String }

    if @return_headers                                     # return headers
      return self.class::Row.new(@headers, row, true)
    elsif not [Array, String].include? @use_headers.class  # skip to field row
      return shift
    end
  end

  self.class::Row.new(@headers, convert_fields(row))  # field row
end</pre> </div> <p>This method is used to turn a finished <code>row</code> into a <a href="../csv/row/">CSV::Row</a>. Header rows are also dealt with here, either by returning a <a href="../csv/row/">CSV::Row</a> with identical headers and fields (save that the fields do not go through the converters) or by reading past them to return a field row. Headers are also saved in <code>@headers</code> for use in future rows.</p> <p>When <code>nil</code>, <code>row</code> is assumed to be a header row not based on an actual row of the stream.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-raw_encoding"> <span class="method-name">raw_encoding</span><span class="method-args">(default = Encoding::ASCII_8BIT)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="raw_encoding-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2302
def raw_encoding(default = Encoding::ASCII_8BIT)
  if @io.respond_to? :internal_encoding
    @io.internal_encoding || @io.external_encoding
  elsif @io.is_a? StringIO
    @io.string.encoding
  elsif @io.respond_to? :encoding
    @io.encoding
  else
    default
  end
end</pre> </div> <p>Returns the encoding of the internal <a href="../io/">IO</a> object or the <code>default</code> if the encoding cannot be determined.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
