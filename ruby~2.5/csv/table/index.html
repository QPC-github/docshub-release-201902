
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>CSV&#58;&#58;Table - Ruby 2.5 - W3cubDocs</title>
  
  <meta name="description" content="A CSV&#58;&#58;Table is a two-dimensional data structure for representing CSV documents. Tables allow you to work with the data by row or column, &hellip;">
  <meta name="keywords" content="class, csv, table, -, ruby, ruby~2.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/ruby~2.5/csv/table/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/ruby~2.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.5/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.5</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rdoc">
				
				
<h1 id="class-CSV::Table" class="class"> class CSV::Table </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../../object/">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="../../enumerable/">Enumerable</a></dd>
</dl> <section class="description"> <p>A <a href="../table/">CSV::Table</a> is a two-dimensional data structure for representing <a href="../../csv/">CSV</a> documents. Tables allow you to work with the data by row or column, manipulate the data, and even convert the results back to <a href="../../csv/">CSV</a>, if needed.</p> <p>All tables returned by <a href="../../csv/">CSV</a> will be constructed from this class, if header row processing is activated.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-mode"> <span class="method-name">mode</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The current access mode for indexing and iteration.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-table"> <span class="method-name">table</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Internal data format used to compare equality.</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(array_of_rows)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 587
def initialize(array_of_rows)
  @table = array_of_rows
  @mode  = :col_or_row
end</pre> </div> <p>Construct a new <a href="../table/">CSV::Table</a> from <code>array_of_rows</code>, which are expected to be <a href="../row/">CSV::Row</a> objects. All rows are assumed to have the same headers.</p> <p>A <a href="../table/">CSV::Table</a> object supports the following Array methods through delegation:</p> <ul>
<li> <p>empty?()</p> </li>
<li> <p>length()</p> </li>
<li> <p>size()</p> </li>
</ul>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3C"> <span class="method-name">&lt;&lt;</span><span class="method-args">(row_or_array)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 785
def &lt;&lt;(row_or_array)
  if row_or_array.is_a? Array  # append Array
    @table &lt;&lt; Row.new(headers, row_or_array)
  else                         # append Row
    @table &lt;&lt; row_or_array
  end

  self  # for chaining
end</pre> </div> <p>Adds a new row to the bottom end of this table. You can provide an Array, which will be converted to a <a href="../row/">CSV::Row</a> (inheriting the table's headers()), or a <a href="../row/">CSV::Row</a>.</p> <p>This method returns the table for chaining.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-name">==</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 871
def ==(other)
  return @table == other.table if other.is_a? CSV::Table
  @table == other
end</pre> </div> <p>Returns <code>true</code> if all rows of this table ==() <code>other</code>'s rows.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-name">[]</span><span class="method-args">(index_or_header)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 701
def [](index_or_header)
  if @mode == :row or  # by index
     (@mode == :col_or_row and (index_or_header.is_a?(Integer) or index_or_header.is_a?(Range)))
    @table[index_or_header]
  else                 # by header
    @table.map { |row| row[index_or_header] }
  end
end</pre> </div> <p>In the default mixed mode, this method returns rows for index access and columns for header access. You can force the index association by first calling <a href="../table/#method-i-by_col">#by_col</a>!() or <a href="../table/#method-i-by_row">#by_row</a>!().</p> <p>Columns are returned as an Array of values. Altering that Array has no effect on the table.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-name">[]=</span><span class="method-args">(index_or_header, value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 726
def []=(index_or_header, value)
  if @mode == :row or  # by index
     (@mode == :col_or_row and index_or_header.is_a? Integer)
    if value.is_a? Array
      @table[index_or_header] = Row.new(headers, value)
    else
      @table[index_or_header] = value
    end
  else                 # set column
    if value.is_a? Array  # multiple values
      @table.each_with_index do |row, i|
        if row.header_row?
          row[index_or_header] = index_or_header
        else
          row[index_or_header] = value[i]
        end
      end
    else                  # repeated value
      @table.each do |row|
        if row.header_row?
          row[index_or_header] = index_or_header
        else
          row[index_or_header] = value
        end
      end
    end
  end
end</pre> </div> <p>In the default mixed mode, this method assigns rows for index access and columns for header access. You can force the index association by first calling <a href="../table/#method-i-by_col">#by_col</a>!() or <a href="../table/#method-i-by_row">#by_row</a>!().</p> <p>Rows may be set to an Array of values (which will inherit the table's headers()) or a <a href="../row/">CSV::Row</a>.</p> <p>Columns may be set to a single value, which is copied to each row of the column, or an Array of values. Arrays of values are assigned to rows top to bottom in row major order. Excess values are ignored and if the Array does not have a value for each row the extra rows will receive a <code>nil</code>.</p> <p>Assigning to an existing column or row clobbers the data. Assigning to new columns creates them at the right end of the table.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-by_col"> <span class="method-name">by_col</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="by_col-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 613
def by_col
  self.class.new(@table.dup).by_col!
end</pre> </div> <p>Returns a duplicate table object, in column mode. This is handy for chaining in a single call without changing the table mode, but be aware that this method can consume a fair amount of memory for bigger data sets.</p> <p>This method returns the duplicate table for chaining. Don't chain destructive methods (like []=()) this way though, since you are working with a duplicate.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-by_col-21"> <span class="method-name">by_col!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="by_col-21-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 623
def by_col!
  @mode = :col

  self
end</pre> </div> <p>Switches the mode of this table to column mode. All calls to indexing and iteration methods will work with columns until the mode is changed again.</p> <p>This method returns the table and is safe to chain.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-by_col_or_row"> <span class="method-name">by_col_or_row</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="by_col_or_row-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 638
def by_col_or_row
  self.class.new(@table.dup).by_col_or_row!
end</pre> </div> <p>Returns a duplicate table object, in mixed mode. This is handy for chaining in a single call without changing the table mode, but be aware that this method can consume a fair amount of memory for bigger data sets.</p> <p>This method returns the duplicate table for chaining. Don't chain destructive methods (like []=()) this way though, since you are working with a duplicate.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-by_col_or_row-21"> <span class="method-name">by_col_or_row!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="by_col_or_row-21-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 650
def by_col_or_row!
  @mode = :col_or_row

  self
end</pre> </div> <p>Switches the mode of this table to mixed mode. All calls to indexing and iteration methods will use the default intelligent indexing system until the mode is changed again. In mixed mode an index is assumed to be a row reference while anything else is assumed to be column access by headers.</p> <p>This method returns the table and is safe to chain.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-by_row"> <span class="method-name">by_row</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="by_row-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 665
def by_row
  self.class.new(@table.dup).by_row!
end</pre> </div> <p>Returns a duplicate table object, in row mode. This is handy for chaining in a single call without changing the table mode, but be aware that this method can consume a fair amount of memory for bigger data sets.</p> <p>This method returns the duplicate table for chaining. Don't chain destructive methods (like []=()) this way though, since you are working with a duplicate.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-by_row-21"> <span class="method-name">by_row!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="by_row-21-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 675
def by_row!
  @mode = :row

  self
end</pre> </div> <p>Switches the mode of this table to row mode. All calls to indexing and iteration methods will work with rows until the mode is changed again.</p> <p>This method returns the table and is safe to chain.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-delete"> <span class="method-name">delete</span><span class="method-args">(index_or_header)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="delete-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 813
def delete(index_or_header)
  if @mode == :row or  # by index
     (@mode == :col_or_row and index_or_header.is_a? Integer)
    @table.delete_at(index_or_header)
  else                 # by header
    @table.map { |row| row.delete(index_or_header).last }
  end
end</pre> </div> <p>Removes and returns the indicated column or row. In the default mixed mode indices refer to rows and everything else is assumed to be a column header. Use <a href="../table/#method-i-by_col">#by_col</a>!() or <a href="../table/#method-i-by_row">#by_row</a>!() to force the lookup.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-delete_if"> <span class="method-name">delete_if</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="delete_if-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 832
def delete_if(&amp;block)
  block or return enum_for(__method__) { @mode == :row or @mode == :col_or_row ? size : headers.size }

  if @mode == :row or @mode == :col_or_row  # by index
    @table.delete_if(&amp;block)
  else                                      # by header
    deleted = []
    headers.each do |header|
      deleted &lt;&lt; delete(header) if block[[header, self[header]]]
    end
  end

  self  # for chaining
end</pre> </div> <p>Removes any column or row for which the block returns <code>true</code>. In the default mixed mode or row mode, iteration is the standard row major walking of rows. In column mode, iteration will <code>yield</code> two element tuples containing the column name and an Array of values for that column.</p> <p>This method returns the table for chaining.</p> <p>If no block is given, an <a href="../../enumerator/">Enumerator</a> is returned.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-name">each</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 858
def each(&amp;block)
  block or return enum_for(__method__) { @mode == :col ? headers.size : size }

  if @mode == :col
    headers.each { |header| block[[header, self[header]]] }
  else
    @table.each(&amp;block)
  end

  self  # for chaining
end</pre> </div> <p>In the default mixed mode or row mode, iteration is the standard row major walking of rows. In column mode, iteration will <code>yield</code> two element tuples containing the column name and an Array of values for that column.</p> <p>This method returns the table for chaining.</p> <p>If no block is given, an <a href="../../enumerator/">Enumerator</a> is returned.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-headers"> <span class="method-name">headers</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="headers-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 685
def headers
  if @table.empty?
    Array.new
  else
    @table.first.headers
  end
end</pre> </div> <p>Returns the headers for the first row of this table (assumed to match all other rows). An empty Array is returned for empty tables.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-name">inspect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 905
def inspect
  "#&lt;#{self.class} mode:#{@mode} row_count:#{to_a.size}&gt;".encode("US-ASCII")
end</pre> </div> <p>Shows the mode and size of this table in a US-ASCII String.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-push"> <span class="method-name">push</span><span class="method-args">(*rows)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="push-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 802
def push(*rows)
  rows.each { |row| self &lt;&lt; row }

  self  # for chaining
end</pre> </div> <p>A shortcut for appending multiple rows. Equivalent to:</p> <pre class="ruby" data-language="ruby">rows.each { |row| self &lt;&lt; row }
</pre> <p>This method returns the table for chaining.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_a"> <span class="method-name">to_a</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 880
def to_a
  array = [headers]
  @table.each do |row|
    array.push(row.fields) unless row.header_row?
  end
  return array
end</pre> </div> <p>Returns the table as an Array of Arrays. Headers will be the first row, then all of the field rows will follow.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_csv"> <span class="method-name">to_csv</span><span class="method-args">(write_headers: true, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_csv-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 895
def to_csv(write_headers: true, **options)
  array = write_headers ? [headers.to_csv(options)] : []
  @table.each do |row|
    array.push(row.fields.to_csv(options)) unless row.header_row?
  end
  return array.join('')
end</pre> </div> <p>Returns the table as a complete <a href="../../csv/">CSV</a> String. Headers will be listed first, then all of the field rows.</p> <p>This method assumes you want the <a href="../table/#method-i-headers">#headers</a>, unless you explicitly pass <code>:write_headers =&gt; false</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="../table/#method-i-to_s">to_s</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span><span class="method-args">(write_headers: true, **options)</span> </div>  <div class="aliases"> Alias for: <a href="../table/#method-i-to_csv">to_csv</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values_at"> <span class="method-name">values_at</span><span class="method-args">(*indices_or_headers)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 764
def values_at(*indices_or_headers)
  if @mode == :row or  # by indices
     ( @mode == :col_or_row and indices_or_headers.all? do |index|
                                  index.is_a?(Integer)         or
                                  ( index.is_a?(Range)         and
                                    index.first.is_a?(Integer) and
                                    index.last.is_a?(Integer) )
                                end )
    @table.values_at(*indices_or_headers)
  else                 # by headers
    @table.map { |row| row.values_at(*indices_or_headers) }
  end
end</pre> </div> <p>The mixed mode default is to treat a list of indices as row access, returning the rows indicated. Anything else is considered columnar access. For columnar access, the return set has an Array for each row with the values indicated by the headers in each Array. You can force column or row mode using <a href="../table/#method-i-by_col">#by_col</a>!() or <a href="../table/#method-i-by_row">#by_row</a>!().</p> <p>You cannot mix column and row access.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
