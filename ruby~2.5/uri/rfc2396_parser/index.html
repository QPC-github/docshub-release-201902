
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>URI&#58;&#58;RFC2396_Parser - Ruby 2.5 - W3cubDocs</title>
  
  <meta name="description" content=" class that Parses String&#39;s into URI&#39;s ">
  <meta name="keywords" content="class, uri, rfc, parser, -, ruby, ruby~2.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/ruby~2.5/uri/rfc2396_parser/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/ruby~2.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.5/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rdoc">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1 id="class-URI::RFC2396_Parser" class="class"> class URI::RFC2396_Parser </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../../object/">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="../rfc2396_regexp/">URI::RFC2396_REGEXP</a></dd>
</dl> <section class="description"> <p>class that Parses String's into URI's</p> <p>It contains a <a href="../../hash/">Hash</a> set of patterns and Regexp's that match and validate.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-pattern"> <span class="method-name">pattern</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The <a href="../../hash/">Hash</a> of patterns.</p> <p>see also URI::Parser.initialize_pattern</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-regexp"> <span class="method-name">regexp</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The <a href="../../hash/">Hash</a> of <a href="../../regexp/">Regexp</a></p> <p>see also URI::Parser.initialize_regexp</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(opts = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 99
def initialize(opts = {})
  @pattern = initialize_pattern(opts)
  @pattern.each_value(&amp;:freeze)
  @pattern.freeze

  @regexp = initialize_regexp(@pattern)
  @regexp.each_value(&amp;:freeze)
  @regexp.freeze
end</pre> </div> <h2 id="method-c-new-label-Synopsis">Synopsis</h2> <pre class="ruby" data-language="ruby">URI::Parser.new([opts])
</pre> <h2 id="method-c-new-label-Args">Args</h2> <p>The constructor accepts a hash as options for parser. Keys of options are pattern names of <a href="../../uri/">URI</a> components and values of options are pattern strings. The constructor generates set of regexps for parsing URIs.</p> <p>You can use the following keys:</p> <pre>* :ESCAPED (URI::PATTERN::ESCAPED in default)
* :UNRESERVED (URI::PATTERN::UNRESERVED in default)
* :DOMLABEL (URI::PATTERN::DOMLABEL in default)
* :TOPLABEL (URI::PATTERN::TOPLABEL in default)
* :HOSTNAME (URI::PATTERN::HOSTNAME in default)</pre> <h2 id="method-c-new-label-Examples">Examples</h2> <pre class="ruby" data-language="ruby">p = URI::Parser.new(:ESCAPED =&gt; "(?:%[a-fA-F0-9]{2}|%u[a-fA-F0-9]{4})")
u = p.parse("http://example.jp/%uABCD") #=&gt; #&lt;URI::HTTP:0xb78cf4f8 URL:http://example.jp/%uABCD&gt;
URI.parse(u.to_s) #=&gt; raises URI::InvalidURIError

s = "http://example.com/ABCD"
u1 = p.parse(s) #=&gt; #&lt;URI::HTTP:0xb78c3220 URL:http://example.com/ABCD&gt;
u2 = URI.parse(s) #=&gt; #&lt;URI::HTTP:0xb78b6d54 URL:http://example.com/ABCD&gt;
u1 == u2 #=&gt; true
u1.eql?(u2) #=&gt; false
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-escape"> <span class="method-callseq"> escape( str ) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> escape( str, unsafe ) </span> </div> <div class="method-description">
<div class="method-source-code" id="escape-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 299
def escape(str, unsafe = @regexp[:UNSAFE])
  unless unsafe.kind_of?(Regexp)
    # perhaps unsafe is String object
    unsafe = Regexp.new("[#{Regexp.quote(unsafe)}]", false)
  end
  str.gsub(unsafe) do
    us = $&amp;
    tmp = ''
    us.each_byte do |uc|
      tmp &lt;&lt; sprintf('%%%02X', uc)
    end
    tmp
  end.force_encoding(Encoding::US_ASCII)
end</pre> </div> <h2 id="method-i-escape-label-Args">Args</h2> <dl class="rdoc-list note-list">
<dt>
<code>str</code> </dt>
<dd> <p>String to make safe</p> </dd>
<dt>
<code>unsafe</code> </dt>
<dd> <p><a href="../../regexp/">Regexp</a> to apply. Defaults to <a href="#">self.regexp</a></p> </dd>
</dl> <h2 id="method-i-escape-label-Description">Description</h2> <p>constructs a safe String from <code>str</code>, removing unsafe characters, replacing them with codes.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-extract"> <span class="method-callseq"> extract( str ) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> extract( str, schemes ) </span> </div> <div class="method-heading"> <span class="method-callseq"> extract( str, schemes ) {|item| block } </span> </div> <div class="method-description">
<div class="method-source-code" id="extract-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 261
def extract(str, schemes = nil)
  if block_given?
    str.scan(make_regexp(schemes)) { yield $&amp; }
    nil
  else
    result = []
    str.scan(make_regexp(schemes)) { result.push $&amp; }
    result
  end
end</pre> </div> <h2 id="method-i-extract-label-Args">Args</h2> <dl class="rdoc-list note-list">
<dt>
<code>str</code> </dt>
<dd> <p>String to search</p> </dd>
<dt>
<code>schemes</code> </dt>
<dd> <p>Patterns to apply to <code>str</code></p> </dd>
</dl> <h2 id="method-i-extract-label-Description">Description</h2> <p>Attempts to parse and merge a set of URIs If no <code>block</code> given , then returns the result, else it calls <code>block</code> for each element in result.</p> <p>see also URI::Parser.make_regexp</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-name">inspect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 335
def inspect
  @@to_s.bind(self).call
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-join"> <span class="method-name">join</span><span class="method-args">(*uris)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="join-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 235
def join(*uris)
  uris[0] = convert_to_uri(uris[0])
  uris.inject :merge
end</pre> </div> <h2 id="method-i-join-label-Args">Args</h2> <dl class="rdoc-list note-list">
<dt>
<code>uris</code> </dt>
<dd> <p>an Array of Strings</p> </dd>
</dl> <h2 id="method-i-join-label-Description">Description</h2> <p>Attempts to parse and merge a set of URIs</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-make_regexp"> <span class="method-name">make_regexp</span><span class="method-args">(schemes = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="make_regexp-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 274
def make_regexp(schemes = nil)
  unless schemes
    @regexp[:ABS_URI_REF]
  else
    /(?=#{Regexp.union(*schemes)}:)#{@pattern[:X_ABS_URI]}/x
  end
end</pre> </div> <p>returns <a href="../../regexp/">Regexp</a> that is default <a href="#">self.regexp</a>, unless <code>schemes</code> is provided. Then it is a <a href="../../regexp/#method-c-union">Regexp.union</a> with <a href="#">self.pattern</a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parse"> <span class="method-name">parse</span><span class="method-args">(uri)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 209
def parse(uri)
  scheme, userinfo, host, port,
    registry, path, opaque, query, fragment = self.split(uri)

  if scheme &amp;&amp; URI.scheme_list.include?(scheme.upcase)
    URI.scheme_list[scheme.upcase].new(scheme, userinfo, host, port,
                                       registry, path, opaque, query,
                                       fragment, self)
  else
    Generic.new(scheme, userinfo, host, port,
                registry, path, opaque, query,
                fragment, self)
  end
end</pre> </div> <h2 id="method-i-parse-label-Args">Args</h2> <dl class="rdoc-list note-list">
<dt>
<code>uri</code> </dt>
<dd> <p>String</p> </dd>
</dl> <h2 id="method-i-parse-label-Description">Description</h2> <p>parses <code>uri</code> and constructs either matching <a href="../../uri/">URI</a> scheme object (FTP, <a href="http" target="_blank">HTTP</a>, <a href="https" target="_blank">HTTPS</a>, <a href="../ldap/">LDAP</a>, <a href="../ldaps/">LDAPS</a>, or <a href="../mailto/">MailTo</a>) or <a href="../generic/">URI::Generic</a></p> <h2 id="method-i-parse-label-Usage">Usage</h2> <pre class="ruby" data-language="ruby">p = URI::Parser.new
p.parse("ldap://ldap.example.com/dc=example?user=john")
#=&gt; #&lt;URI::LDAP:0x00000000b9e7e8 URL:ldap://ldap.example.com/dc=example?user=john&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-split"> <span class="method-name">split</span><span class="method-args">(uri)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="split-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 120
def split(uri)
  case uri
  when ''
    # null uri

  when @regexp[:ABS_URI]
    scheme, opaque, userinfo, host, port,
      registry, path, query, fragment = $~[1..-1]

    # URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]

    # absoluteURI   = scheme ":" ( hier_part | opaque_part )
    # hier_part     = ( net_path | abs_path ) [ "?" query ]
    # opaque_part   = uric_no_slash *uric

    # abs_path      = "/"  path_segments
    # net_path      = "//" authority [ abs_path ]

    # authority     = server | reg_name
    # server        = [ [ userinfo "@" ] hostport ]

    if !scheme
      raise InvalidURIError,
        "bad URI(absolute but no scheme): #{uri}"
    end
    if !opaque &amp;&amp; (!path &amp;&amp; (!host &amp;&amp; !registry))
      raise InvalidURIError,
        "bad URI(absolute but no path): #{uri}"
    end

  when @regexp[:REL_URI]
    scheme = nil
    opaque = nil

    userinfo, host, port, registry,
      rel_segment, abs_path, query, fragment = $~[1..-1]
    if rel_segment &amp;&amp; abs_path
      path = rel_segment + abs_path
    elsif rel_segment
      path = rel_segment
    elsif abs_path
      path = abs_path
    end

    # URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]

    # relativeURI   = ( net_path | abs_path | rel_path ) [ "?" query ]

    # net_path      = "//" authority [ abs_path ]
    # abs_path      = "/"  path_segments
    # rel_path      = rel_segment [ abs_path ]

    # authority     = server | reg_name
    # server        = [ [ userinfo "@" ] hostport ]

  else
    raise InvalidURIError, "bad URI(is not URI?): #{uri}"
  end

  path = '' if !path &amp;&amp; !opaque # (see RFC2396 Section 5.2)
  ret = [
    scheme,
    userinfo, host, port,         # X
    registry,                     # X
    path,                         # Y
    opaque,                       # Y
    query,
    fragment
  ]
  return ret
end</pre> </div> <p>Returns a split <a href="../../uri/">URI</a> against <a href="#">regexp</a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-unescape"> <span class="method-callseq"> unescape( str ) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> unescape( str, unsafe ) </span> </div> <div class="method-description">
<div class="method-source-code" id="unescape-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 330
def unescape(str, escaped = @regexp[:ESCAPED])
  str.gsub(escaped) { [$&amp;[1, 2].hex].pack('C') }.force_encoding(str.encoding)
end</pre> </div> <h2 id="method-i-unescape-label-Args">Args</h2> <dl class="rdoc-list note-list">
<dt>
<code>str</code> </dt>
<dd> <p>String to remove escapes from</p> </dd>
<dt>
<code>unsafe</code> </dt>
<dd> <p><a href="../../regexp/">Regexp</a> to apply. Defaults to <a href="#">self.regexp</a></p> </dd>
</dl> <h2 id="method-i-unescape-label-Description">Description</h2> <p>Removes escapes from <code>str</code></p>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-convert_to_uri"> <span class="method-name">convert_to_uri</span><span class="method-args">(uri)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="convert_to_uri-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 531
def convert_to_uri(uri)
  if uri.is_a?(URI::Generic)
    uri
  elsif uri = String.try_convert(uri)
    parse(uri)
  else
    raise ArgumentError,
      "bad argument (expected URI object or URI string)"
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-initialize_pattern"> <span class="method-name">initialize_pattern</span><span class="method-args">(opts = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="initialize_pattern-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 342
def initialize_pattern(opts = {})
  ret = {}
  ret[:ESCAPED] = escaped = (opts.delete(:ESCAPED) || PATTERN::ESCAPED)
  ret[:UNRESERVED] = unreserved = opts.delete(:UNRESERVED) || PATTERN::UNRESERVED
  ret[:RESERVED] = reserved = opts.delete(:RESERVED) || PATTERN::RESERVED
  ret[:DOMLABEL] = opts.delete(:DOMLABEL) || PATTERN::DOMLABEL
  ret[:TOPLABEL] = opts.delete(:TOPLABEL) || PATTERN::TOPLABEL
  ret[:HOSTNAME] = hostname = opts.delete(:HOSTNAME)

  # RFC 2396 (URI Generic Syntax)
  # RFC 2732 (IPv6 Literal Addresses in URL's)
  # RFC 2373 (IPv6 Addressing Architecture)

  # uric          = reserved | unreserved | escaped
  ret[:URIC] = uric = "(?:[#{unreserved}#{reserved}]|#{escaped})"
  # uric_no_slash = unreserved | escaped | ";" | "?" | ":" | "@" |
  #                 "&amp;" | "=" | "+" | "$" | ","
  ret[:URIC_NO_SLASH] = uric_no_slash = "(?:[#{unreserved};?:@&amp;=+$,]|#{escaped})"
  # query         = *uric
  ret[:QUERY] = query = "#{uric}*"
  # fragment      = *uric
  ret[:FRAGMENT] = fragment = "#{uric}*"

  # hostname      = *( domainlabel "." ) toplabel [ "." ]
  # reg-name      = *( unreserved / pct-encoded / sub-delims ) # RFC3986
  unless hostname
    ret[:HOSTNAME] = hostname = "(?:[a-zA-Z0-9\\-.]|%\\h\\h)+"
  end

  # RFC 2373, APPENDIX B:
  # IPv6address = hexpart [ ":" IPv4address ]
  # IPv4address   = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT
  # hexpart = hexseq | hexseq "::" [ hexseq ] | "::" [ hexseq ]
  # hexseq  = hex4 *( ":" hex4)
  # hex4    = 1*4HEXDIG
  #
  # XXX: This definition has a flaw. "::" + IPv4address must be
  # allowed too.  Here is a replacement.
  #
  # IPv4address = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT
  ret[:IPV4ADDR] = ipv4addr = "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}"
  # hex4     = 1*4HEXDIG
  hex4 = "[#{PATTERN::HEX}]{1,4}"
  # lastpart = hex4 | IPv4address
  lastpart = "(?:#{hex4}|#{ipv4addr})"
  # hexseq1  = *( hex4 ":" ) hex4
  hexseq1 = "(?:#{hex4}:)*#{hex4}"
  # hexseq2  = *( hex4 ":" ) lastpart
  hexseq2 = "(?:#{hex4}:)*#{lastpart}"
  # IPv6address = hexseq2 | [ hexseq1 ] "::" [ hexseq2 ]
  ret[:IPV6ADDR] = ipv6addr = "(?:#{hexseq2}|(?:#{hexseq1})?::(?:#{hexseq2})?)"

  # IPv6prefix  = ( hexseq1 | [ hexseq1 ] "::" [ hexseq1 ] ) "/" 1*2DIGIT
  # unused

  # ipv6reference = "[" IPv6address "]" (RFC 2732)
  ret[:IPV6REF] = ipv6ref = "\\[#{ipv6addr}\\]"

  # host          = hostname | IPv4address
  # host          = hostname | IPv4address | IPv6reference (RFC 2732)
  ret[:HOST] = host = "(?:#{hostname}|#{ipv4addr}|#{ipv6ref})"
  # port          = *digit
  ret[:PORT] = port = '\d*'
  # hostport      = host [ ":" port ]
  ret[:HOSTPORT] = hostport = "#{host}(?::#{port})?"

  # userinfo      = *( unreserved | escaped |
  #                    ";" | ":" | "&amp;" | "=" | "+" | "$" | "," )
  ret[:USERINFO] = userinfo = "(?:[#{unreserved};:&amp;=+$,]|#{escaped})*"

  # pchar         = unreserved | escaped |
  #                 ":" | "@" | "&amp;" | "=" | "+" | "$" | ","
  pchar = "(?:[#{unreserved}:@&amp;=+$,]|#{escaped})"
  # param         = *pchar
  param = "#{pchar}*"
  # segment       = *pchar *( ";" param )
  segment = "#{pchar}*(?:;#{param})*"
  # path_segments = segment *( "/" segment )
  ret[:PATH_SEGMENTS] = path_segments = "#{segment}(?:/#{segment})*"

  # server        = [ [ userinfo "@" ] hostport ]
  server = "(?:#{userinfo}@)?#{hostport}"
  # reg_name      = 1*( unreserved | escaped | "$" | "," |
  #                     ";" | ":" | "@" | "&amp;" | "=" | "+" )
  ret[:REG_NAME] = reg_name = "(?:[#{unreserved}$,;:@&amp;=+]|#{escaped})+"
  # authority     = server | reg_name
  authority = "(?:#{server}|#{reg_name})"

  # rel_segment   = 1*( unreserved | escaped |
  #                     ";" | "@" | "&amp;" | "=" | "+" | "$" | "," )
  ret[:REL_SEGMENT] = rel_segment = "(?:[#{unreserved};@&amp;=+$,]|#{escaped})+"

  # scheme        = alpha *( alpha | digit | "+" | "-" | "." )
  ret[:SCHEME] = scheme = "[#{PATTERN::ALPHA}][\\-+.#{PATTERN::ALPHA}\\d]*"

  # abs_path      = "/"  path_segments
  ret[:ABS_PATH] = abs_path = "/#{path_segments}"
  # rel_path      = rel_segment [ abs_path ]
  ret[:REL_PATH] = rel_path = "#{rel_segment}(?:#{abs_path})?"
  # net_path      = "//" authority [ abs_path ]
  ret[:NET_PATH] = net_path = "//#{authority}(?:#{abs_path})?"

  # hier_part     = ( net_path | abs_path ) [ "?" query ]
  ret[:HIER_PART] = hier_part = "(?:#{net_path}|#{abs_path})(?:\\?(?:#{query}))?"
  # opaque_part   = uric_no_slash *uric
  ret[:OPAQUE_PART] = opaque_part = "#{uric_no_slash}#{uric}*"

  # absoluteURI   = scheme ":" ( hier_part | opaque_part )
  ret[:ABS_URI] = abs_uri = "#{scheme}:(?:#{hier_part}|#{opaque_part})"
  # relativeURI   = ( net_path | abs_path | rel_path ) [ "?" query ]
  ret[:REL_URI] = rel_uri = "(?:#{net_path}|#{abs_path}|#{rel_path})(?:\\?#{query})?"

  # URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]
  ret[:URI_REF] = "(?:#{abs_uri}|#{rel_uri})?(?:##{fragment})?"

  ret[:X_ABS_URI] = "
    (#{scheme}):                           (?# 1: scheme)
    (?:
       (#{opaque_part})                    (?# 2: opaque)
    |
       (?:(?:
         //(?:
             (?:(?:(#{userinfo})@)?        (?# 3: userinfo)
               (?:(#{host})(?::(\\d*))?))? (?# 4: host, 5: port)
           |
             (#{reg_name})                 (?# 6: registry)
           )
         |
         (?!//))                           (?# XXX: '//' is the mark for hostport)
         (#{abs_path})?                    (?# 7: path)
       )(?:\\?(#{query}))?                 (?# 8: query)
    )
    (?:\\#(#{fragment}))?                  (?# 9: fragment)
  "

  ret[:X_REL_URI] = "
    (?:
      (?:
        //
        (?:
          (?:(#{userinfo})@)?       (?# 1: userinfo)
            (#{host})?(?::(\\d*))?  (?# 2: host, 3: port)
        |
          (#{reg_name})             (?# 4: registry)
        )
      )
    |
      (#{rel_segment})              (?# 5: rel_segment)
    )?
    (#{abs_path})?                  (?# 6: abs_path)
    (?:\\?(#{query}))?              (?# 7: query)
    (?:\\#(#{fragment}))?           (?# 8: fragment)
  "

  ret
end</pre> </div> <p>Constructs the default <a href="../../hash/">Hash</a> of patterns</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-initialize_regexp"> <span class="method-name">initialize_regexp</span><span class="method-args">(pattern)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="initialize_regexp-source"> <pre class="ruby" data-language="ruby"># File lib/uri/rfc2396_parser.rb, line 500
def initialize_regexp(pattern)
  ret = {}

  # for URI::split
  ret[:ABS_URI] = Regexp.new('\A\s*' + pattern[:X_ABS_URI] + '\s*\z', Regexp::EXTENDED)
  ret[:REL_URI] = Regexp.new('\A\s*' + pattern[:X_REL_URI] + '\s*\z', Regexp::EXTENDED)

  # for URI::extract
  ret[:URI_REF]     = Regexp.new(pattern[:URI_REF])
  ret[:ABS_URI_REF] = Regexp.new(pattern[:X_ABS_URI], Regexp::EXTENDED)
  ret[:REL_URI_REF] = Regexp.new(pattern[:X_REL_URI], Regexp::EXTENDED)

  # for URI::escape/unescape
  ret[:ESCAPED] = Regexp.new(pattern[:ESCAPED])
  ret[:UNSAFE]  = Regexp.new("[^#{pattern[:UNRESERVED]}#{pattern[:RESERVED]}]")

  # for Generic#initialize
  ret[:SCHEME]   = Regexp.new("\\A#{pattern[:SCHEME]}\\z")
  ret[:USERINFO] = Regexp.new("\\A#{pattern[:USERINFO]}\\z")
  ret[:HOST]     = Regexp.new("\\A#{pattern[:HOST]}\\z")
  ret[:PORT]     = Regexp.new("\\A#{pattern[:PORT]}\\z")
  ret[:OPAQUE]   = Regexp.new("\\A#{pattern[:OPAQUE_PART]}\\z")
  ret[:REGISTRY] = Regexp.new("\\A#{pattern[:REG_NAME]}\\z")
  ret[:ABS_PATH] = Regexp.new("\\A#{pattern[:ABS_PATH]}\\z")
  ret[:REL_PATH] = Regexp.new("\\A#{pattern[:REL_PATH]}\\z")
  ret[:QUERY]    = Regexp.new("\\A#{pattern[:QUERY]}\\z")
  ret[:FRAGMENT] = Regexp.new("\\A#{pattern[:FRAGMENT]}\\z")

  ret
end</pre> </div> <p>Constructs the default <a href="../../hash/">Hash</a> of Regexp's</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
