
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Refinements - Ruby 2.5 - W3cubDocs</title>
  
  <meta name="description" content="Due to Ruby&#39;s open classes you can redefine or add functionality to existing classes. This is called a “monkey patch”. Unfortunately the scope &hellip;">
  <meta name="keywords" content="refinements, -, ruby, ruby~2.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/ruby~2.5/syntax/refinements_rdoc/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/ruby~2.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.5/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rdoc">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1 id="label-Refinements">Refinements</h1> <p>Due to Ruby's open classes you can redefine or add functionality to existing classes. This is called a “monkey patch”. Unfortunately the scope of such changes is global. All users of the monkey-patched class see the same changes. This can cause unintended side-effects or breakage of programs.</p> <p>Refinements are designed to reduce the impact of monkey patching on other users of the monkey-patched class. Refinements provide a way to extend a class locally.</p> <p>Here is a basic refinement:</p> <pre class="ruby" data-language="ruby">class C
  def foo
    puts "C#foo"
  end
end

module M
  refine C do
    def foo
      puts "C#foo in M"
    end
  end
end
</pre> <p>First, a class <code>C</code> is defined. Next a refinement for <code>C</code> is created using <a href="../../module/#method-i-refine">Module#refine</a>. Refinements only modify classes, not modules so the argument must be a class.</p> <p><a href="../../module/#method-i-refine">Module#refine</a> creates an anonymous module that contains the changes or refinements to the class (<code>C</code> in the example). <code>self</code> in the refine block is this anonymous module similar to <a href="../../module/#method-i-module_eval">Module#module_eval</a>.</p> <p>Activate the refinement with using:</p> <pre class="ruby" data-language="ruby">using M

c = C.new

c.foo # prints "C#foo in M"
</pre> <h2 id="label-Scope">Scope</h2> <p>You may activate refinements at top-level, and inside classes and modules. You may not activate refinements in method scope. Refinements are activated until the end of the current class or module definition, or until the end of the current file if used at the top-level.</p> <p>You may activate refinements in a string passed to <a href="../../kernel/#method-i-eval">Kernel#eval</a>. Refinements are active until the end of the eval string.</p> <p>Refinements are lexical in scope. Refinements are only active within a scope after the call to <code>using</code>. Any code before the <code>using</code> statement will not have the refinement activated.</p> <p>When control is transferred outside the scope, the refinement is deactivated. This means that if you require or load a file or call a method that is defined outside the current scope the refinement will be deactivated:</p> <pre class="ruby" data-language="ruby">class C
end

module M
  refine C do
    def foo
      puts "C#foo in M"
    end
  end
end

def call_foo(x)
  x.foo
end

using M

x = C.new
x.foo       # prints "C#foo in M"
call_foo(x) #=&gt; raises NoMethodError
</pre> <p>If a method is defined in a scope where a refinement is active, the refinement will be active when the method is called. This example spans multiple files:</p> <p>c.rb:</p> <pre class="ruby" data-language="ruby">class C
end
</pre> <p>m.rb:</p> <pre class="ruby" data-language="ruby">require "c"

module M
  refine C do
    def foo
      puts "C#foo in M"
    end
  end
end
</pre> <p>m_user.rb:</p> <pre class="ruby" data-language="ruby">require "m"

using M

class MUser
  def call_foo(x)
    x.foo
  end
end
</pre> <p>main.rb:</p> <pre class="ruby" data-language="ruby">require "m_user"

x = C.new
m_user = MUser.new
m_user.call_foo(x) # prints "C#foo in M"
x.foo              #=&gt; raises NoMethodError
</pre> <p>Since the refinement <code>M</code> is active in <code>m_user.rb</code> where <code>MUser#call_foo</code> is defined it is also active when <code>main.rb</code> calls <code>call_foo</code>.</p> <p>Since using is a method, refinements are only active when it is called. Here are examples of where a refinement <code>M</code> is and is not active.</p> <p>In a file:</p> <pre class="ruby" data-language="ruby"># not activated here
using M
# activated here
class Foo
  # activated here
  def foo
    # activated here
  end
  # activated here
end
# activated here
</pre> <p>In a class:</p> <pre class="ruby" data-language="ruby"># not activated here
class Foo
  # not activated here
  def foo
    # not activated here
  end
  using M
  # activated here
  def bar
    # activated here
  end
  # activated here
end
# not activated here
</pre> <p>Note that the refinements in <code>M</code> are <strong>not</strong> activated automatically if the class <code>Foo</code> is reopened later.</p> <p>In eval:</p> <pre class="ruby" data-language="ruby"># not activated here
eval &lt;&lt;EOF
  # not activated here
  using M
  # activated here
EOF
# not activated here
</pre> <p>When not evaluated:</p> <pre class="ruby" data-language="ruby"># not activated here
if false
  using M
end
# not activated here
</pre> <p>When defining multiple refinements in the same module inside multiple <code>refine</code> blocks, all refinements from the same module are active when a refined method (any of the <code>to_json</code> methods from the example below) is called:</p> <pre class="ruby" data-language="ruby">module ToJSON
  refine Integer do
    def to_json
      to_s
    end
  end

  refine Array do
    def to_json
      "[" + map { |i| i.to_json }.join(",") + "]"
    end
  end

  refine Hash do
    def to_json
      "{" + map { |k, v| k.to_s.dump + ":" + v.to_json }.join(",") + "}"
    end
  end
end

using ToJSON

p [{1=&gt;2}, {3=&gt;4}].to_json # prints "[{\"1\":2},{\"3\":4}]"
</pre> <h2 id="label-Method+Lookup">
<a href="../../method/">Method</a> Lookup</h2> <p>When looking up a method for an instance of class <code>C</code> Ruby checks:</p> <ul>
<li> <p>If refinements are active for <code>C</code>, in the reverse order they were activated:</p> <ul>
<li> <p>The prepended modules from the refinement for <code>C</code></p> </li>
<li> <p>The refinement for <code>C</code></p> </li>
<li> <p>The included modules from the refinement for <code>C</code></p> </li>
</ul> </li>
<li> <p>The prepended modules of <code>C</code></p> </li>
<li> <p><code>C</code></p> </li>
<li> <p>The included modules of <code>C</code></p> </li>
</ul> <p>If no method was found at any point this repeats with the superclass of <code>C</code>.</p> <p>Note that methods in a subclass have priority over refinements in a superclass. For example, if the method <code>/</code> is defined in a refinement for <a href="../../numeric/">Numeric</a> <code>1 / 2</code> invokes the original Integer#/ because <a href="../../integer/">Integer</a> is a subclass of <a href="../../numeric/">Numeric</a> and is searched before the refinements for the superclass <a href="../../numeric/">Numeric</a>. Since the method <code>/</code> is also present in child <code>Integer</code>, the method lookup does not move up to the superclass.</p> <p>However, if a method <code>foo</code> is defined on <a href="../../numeric/">Numeric</a> in a refinement, <code>1.foo</code> invokes that method since <code>foo</code> does not exist on <a href="../../integer/">Integer</a>.</p> <h2 id="label-super"><code>super</code></h2> <p>When <code>super</code> is invoked method lookup checks:</p> <ul>
<li> <p>The included modules of the current class. Note that the current class may be a refinement.</p> </li>
<li> <p>If the current class is a refinement, the method lookup proceeds as in the <a href="../../method/">Method</a> Lookup section above.</p> </li>
<li> <p>If the current class has a direct superclass, the method proceeds as in the <a href="../../method/">Method</a> Lookup section above using the superclass.</p> </li>
</ul> <p>Note that <code>super</code> in a method of a refinement invokes the method in the refined class even if there is another refinement which has been activated in the same context.</p> <h2 id="label-Indirect+Method+Calls">Indirect <a href="../../method/">Method</a> Calls</h2> <p>When using indirect method access such as Kernel#send, Kernel#method or Kernel#respond_to? refinements are not honored for the caller context during method lookup.</p> <p>This behavior may be changed in the future.</p> <h2 id="label-Refinement+inheritance+by+Module-23include">Refinement inheritance by <a href="../../module/#method-i-include">Module#include</a>
</h2> <p>When a module X is included into a module Y, Y inherits refinements from X.</p> <p>For exmaple, C inherits refinements from A and B in the following code:</p> <pre>module A
  refine X do ... end
  refine Y do ... end
end
module B
  refine Z do ... end
end
module C
  include A
  include B
end

using C
# Refinements in A and B are activated here.</pre> <p>Refinements in descendants have higher precedence than those of ancestors.</p> <h2 id="label-Further+Reading">Further Reading</h2> <p>See <a href="https://bugs.ruby-lang.org/projects/ruby-trunk/wiki/RefinementsSpec" target="_blank">bugs.ruby-lang.org/projects/ruby-trunk/wiki/RefinementsSpec</a> for the current specification for implementing refinements. The specification also contains more details.</p>
<div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
