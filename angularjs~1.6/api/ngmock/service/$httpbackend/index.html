
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>ngMock.&#36;httpBackend - Angular.js 1.6 - W3cubDocs</title>
  
  <meta name="description" content=" Fake HTTP backend implementation suitable for unit testing applications that use the &#36;http service. ">
  <meta name="keywords" content="&#36;httpbackend, ngmock, -, angular, js, angularjs~1.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/angularjs~1.6/api/ngmock/service/$httpbackend/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/angularjs~1.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angularjs~1.6/" class="_nav-link" title="" style="margin-left:0;">Angular.js 1.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _angularjs">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1 class="api-profile-header-heading">
<a href="https://github.com/angular/angular.js/edit/v1.6.x/src/ngMock/angular-mocks.js?message=docs(%24httpBackend)%3A%20describe%20your%20change...#L1025" class="improve-docs btn btn-primary" target="_blank">Improve this Doc</a><a href="https://github.com/angular/angular.js/tree/v1.6.6/src/ngMock/angular-mocks.js#L1025" class="view-source pull-right btn btn-primary" target="_blank"> View Source </a>$httpBackend</h1> <ol class="api-profile-header-structure naked-list step-list"> <li> service in module <a href="../../../ngmock/">ngMock</a> </li> </ol>  <div class="api-profile-description"> <p>Fake HTTP backend implementation suitable for unit testing applications that use the <a href="../../../ng/service/%24http/">$http service</a>.</p> <div class="alert alert-info"> <strong>Note</strong>: For fake HTTP backend implementation suitable for end-to-end testing or backend-less development please see <a href="../../../ngmocke2e/service/%24httpbackend/">e2e $httpBackend mock</a>. </div> <p>During unit testing, we want our unit tests to run quickly and have no external dependencies so we don’t want to send <a href="https://developer.mozilla.org/en/xmlhttprequest" target="_blank">XHR</a> or <a href="http://en.wikipedia.org/wiki/JSONP" target="_blank">JSONP</a> requests to a real server. All we really need is to verify whether a certain request has been sent or not, or alternatively just let the application make requests, respond with pre-trained responses and assert that the end result is what we expect it to be.</p> <p>This mock implementation can be used to respond with static or dynamic responses via the <code>expect</code> and <code>when</code> apis and their shortcuts (<code>expectGET</code>, <code>whenPOST</code>, etc).</p> <p>When an Angular application needs some data from a server, it calls the $http service, which sends the request to a real server using $httpBackend service. With dependency injection, it is easy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify the requests and respond with some testing data without sending a request to a real server.</p> <p>There are two ways to specify what test data should be returned as http responses by the mock backend when the code under test makes http requests:</p> <ul> <li>
<code>$httpBackend.expect</code> - specifies a request expectation</li> <li>
<code>$httpBackend.when</code> - specifies a backend definition</li> </ul> <h2 id="request-expectations-vs-backend-definitions">Request Expectations vs Backend Definitions</h2> <p>Request expectations provide a way to make assertions about requests made by the application and to define responses for those requests. The test will fail if the expected requests are not made or they are made in the wrong order.</p> <p>Backend definitions allow you to define a fake backend for your application which doesn't assert if a particular request was made or not, it just returns a trained response if a request is made. The test will pass whether or not the request gets made during testing.</p> <table class="table"> <tr>
<th width="220px"></th>
<th>Request expectations</th>
<th>Backend definitions</th>
</tr> <tr> <th>Syntax</th> <td>.expect(...).respond(...)</td> <td>.when(...).respond(...)</td> </tr> <tr> <th>Typical usage</th> <td>strict unit tests</td> <td>loose (black-box) unit testing</td> </tr> <tr> <th>Fulfills multiple requests</th> <td>NO</td> <td>YES</td> </tr> <tr> <th>Order of requests matters</th> <td>YES</td> <td>NO</td> </tr> <tr> <th>Request required</th> <td>YES</td> <td>NO</td> </tr> <tr> <th>Response required</th> <td>optional (see below)</td> <td>YES</td> </tr> </table> <p>In cases where both backend definitions and request expectations are specified during unit testing, the request expectations are evaluated first.</p> <p>If a request expectation has no response specified, the algorithm will search your backend definitions for an appropriate response.</p> <p>If a request didn't match any expectation or if the expectation doesn't have the response defined, the backend definitions are evaluated in sequential order to see if any of them match the request. The response from the first matched definition is returned.</p> <h2 id="flushing-http-requests">Flushing HTTP requests</h2> <p>The $httpBackend used in production always responds to requests asynchronously. If we preserved this behavior in unit testing, we'd have to create async unit tests, which are hard to write, to follow and to maintain. But neither can the testing mock respond synchronously; that would change the execution of the code under test. For this reason, the mock $httpBackend has a <code>flush()</code> method, which allows the test to explicitly flush pending requests. This preserves the async api of the backend, while allowing the test to execute synchronously.</p> <h2 id="unit-testing-with-mock-httpbackend">Unit testing with mock $httpBackend</h2> <p>The following code shows how to setup and use the mock backend when unit testing a controller. First we create the controller under test:</p> <pre data-language="javascript">// The module code
angular
  .module('MyApp', [])
  .controller('MyController', MyController);

// The controller code
function MyController($scope, $http) {
  var authToken;

  $http.get('/auth.py').then(function(response) {
    authToken = response.headers('A-Token');
    $scope.user = response.data;
  }).catch(function() {
    $scope.status = 'Failed...';
  });

  $scope.saveMessage = function(message) {
    var headers = { 'Authorization': authToken };
    $scope.status = 'Saving...';

    $http.post('/add-msg.py', message, { headers: headers } ).then(function(response) {
      $scope.status = '';
    }).catch(function() {
      $scope.status = 'Failed...';
    });
  };
}
</pre> <p>Now we setup the mock backend and create the test specs:</p> <pre data-language="javascript">// testing controller
describe('MyController', function() {
   var $httpBackend, $rootScope, createController, authRequestHandler;

   // Set up the module
   beforeEach(module('MyApp'));

   beforeEach(inject(function($injector) {
     // Set up the mock http service responses
     $httpBackend = $injector.get('$httpBackend');
     // backend definition common for all tests
     authRequestHandler = $httpBackend.when('GET', '/auth.py')
                            .respond({userId: 'userX'}, {'A-Token': 'xxx'});

     // Get hold of a scope (i.e. the root scope)
     $rootScope = $injector.get('$rootScope');
     // The $controller service is used to create instances of controllers
     var $controller = $injector.get('$controller');

     createController = function() {
       return $controller('MyController', {'$scope' : $rootScope });
     };
   }));


   afterEach(function() {
     $httpBackend.verifyNoOutstandingExpectation();
     $httpBackend.verifyNoOutstandingRequest();
   });


   it('should fetch authentication token', function() {
     $httpBackend.expectGET('/auth.py');
     var controller = createController();
     $httpBackend.flush();
   });


   it('should fail authentication', function() {

     // Notice how you can change the response even after it was set
     authRequestHandler.respond(401, '');

     $httpBackend.expectGET('/auth.py');
     var controller = createController();
     $httpBackend.flush();
     expect($rootScope.status).toBe('Failed...');
   });


   it('should send msg to server', function() {
     var controller = createController();
     $httpBackend.flush();

     // now you don’t care about the authentication, but
     // the controller will still send the request and
     // $httpBackend will respond without you having to
     // specify the expectation and response for this request

     $httpBackend.expectPOST('/add-msg.py', 'message content').respond(201, '');
     $rootScope.saveMessage('message content');
     expect($rootScope.status).toBe('Saving...');
     $httpBackend.flush();
     expect($rootScope.status).toBe('');
   });


   it('should send auth header', function() {
     var controller = createController();
     $httpBackend.flush();

     $httpBackend.expectPOST('/add-msg.py', undefined, function(headers) {
       // check if the header was sent, if it wasn't the expectation won't
       // match the request and the test will fail
       return headers['Authorization'] === 'xxx';
     }).respond(201, '');

     $rootScope.saveMessage('whatever');
     $httpBackend.flush();
   });
});
</pre> <h2 id="dynamic-responses">Dynamic responses</h2> <p>You define a response to a request by chaining a call to <code>respond()</code> onto a definition or expectation. If you provide a <strong>callback</strong> as the first parameter to <code>respond(callback)</code> then you can dynamically generate a response based on the properties of the request.</p> <p>The <code>callback</code> function should be of the form <code>function(method, url, data, headers, params)</code>.</p> <h3 id="query-parameters">Query parameters</h3> <p>By default, query parameters on request URLs are parsed into the <code>params</code> object. So a request URL of <code>/list?q=searchstr&amp;orderby=-name</code> would set <code>params</code> to be <code>{q: 'searchstr', orderby: '-name'}</code>.</p> <h3 id="regex-parameter-matching">Regex parameter matching</h3> <p>If an expectation or definition uses a <strong>regex</strong> to match the URL, you can provide an array of <strong>keys</strong> via a <code>params</code> argument. The index of each <strong>key</strong> in the array will match the index of a <strong>group</strong> in the <strong>regex</strong>.</p> <p>The <code>params</code> object in the <strong>callback</strong> will now have properties with these keys, which hold the value of the corresponding <strong>group</strong> in the <strong>regex</strong>.</p> <p>This also applies to the <code>when</code> and <code>expect</code> shortcut methods.</p> <pre data-language="javascript">$httpBackend.expect('GET', /\/user\/(.+)/, undefined, undefined, ['id'])
  .respond(function(method, url, data, headers, params) {
    // for requested url of '/user/1234' params is {id: '1234'}
  });

$httpBackend.whenPATCH(/\/user\/(.+)\/article\/(.+)/, undefined, undefined, ['user', 'article'])
  .respond(function(method, url, data, headers, params) {
    // for url of '/user/1234/article/567' params is {user: '1234', article: '567'}
  });
</pre> <h2 id="matching-route-requests">Matching route requests</h2> <p>For extra convenience, <code>whenRoute</code> and <code>expectRoute</code> shortcuts are available. These methods offer colon delimited matching of the url path, ignoring the query string. This allows declarations similar to how application routes are configured with <code>$routeProvider</code>. Because these methods convert the definition url to regex, declaration order is important. Combined with query parameter parsing, the following is possible:</p> <pre data-language="javascript">$httpBackend.whenRoute('GET', '/users/:id')
  .respond(function(method, url, data, headers, params) {
    return [200, MockUserList[Number(params.id)]];
  });

$httpBackend.whenRoute('GET', '/users')
  .respond(function(method, url, data, headers, params) {
    var userList = angular.copy(MockUserList),
      defaultSort = 'lastName',
      count, pages, isPrevious, isNext;

    // paged api response '/v1/users?page=2'
    params.page = Number(params.page) || 1;

    // query for last names '/v1/users?q=Archer'
    if (params.q) {
      userList = $filter('filter')({lastName: params.q});
    }

    pages = Math.ceil(userList.length / pagingLength);
    isPrevious = params.page &gt; 1;
    isNext = params.page &lt; pages;

    return [200, {
      count:    userList.length,
      previous: isPrevious,
      next:     isNext,
      // sort field -&gt; '/v1/users?sortBy=firstName'
      results:  $filter('orderBy')(userList, params.sortBy || defaultSort)
                  .splice((params.page - 1) * pagingLength, pagingLength)
    }];
  });
</pre> </div> <div> <h2>Methods</h2> <ul class="methods defs"> <li id="when"> <h3>when(method, url, [data], [headers], [keys]);</h3> <div>
<p>Creates a new backend definition.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> method </td> <td> <code class="label type-hint type-hint-string">string</code> </td> <td> <p>HTTP method.</p> </td> </tr> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> data <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)</code> </td> <td> <p>HTTP request body or function that receives data string and returns true if the data is as expected.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code><code class="label type-hint type-hint-function">function(Object)</code> </td> <td> <p>HTTP headers or function that receives http header object and returns true if the headers match the current definition.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> <ul> <li>respond –<pre data-language="javascript">{function([status,] data[, headers, statusText])
| function(function(method, url, data, headers, params)}
</pre> – The respond method takes a set of static data to be returned or a function that can return an array containing response status (number), response data (Array|Object|string), response headers (Object), and the text for the status (string). The respond method returns the <code>requestHandler</code> object for possible overrides.</li> </ul> </td> </tr> </table> </li> <li id="whenGET"> <h3>whenGET(url, [headers], [keys]);</h3> <div>
<p>Creates a new backend definition for GET requests. For more info see <code>when()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code><code class="label type-hint type-hint-function">function(Object)</code> </td> <td> <p>HTTP headers.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="whenHEAD"> <h3>whenHEAD(url, [headers], [keys]);</h3> <div>
<p>Creates a new backend definition for HEAD requests. For more info see <code>when()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code><code class="label type-hint type-hint-function">function(Object)</code> </td> <td> <p>HTTP headers.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="whenDELETE"> <h3>whenDELETE(url, [headers], [keys]);</h3> <div>
<p>Creates a new backend definition for DELETE requests. For more info see <code>when()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code><code class="label type-hint type-hint-function">function(Object)</code> </td> <td> <p>HTTP headers.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="whenPOST"> <h3>whenPOST(url, [data], [headers], [keys]);</h3> <div>
<p>Creates a new backend definition for POST requests. For more info see <code>when()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> data <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)</code> </td> <td> <p>HTTP request body or function that receives data string and returns true if the data is as expected.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code><code class="label type-hint type-hint-function">function(Object)</code> </td> <td> <p>HTTP headers.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="whenPUT"> <h3>whenPUT(url, [data], [headers], [keys]);</h3> <div>
<p>Creates a new backend definition for PUT requests. For more info see <code>when()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> data <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)</code> </td> <td> <p>HTTP request body or function that receives data string and returns true if the data is as expected.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code><code class="label type-hint type-hint-function">function(Object)</code> </td> <td> <p>HTTP headers.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="whenJSONP"> <h3>whenJSONP(url, [keys]);</h3> <div>
<p>Creates a new backend definition for JSONP requests. For more info see <code>when()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="whenRoute"> <h3>whenRoute(method, url);</h3> <div>
<p>Creates a new backend definition that compares only with the requested route.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> method </td> <td> <code class="label type-hint type-hint-string">string</code> </td> <td> <p>HTTP method.</p> </td> </tr> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code> </td> <td> <p>HTTP url string that supports colon param matching.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled. See #when for more info.</p> </td> </tr> </table> </li> <li id="expect"> <h3>expect(method, url, [data], [headers], [keys]);</h3> <div>
<p>Creates a new request expectation.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> method </td> <td> <code class="label type-hint type-hint-string">string</code> </td> <td> <p>HTTP method.</p> </td> </tr> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> data <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)</code><code class="label type-hint type-hint-object">Object</code> </td> <td> <p>HTTP request body or function that receives data string and returns true if the data is as expected, or Object if request body is in JSON format.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code><code class="label type-hint type-hint-function">function(Object)</code> </td> <td> <p>HTTP headers or function that receives http header object and returns true if the headers match the current expectation.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> <ul> <li>respond –<pre>{ function([status,] data[, headers, statusText])
| function(function(method, url, data, headers, params)}
</pre> – The respond method takes a set of static data to be returned or a function that can return an array containing response status (number), response data (Array|Object|string), response headers (Object), and the text for the status (string). The respond method returns the <code>requestHandler</code> object for possible overrides.</li> </ul> </td> </tr> </table> </li> <li id="expectGET"> <h3>expectGET(url, [headers], [keys]);</h3> <div>
<p>Creates a new request expectation for GET requests. For more info see <code>expect()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code> </td> <td> <p>HTTP headers.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled. See #expect for more info.</p> </td> </tr> </table> </li> <li id="expectHEAD"> <h3>expectHEAD(url, [headers], [keys]);</h3> <div>
<p>Creates a new request expectation for HEAD requests. For more info see <code>expect()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code> </td> <td> <p>HTTP headers.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="expectDELETE"> <h3>expectDELETE(url, [headers], [keys]);</h3> <div>
<p>Creates a new request expectation for DELETE requests. For more info see <code>expect()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code> </td> <td> <p>HTTP headers.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="expectPOST"> <h3>expectPOST(url, [data], [headers], [keys]);</h3> <div>
<p>Creates a new request expectation for POST requests. For more info see <code>expect()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> data <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)</code><code class="label type-hint type-hint-object">Object</code> </td> <td> <p>HTTP request body or function that receives data string and returns true if the data is as expected, or Object if request body is in JSON format.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code> </td> <td> <p>HTTP headers.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="expectPUT"> <h3>expectPUT(url, [data], [headers], [keys]);</h3> <div>
<p>Creates a new request expectation for PUT requests. For more info see <code>expect()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> data <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)</code><code class="label type-hint type-hint-object">Object</code> </td> <td> <p>HTTP request body or function that receives data string and returns true if the data is as expected, or Object if request body is in JSON format.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code> </td> <td> <p>HTTP headers.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="expectPATCH"> <h3>expectPATCH(url, [data], [headers], [keys]);</h3> <div>
<p>Creates a new request expectation for PATCH requests. For more info see <code>expect()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives a url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> data <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)</code><code class="label type-hint type-hint-object">Object</code> </td> <td> <p>HTTP request body or function that receives data string and returns true if the data is as expected, or Object if request body is in JSON format.</p> </td> </tr> <tr> <td> headers <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-object">Object</code> </td> <td> <p>HTTP headers.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="expectJSONP"> <h3>expectJSONP(url, [keys]);</h3> <div>
<p>Creates a new request expectation for JSONP requests. For more info see <code>expect()</code>.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code><code class="label type-hint type-hint-regexp">RegExp</code><code class="label type-hint type-hint-function">function(string)=</code> </td> <td> <p>HTTP url or function that receives an url and returns true if the url matches the current definition.</p> </td> </tr> <tr> <td> keys <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-array">Array</code> </td> <td> <p>Array of keys to assign to regex matches in request url described above.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled.</p> </td> </tr> </table> </li> <li id="expectRoute"> <h3>expectRoute(method, url);</h3> <div>
<p>Creates a new request expectation that compares only with the requested route.</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> method </td> <td> <code class="label type-hint type-hint-string">string</code> </td> <td> <p>HTTP method.</p> </td> </tr> <tr> <td> url </td> <td> <code class="label type-hint type-hint-string">string</code> </td> <td> <p>HTTP url string that supports colon param matching.</p> </td> </tr> </tbody> </table> <h4>Returns</h4> <table class="variables-matrix return-arguments"> <tr> <td><code class="label type-hint type-hint-requesthandler">requestHandler</code></td> <td>
<p>Returns an object with <code>respond</code> method that controls how a matched request is handled. You can save this object for later use and invoke <code>respond</code> again in order to change how a matched request is handled. See #expect for more info.</p> </td> </tr> </table> </li> <li id="flush"> <h3>flush([count], [skip]);</h3> <div>
<p>Flushes pending requests using the trained responses. Requests are flushed in the order they were made, but it is also possible to skip one or more requests (for example to have them flushed later). This is useful for simulating scenarios where responses arrive from the server in any order.</p> <p>If there are no pending requests to flush when the method is called, an exception is thrown (as this is typically a sign of programming error).</p> </div> <h4>Parameters</h4> <table class="variables-matrix input-arguments"> <thead> <tr> <th>Param</th> <th>Type</th> <th>Details</th> </tr> </thead> <tbody> <tr> <td> count <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-number">number</code> </td> <td> <p>Number of responses to flush. If undefined/null, all pending requests (starting after <code>skip</code>) will be flushed.</p> </td> </tr> <tr> <td> skip <div><em>(optional)</em></div> </td> <td> <code class="label type-hint type-hint-number">number</code> </td> <td> <p>Number of pending requests to skip. For example, a value of <code>5</code> would skip the first 5 pending requests and start flushing from the 6th onwards.</p> <p><em>(default: 0)</em></p> </td> </tr> </tbody> </table> </li> <li id="verifyNoOutstandingExpectation"> <h3>verifyNoOutstandingExpectation();</h3> <div>
<p>Verifies that all of the requests defined via the <code>expect</code> api were made. If any of the requests were not made, verifyNoOutstandingExpectation throws an exception.</p> <p>Typically, you would call this method following each test case that asserts requests using an "afterEach" clause.</p> <pre data-language="javascript">afterEach($httpBackend.verifyNoOutstandingExpectation);
</pre> </div> </li> <li id="verifyNoOutstandingRequest"> <h3>verifyNoOutstandingRequest();</h3> <div>
<p>Verifies that there are no outstanding requests that need to be flushed.</p> <p>Typically, you would call this method following each test case that asserts requests using an "afterEach" clause.</p> <pre data-language="javascript">afterEach($httpBackend.verifyNoOutstandingRequest);
</pre> </div> </li> <li id="resetExpectations"> <h3>resetExpectations();</h3> <div>
<p>Resets all request expectations, but preserves all backend definitions. Typically, you would call resetExpectations during a multiple-phase test when you want to reuse the same instance of $httpBackend mock.</p> </div> </li> </ul> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://code.angularjs.org/1.6.6/docs/api/ngMock/service/%24httpBackend" class="_attribution-link" target="_blank">https://code.angularjs.org/1.6.6/docs/api/ngMock/service/$httpBackend</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
