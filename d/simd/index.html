
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>39. Vector Extensions - D - W3cubDocs</title>
  
  <meta name="description" content="Modern CPUs often support specialized vector types and vector operations, sometimes called &#34;media instructions&#34;. Vector types are a fixed &hellip;">
  <meta name="keywords" content="vector, extensions, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/simd/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1>Vector Extensions</h1>       <b>Contents</b>  <ol> <li>
<a href="#core_simd"><code>core.simd</code></a><ol> <li><a href="#properties">Properties</a></li> <li><a href="#conversions">Conversions</a></li> <li><a href="#accessing_inidivual_elems">Accessing Individual Vector Elements</a></li> <li><a href="#conditional_compilation">Conditional Compilation</a></li> </ol>
</li> <li>
<a href="#x86_64_vec">X86 And X86_64 Vector Extension Implementation</a><ol> <li><a href="#vector_op_intrinsics">Vector Operation Intrinsics</a></li> </ol>
</li> </ol>   <p>Modern CPUs often support specialized vector types and vector operations, sometimes called "media instructions". Vector types are a fixed array of floating or integer types, and vector operations operate simultaneously on them, thus achieving great speed-ups.</p>  <p>When the compiler takes advantage of these instructions with standard D code to speed up loops over arithmetic data, this is called auto-vectorization. Auto-vectorization, however, has had only limited success and has not been able to really take advantage of the richness (and often quirkiness) of the native vector instructions. </p>  <p>D has the array operation notation, such as: </p>  <pre data-language="d">int[] a,b;
...
a[] += b[];
</pre>  <p>which can be vectorized by the compiler, but again success is limited for the same reason auto-vectorization is. </p>  <p>The difficulties with trying to use vector instructions on regular arrays are:</p>  <ol> <li>The vector types have stringent alignment requirements that are not and cannot be met by conventional arrays.</li> <li>C ABI's often have vector extensions and have special name mangling for them, call/return conventions, and symbolic debug support.</li> <li>The only way to get at the full vector instruction set would be to use inline assembler - but the compiler cannot do register allocation across inline assembler blocks (or other optimizations), leading to poor code performance.</li> <li>Interleaving conventional array code with vector operations on the same data can unwittingly lead to extremely poor runtime performance.</li> </ol>  <p>These issues are cleared up by using special vector types. </p>  <h2 id="core_simd"><code>core.simd</code></h2>  <p>Vector types and operations are introduced to D code by importing <a href="https://dlang.org/phobos/core_simd.html" target="_blank"><code>core.simd</code></a>:</p>  <pre data-language="d">import core.simd;
</pre>  <p>These types and operations will be the ones defined for the architecture the compiler is targeting. If a particular CPU family has varying support for vector types, an additional runtime check may be necessary. The compiler does not emit runtime checks; those must be done by the programmer. </p>  <p>Depending on the architecture, compiler flags may be required to activate support for SIMD types. </p>  <p>The types defined will all follow the naming convention:</p>  <pre>typeNN
</pre> where <i>type</i> is the vector element type and <i>NN</i> is the number of those elements in the vector type. The type names will not be keywords.  <h3 id="properties">Properties</h3>  <p>Vector types have the property:</p>  <table>
<caption>Vector Type Properties</caption> <tr>
<th class="donthyphenate"><b>Property</b></th>
<th class="donthyphenate"><b>Description</b></th>
</tr> <tr>
<td>.array</td>
<td>Returns static array representation</td>
</tr> </table>  <p>All the properties of the static array representation also work.</p>  <h3 id="conversions">Conversions</h3>  <p>Vector types of the same size can be implicitly converted among each other. Vector types can be cast to the static array representation.</p>  <p>Integers and floating point values can be implicitly converted to their vector equivalents:</p>  <pre data-language="d">int4 v = 7;
v = 3 + v;   // add 3 to each element in v
</pre>  <h3 id="accessing_inidivual_elems">Accessing Individual Vector Elements</h3>  <p>They cannot be accessed directly, but can be when converted to an array type:</p>  <pre data-language="d">int4 v;
(cast(int*)&amp;v)[3] = 2;   // set 3rd element of the 4 int vector
(cast(int[4])v)[3] = 2;  // set 3rd element of the 4 int vector
v.array[3] = 2;          // set 3rd element of the 4 int vector
v.ptr[3] = 2;            // set 3rd element of the 4 int vector
</pre>   <h3 id="conditional_compilation">Conditional Compilation</h3>  <p>If vector extensions are implemented, the <a href="../version/#PredefinedVersions">version identifier</a> <code>D_SIMD</code> is set.</p>  <p>Whether a type exists or not can be tested at compile time with an <a href="../expression/#IsExpression"><i>IsExpression</i></a>: </p>  <pre data-language="d">static if (is(typeNN))
    ... yes, it is supported ...
else
    ... nope, use workaround ...
</pre>  <p>Whether a particular operation on a type is supported can be tested at compile time with: </p>  <pre data-language="d">float4 a,b;
static if (__traits(compiles, a+b))
    ... yes, it is supported ...
else
    ... nope, use workaround ...
</pre>  <p>For runtime testing to see if certain vector instructions are available, see the functions in <a href="https://dlang.org/phobos/core_cpuid.html" target="_blank">core.cpuid</a>. </p>  <p>A typical workaround would be to use array vector operations instead:</p>  <pre data-language="d">float4 a,b;
static if (__traits(compiles, a/b))
    c = a / b;
else
    c[] = a[] / b[];
</pre>  <h2 id="x86_64_vec">X86 And X86_64 Vector Extension Implementation</h2>  <p>The rest of this document describes the specific implementation of the vector types for the X86 and X86_64 architectures. </p>  <p>The vector extensions are currently implemented for the OS X 32 bit target, and all 64 bit targets.</p>  <p><a href="https://dlang.org/phobos/core_simd.html" target="_blank"><code>core.simd</code></a> defines the following types: </p>  <table>
<caption>Vector Types</caption> <tr>
<th class="donthyphenate"><b>Type Name</b></th>
<th class="donthyphenate"><b>Description</b></th>
<th class="donthyphenate"><b>gcc Equivalent</b></th>
</tr> <tr>
<td>void16</td>
<td>16 bytes of untyped data</td>
<td><i>no equivalent</i></td>
</tr> <tr>
<td>byte16</td>
<td>16 <code>byte</code>'s</td>
<td><code>signed char __attribute__((vector_size(16)))</code></td>
</tr> <tr>
<td>ubyte16</td>
<td>16 <code>ubyte</code>'s</td>
<td><code>unsigned char __attribute__((vector_size(16)))</code></td>
</tr> <tr>
<td>short8</td>
<td>8 <code>short</code>'s</td>
<td><code>short __attribute__((vector_size(16)))</code></td>
</tr> <tr>
<td>ushort8</td>
<td>8 <code>ushort</code>'s</td>
<td><code>ushort __attribute__((vector_size(16)))</code></td>
</tr> <tr>
<td>int4</td>
<td>4 <code>int</code>'s</td>
<td><code>int __attribute__((vector_size(16)))</code></td>
</tr> <tr>
<td>uint4</td>
<td>4 <code>uint</code>'s</td>
<td><code>unsigned __attribute__((vector_size(16)))</code></td>
</tr> <tr>
<td>long2</td>
<td>2 <code>long</code>'s</td>
<td><code>long __attribute__((vector_size(16)))</code></td>
</tr> <tr>
<td>ulong2</td>
<td>2 <code>ulong</code>'s</td>
<td><code>unsigned long __attribute__((vector_size(16)))</code></td>
</tr> <tr>
<td>float4</td>
<td>4 <code>float</code>'s</td>
<td><code>float __attribute__((vector_size(16)))</code></td>
</tr> <tr>
<td>double2</td>
<td>2 <code>double</code>'s</td>
<td><code>double __attribute__((vector_size(16)))</code></td>
</tr> <tr>
<td>void32</td>
<td>32 bytes of untyped data</td>
<td><i>no equivalent</i></td>
</tr> <tr>
<td>byte32</td>
<td>32 <code>byte</code>'s</td>
<td><code>signed char __attribute__((vector_size(32)))</code></td>
</tr> <tr>
<td>ubyte32</td>
<td>32 <code>ubyte</code>'s</td>
<td><code>unsigned char __attribute__((vector_size(32)))</code></td>
</tr> <tr>
<td>short16</td>
<td>16 <code>short</code>'s</td>
<td><code>short __attribute__((vector_size(32)))</code></td>
</tr> <tr>
<td>ushort16</td>
<td>16 <code>ushort</code>'s</td>
<td><code>ushort __attribute__((vector_size(32)))</code></td>
</tr> <tr>
<td>int8</td>
<td>8 <code>int</code>'s</td>
<td><code>int __attribute__((vector_size(32)))</code></td>
</tr> <tr>
<td>uint8</td>
<td>8 <code>uint</code>'s</td>
<td><code>unsigned __attribute__((vector_size(32)))</code></td>
</tr> <tr>
<td>long4</td>
<td>4 <code>long</code>'s</td>
<td><code>long __attribute__((vector_size(32)))</code></td>
</tr> <tr>
<td>ulong4</td>
<td>4 <code>ulong</code>'s</td>
<td><code>unsigned long __attribute__((vector_size(32)))</code></td>
</tr> <tr>
<td>float8</td>
<td>8 <code>float</code>'s</td>
<td><code>float __attribute__((vector_size(32)))</code></td>
</tr> <tr>
<td>double4</td>
<td>4 <code>double</code>'s</td>
<td><code>double __attribute__((vector_size(32)))</code></td>
</tr> </table>  <p>Note: for 32 bit gcc, it's <code>long long</code> instead of <code>long</code>.</p>  <table>
<caption>Supported 128-bit Vector Operators</caption> <tr>
<th class="donthyphenate"><b>Operator</b></th>
<th class="donthyphenate"><b>void16</b></th>
<th class="donthyphenate"><b>byte16</b></th>
<th class="donthyphenate"><b>ubyte16</b></th>
<th class="donthyphenate"><b>short8</b></th>
<th class="donthyphenate"><b>ushort8</b></th>
<th class="donthyphenate"><b>int4</b></th>
<th class="donthyphenate"><b>uint4</b></th>
<th class="donthyphenate"><b>long2</b></th>
<th class="donthyphenate"><b>ulong2</b></th>
<th class="donthyphenate"><b>float4</b></th>
<th class="donthyphenate"><b>double2</b></th>
</tr> <tr>
<td>=</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>+</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>-</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>*</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>/</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td><code>&amp;</code></td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td>|</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td><code>^</code></td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td>+=</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>-=</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>*=</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>/=</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>
<code>&amp;</code>=</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td>|=</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td><code>^=</code></td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td>
<i>unary</i><code>~</code>
</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td>
<i>unary</i>+</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>
<i>unary</i>-</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> </table>  <table>
<caption>Supported 256-bit Vector Operators</caption> <tr>
<th class="donthyphenate"><b>Operator</b></th>
<th class="donthyphenate"><b>void32</b></th>
<th class="donthyphenate"><b>byte32</b></th>
<th class="donthyphenate"><b>ubyte32</b></th>
<th class="donthyphenate"><b>short16</b></th>
<th class="donthyphenate"><b>ushort16</b></th>
<th class="donthyphenate"><b>int8</b></th>
<th class="donthyphenate"><b>uint8</b></th>
<th class="donthyphenate"><b>long4</b></th>
<th class="donthyphenate"><b>ulong4</b></th>
<th class="donthyphenate"><b>float8</b></th>
<th class="donthyphenate"><b>double4</b></th>
</tr> <tr>
<td>=</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>+</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>-</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>*</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>/</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td><code>&amp;</code></td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td>|</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td><code>^</code></td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td>+=</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>-=</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>*=</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>/=</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>
<code>&amp;</code>=</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td>|=</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td><code>^=</code></td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td>
<i>unary</i><code>~</code>
</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>–</td>
<td>–</td>
</tr> <tr>
<td>
<i>unary</i>+</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> <tr>
<td>
<i>unary</i>-</td>
<td>–</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr> </table>  <p>Operators not listed are not supported at all.</p>  <h3 id="vector_op_intrinsics">Vector Operation Intrinsics</h3>  <p>See <a href="https://dlang.org/phobos/core_simd.html" target="_blank"><code>core.simd</code></a> for the supported intrinsics.</p>    <div class="_attribution">
  <p class="_attribution-p">
    © 1999–2018 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/spec/simd.html" class="_attribution-link" target="_blank">https://dlang.org/spec/simd.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
