
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>dmd.target - D - W3cubDocs</title>
  
  <meta name="description" content=" Compiler implementation of the D programming language. ">
  <meta name="keywords" content="dmd, target, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/dmd_target/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1>dmd.target</h1>  <p>Compiler implementation of the <a href="http://www.dlang.org" target="_blank">D programming language</a>. </p>
<dl>
<dt>Authors:</dt>
<dd>
<a href="http://www.digitalmars.com" target="_blank">Walter Bright</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/dmd/blob/master/src/dmd/target.d" target="_blank">target.d</a> </dd>
</dl> <dl>
<dt>Documentation</dt>
<dd> <a href="../dmd_target/">https://dlang.org/phobos/dmd_target.html</a> </dd>
</dl> <dl>
<dt>Coverage</dt>
<dd> <a href="https://codecov.io/gh/dlang/dmd/src/master/src/dmd/target.d" target="_blank">https://codecov.io/gh/dlang/dmd/src/master/src/dmd/target.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="Target">struct <strong id="Target">Target</strong>; </dt> <dd>
<p>Describes a back-end target. At present it is incomplete, but in the future it should grow to contain most or all target machine and target O/S specific information. </p>
<p>In many cases, calls to sizeof() can't be used directly for getting data type sizes since cross compiling is supported and would end up using the host sizes rather than the target sizes.</p> <dl>
<dt class="d_decl" id="Target.ptrsize">uint <strong id="ptrsize">ptrsize</strong>; </dt> <dd>
<p>size of a pointer in bytes</p> </dd> <dt class="d_decl" id="Target.realsize">uint <strong id="realsize">realsize</strong>; </dt> <dd>
<p>size a real consumes in memory</p> </dd> <dt class="d_decl" id="Target.realpad">uint <strong id="realpad">realpad</strong>; </dt> <dd>
<p>padding added to the CPU real size to bring it up to realsize</p> </dd> <dt class="d_decl" id="Target.realalignsize">uint <strong id="realalignsize">realalignsize</strong>; </dt> <dd>
<p>alignment for reals</p> </dd> <dt class="d_decl" id="Target.classinfosize">uint <strong id="classinfosize">classinfosize</strong>; </dt> <dd>
<p>size of <code>ClassInfo</code></p> </dd> <dt class="d_decl" id="Target.maxStaticDataSize">ulong <strong id="maxStaticDataSize">maxStaticDataSize</strong>; </dt> <dd>
<p>maximum size of static data</p> </dd> <dt class="d_decl" id="Target.c_longsize">uint <strong id="c_longsize">c_longsize</strong>; </dt> <dd>
<p>size of a C <code>long</code> or <code>unsigned long</code> type</p> </dd> <dt class="d_decl" id="Target.c_long_doublesize">uint <strong id="c_long_doublesize">c_long_doublesize</strong>; </dt> <dd>
<p>size of a C <code>long double</code></p> </dd> <dt class="d_decl" id="Target.reverseCppOverloads">bool <strong id="reverseCppOverloads">reverseCppOverloads</strong>; </dt> <dd>
<p>set if overloaded functions are grouped and in reverse order (such as in dmc and cl)</p> </dd> <dt class="d_decl" id="Target.cppExceptions">bool <strong id="cppExceptions">cppExceptions</strong>; </dt> <dd>
<p>set if catching C++ exceptions is supported</p> </dd> <dt class="d_decl" id="Target.twoDtorInVtable">bool <strong id="twoDtorInVtable">twoDtorInVtable</strong>; </dt> <dd>
<p>target C++ ABI puts deleting and non-deleting destructor into vtable</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties">struct <strong id="FPTypeProperties">FPTypeProperties</strong>(T); </dt> <dd>
<p>Values representing all properties for floating point types</p> <dl>
<dt class="d_decl" id="Target.FPTypeProperties.max">real_t <strong id="max">max</strong>; </dt> <dd>
<p>largest representable value that's not infinity</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.min_normal">real_t <strong id="min_normal">min_normal</strong>; </dt> <dd>
<p>smallest representable normalized value that's not 0</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.nan">real_t <strong id="nan">nan</strong>; </dt> <dd>
<p>NaN value</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.snan">real_t <strong id="snan">snan</strong>; </dt> <dd>
<p>signalling NaN value</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.infinity">real_t <strong id="infinity">infinity</strong>; </dt> <dd>
<p>infinity value</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.epsilon">real_t <strong id="epsilon">epsilon</strong>; </dt> <dd>
<p>smallest increment to the value 1</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.dig">d_int64 <strong id="dig">dig</strong>; </dt> <dd>
<p>number of decimal digits of precision</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.mant_dig">d_int64 <strong id="mant_dig">mant_dig</strong>; </dt> <dd>
<p>number of bits in mantissa</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.max_exp">d_int64 <strong id="max_exp">max_exp</strong>; </dt> <dd>
<p>maximum int value such that 2<sup><code>max_exp-1</code></sup> is representable</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.min_exp">d_int64 <strong id="min_exp">min_exp</strong>; </dt> <dd>
<p>minimum int value such that 2<sup><code>min_exp-1</code></sup> is representable as a normalized value</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.max_10_exp">d_int64 <strong id="max_10_exp">max_10_exp</strong>; </dt> <dd>
<p>maximum int value such that 10<sup><code>max_10_exp</code> is representable</sup></p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.min_10_exp">d_int64 <strong id="min_10_exp">min_10_exp</strong>; </dt> <dd>
<p>minimum int value such that 10<sup><code>min_10_exp</code></sup> is representable as a normalized value</p> </dd> </dl> </dd> <dt class="d_decl" id="Target.FloatProperties">alias <strong id="FloatProperties">FloatProperties</strong> = .Target.FPTypeProperties!float.FPTypeProperties; </dt>  <dt class="d_decl" id="Target.DoubleProperties">alias <strong id="DoubleProperties">DoubleProperties</strong> = .Target.FPTypeProperties!double.FPTypeProperties; </dt>  <dt class="d_decl" id="Target.RealProperties">alias <strong id="RealProperties">RealProperties</strong> = .Target.FPTypeProperties!real.FPTypeProperties; </dt>  <dt class="d_decl" id="Target._init">static void <strong id="_init">_init</strong>(); </dt> <dd>
<p>Initialize the Target</p> </dd> <dt class="d_decl" id="Target.alignsize">static uint <strong id="alignsize">alignsize</strong>(Type type); </dt> <dd>
<p>Requested target memory alignment size of the given type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>type</code>
</td> <td>type to inspect</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>alignment in bytes</dd>
</dl> </dd> <dt class="d_decl" id="Target.fieldalign">static uint <strong id="fieldalign">fieldalign</strong>(Type type); </dt> <dd>
<p>Requested target field alignment size of the given type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>type</code>
</td> <td>type to inspect</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>alignment in bytes</dd>
</dl> </dd> <dt class="d_decl" id="Target.critsecsize">static uint <strong id="critsecsize">critsecsize</strong>(); </dt> <dd>
<p>Size of the target OS critical section. </p>
<dl>
<dt>Returns:</dt>
<dd>size in bytes</dd>
</dl> </dd> <dt class="d_decl" id="Target.va_listType">static Type <strong id="va_listType">va_listType</strong>(); </dt> <dd>
<p>Type for the <code>va_list</code> type for the target. </p>
<dl>
<dt>NOTE</dt>
<dd> For Posix/x86_64 this returns the type which will really be used for passing an argument of type va_list. </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>Type</code> that represents <code>va_list</code>.</dd>
</dl> </dd> <dt class="d_decl" id="Target.isVectorTypeSupported">static int <strong id="isVectorTypeSupported">isVectorTypeSupported</strong>(int sz, Type type); </dt> <dd>
<p>Checks whether the target supports a vector type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>sz</code>
</td> <td>vector type size in bytes</td>
</tr> <tr>
<td>Type <code>type</code>
</td> <td>vector element type</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>0 vector type is supported, 1 vector type is not supported on the target at all 2 vector element type is not supported 3 vector size is not supported</dd>
</dl> </dd> <dt class="d_decl" id="Target.isVectorOpSupported">static bool <strong id="isVectorOpSupported">isVectorOpSupported</strong>(Type type, TOK op, Type t2 = null); </dt> <dd>
<p>Checks whether the target supports the given operation for vectors. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>type</code>
</td> <td>target type of operation</td>
</tr> <tr>
<td>TOK <code>op</code>
</td> <td>the unary or binary op being done on the <code>type</code>
</td>
</tr> <tr>
<td>Type <code>t2</code>
</td> <td>type of second operand if <code>op</code> is a binary operation</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if the operation is supported or type is not a vector</dd>
</dl> </dd> <dt class="d_decl" id="Target.toCppMangle">static const(char)* <strong id="toCppMangle">toCppMangle</strong>(Dsymbol s); </dt> <dd>
<p>Mangle the given symbol for C++ ABI. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Dsymbol <code>s</code>
</td> <td>declaration with C++ linkage</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>string mangling of symbol</dd>
</dl> </dd> <dt class="d_decl" id="Target.cppTypeInfoMangle">static const(char)* <strong id="cppTypeInfoMangle">cppTypeInfoMangle</strong>(ClassDeclaration cd); </dt> <dd>
<p>Get RTTI mangling of the given class declaration for C++ ABI. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ClassDeclaration <code>cd</code>
</td> <td>class with C++ linkage</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>string mangling of C++ typeinfo</dd>
</dl> </dd> <dt class="d_decl" id="Target.cppTypeMangle">static const(char)* <strong id="cppTypeMangle">cppTypeMangle</strong>(Type t); </dt> <dd>
<p>Gets vendor-specific type mangling for C++ ABI. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>type to inspect</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>string if type is mangled specially on target null if unhandled</dd>
</dl> </dd> <dt class="d_decl" id="Target.cppParameterType">static Type <strong id="cppParameterType">cppParameterType</strong>(Parameter p); </dt> <dd>
<p>Get the type that will really be used for passing the given argument to an <code>extern(C++)</code> function. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Parameter <code>p</code>
</td> <td>parameter to be passed.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>Type</code> to use for parameter <code>p</code>.</dd>
</dl> </dd> <dt class="d_decl" id="Target.systemLinkage">static LINK <strong id="systemLinkage">systemLinkage</strong>(); </dt> <dd>
<p>Default system linkage for the target. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>LINK</code> to use for <code>extern(System)</code>
</dd>
</dl> </dd> <dt class="d_decl" id="Target.toArgTypes">static TypeTuple <strong id="toArgTypes">toArgTypes</strong>(Type t); </dt> <dd>
<p>Describes how an argument type is passed to a function on target. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>type to break down</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>tuple of types if type is passed in one or more registers empty tuple if type is always passed on the stack</dd>
</dl> </dd> <dt class="d_decl" id="Target.isReturnOnStack">static bool <strong id="isReturnOnStack">isReturnOnStack</strong>(TypeFunction tf, bool needsThis); </dt> <dd>
<p>Determine return style of function - whether in registers or through a hidden pointer to the caller's stack. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TypeFunction <code>tf</code>
</td> <td>function type to check</td>
</tr> <tr>
<td>bool <code>needsThis</code>
</td> <td>true if the function type is for a non-static member function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if return value from function is on the stack</dd>
</dl> </dd> <dt class="d_decl" id="Target.parameterSize">static ulong <strong id="parameterSize">parameterSize</strong>(ref const Loc loc, Type t); </dt> <dd>
<p>Determine the size a value of type <code>t</code> will be when it is passed on the function parameter stack. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Loc <code>loc</code>
</td> <td>location to use for error messages</td>
</tr> <tr>
<td>Type <code>t</code>
</td> <td>type of parameter</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>size used on parameter stack</dd>
</dl> </dd> <dt class="d_decl" id="Target.getTargetInfo">static Expression <strong id="getTargetInfo">getTargetInfo</strong>(const(char)* name, ref const Loc loc); </dt> <dd>
<p>Get targetInfo by key </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)* <code>name</code>
</td> <td>name of targetInfo to get</td>
</tr> <tr>
<td>Loc <code>loc</code>
</td> <td>location to use for error messages</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Expression for the requested targetInfo</dd>
</dl> </dd> </dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2018 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/dmd_target.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/dmd_target.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
