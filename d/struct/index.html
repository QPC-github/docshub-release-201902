
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>14. Structs, Unions - D - W3cubDocs</title>
  
  <meta name="description" content="Whereas classes are reference types, structs are value types. Structs and unions are simple aggregations of data and their associated operations on &hellip;">
  <meta name="keywords" content="structs, unions, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/struct/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1>Structs, Unions</h1>       <b>Contents</b>  <ol> <li><a href="#struct_layout">Struct Layout</a></li> <li><a href="#POD">Plain Old Data</a></li> <li><a href="#opaque_struct_unions">Opaque Structs and Unions</a></li> <li><a href="#default_struct_init">Default Initialization of Structs</a></li> <li><a href="#static_struct_init">Static Initialization of Structs</a></li> <li><a href="#default_union_init">Default Initialization of Unions</a></li> <li><a href="#static_union_init">Static Initialization of Unions</a></li> <li><a href="#dynamic_struct_init">Dynamic Initialization of Structs</a></li> <li><a href="#struct-literal">Struct Literals</a></li> <li><a href="#struct_properties">Struct Properties</a></li> <li><a href="#struct_instance_properties">Struct Instance Properties</a></li> <li><a href="#struct_field_properties">Struct Field Properties</a></li> <li><a href="#const-struct">Const, Immutable and Shared Structs</a></li> <li><a href="#struct-constructor">Struct Constructors</a></li> <li><a href="#disable_default_construction">Disabling Default Struct Construction</a></li> <li><a href="#UnionConstructor">Union Constructors</a></li> <li><a href="#field-init">Field initialization inside constructor</a></li> <li><a href="#struct-postblit">Struct Postblits</a></li> <li><a href="#struct-destructor">Struct Destructors</a></li> <li><a href="#StructInvariant">Struct Invariants</a></li> <li><a href="#assign-overload">Identity Assignment Overload</a></li> <li><a href="#nested">Nested Structs</a></li> <li><a href="#unions_and_special_memb_funct">Unions and Special Member Functions</a></li> </ol>   <p>Whereas classes are reference types, structs are value types. Structs and unions are simple aggregations of data and their associated operations on that data. </p>  <pre>AggregateDeclaration:
    ClassDeclaration
    InterfaceDeclaration
    StructDeclaration
    UnionDeclaration

StructDeclaration:
    struct Identifier ;
    struct Identifier AggregateBody
    StructTemplateDeclaration
    AnonStructDeclaration

AnonStructDeclaration:
    struct AggregateBody

UnionDeclaration:
    union Identifier ;
    union Identifier AggregateBody
    UnionTemplateDeclaration
    AnonUnionDeclaration

AnonUnionDeclaration:
    union AggregateBody

AggregateBody:
    { DeclDefsopt }
</pre>  <p>A struct is defined to not have an identity; that is, the implementation is free to make bit copies of the struct as convenient.</p>  <p>Structs and unions may not contain an instance of themselves, however, they may contain a pointer to the same type. </p>  <b>Best Practices:</b> <ol> <li>Bit fields are supported with the <a href="https://dlang.org/phobos/std_bitmanip.html#bitfields" target="_blank">bitfields</a> template.</li> </ol>   <h2 id="struct_layout">Struct Layout</h2>  <p>The non-static data members of a struct are called <i>fields</i>. Fields are laid out in lexical order. Fields are aligned according to the <a href="../attribute/#align">Align Attribute</a> in effect. Unnamed padding is inserted between fields to align fields. There is no padding between the first field and the start of the object. </p>  <p>Structs with no fields of non-zero size (aka <i>Empty Structs</i>) have a size of one byte.</p>  <p>Non-static <a href="#nested">function-nested D structs</a>, which access the context of their enclosing scope, have an extra field. </p>  <b>Implementation Defined</b>: <ol> <li>The default layout of the fields of a struct is an exact match with the <i>associated C compiler</i>.</li> <li>g++ and clang++ differ in how empty structs are handled. Both return <code>1</code> from <code>sizeof</code>, however, clang++ does not push them onto the parameter stack while g++ does. This is a binary incompatibility between g++ and clang++. dmd follows clang++ behavior for OSX and FreeBSD, and g++ behavior for Linux and other Posix platforms. </li> <li>clang and gcc both return <code>0</code> from <code>sizeof</code> for empty structs. Using <code>extern "C++"</code> in clang++ and g++ does not cause them to conform to the behavior of their respective C compilers.</li> </ol>  <b>Undefined Behavior</b>: <ol> <li>The padding data can be accessed, but its contents are undefined.</li> <li>Do not pass or return structs with no fields of non-zero size to <code>extern (C)</code> functions. According to C11 6.7.2.1p8 this is undefined behavior.</li> </ol>  <b>Best Practices:</b> <ol> <li>When laying out a struct to match an externally defined layout, use align attributes to describe an exact match. Using a <a href="../version/#static-assert">Static Assert</a> to ensure the result is as expected.</li> <li>Although the contents of the padding are often zero, do not rely on that.</li> <li>Avoid using empty structs when interfacing with C and C++ code.</li> <li>Avoid using empty structs as parameters or arguments to variadic functions.</li> </ol>  <h2 id="POD">Plain Old Data</h2>  <p>A struct or union is <i>Plain Old Data</i> (POD) if it meets the following criteria:</p>  <ol> <li>it is not nested</li> <li>it has no postblits, destructors, or assignment operators</li> <li>it has no <code>ref</code> fields or fields that are themselves non-POD</li> </ol>  <b>Best Practices:</b> Structs or unions that interface with C code should be POD.   <h2 id="opaque_struct_unions">Opaque Structs and Unions</h2>  <p>Opaque struct and union declarations do not have a <a href="#AggregateBody"><i>AggregateBody</i></a>:</p>  <pre data-language="d">struct S;
union U;
</pre>  <p>The members are completely hidden to the user, and so the only operations on those types are ones that do not require any knowledge of the contents of those types. For example:</p>   <pre data-language="d">struct S;
S.sizeof; // error, size is not known
S s;      // error, cannot initialize unknown contents
S* p;     // ok, knowledge of members is not necessary
</pre>   <b>Best Practices:</b> They can be used to implement the <a href="https://en.wikipedia.org/wiki/Opaque_pointer" target="_blank">PIMPL idiom</a>.   <h2 id="default_struct_init">Default Initialization of Structs</h2>  <p>Struct fields are by default initialized to whatever the <a href="../declaration/#Initializer"><i>Initializer</i></a> for the field is, and if none is supplied, to the default initializer for the field's type. </p>   <pre data-language="d">struct S { int a = 4; int b; }
S x; // x.a is set to 4, x.b to 0
</pre>   <p>The default initializers are evaluated at compile time.</p>  <p>The default initializers may not contain references to mutable data.</p>  <h2 id="static_struct_init">Static Initialization of Structs</h2>  <p>If a <a href="../declaration/#StructInitializer"><i>StructInitializer</i></a> is supplied, the fields are initialized by the <a href="../declaration/#StructMemberInitializer"><i>StructMemberInitializer</i></a> syntax. <i>StructMemberInitializers</i> with the <i>Identifier : NonVoidInitializer</i> syntax may be appear in any order, where <i>Identifier</i> is the field identifer. <i>StructMemberInitializer</i>s with the <a href="../declaration/#NonVoidInitializer"><i>NonVoidInitializer</i></a> syntax appear in the lexical order of the fields in the <a href="#StructDeclaration"><i>StructDeclaration</i></a>. </p>  <p>Fields not specified in the <i>StructInitializer</i> are default initialized.</p>   <pre data-language="d">struct S { int a, b, c, d = 7; }
S r;                          // r.a = 0, r.b = 0, r.c = 0, r.d = 7
S s = { a:1, b:2 };           // s.a = 1, s.b = 2, s.c = 0, s.d = 7
S t = { c:4, b:5, a:2, d:5 }; // t.a = 2, t.b = 5, t.c = 4, t.d = 5
S u = { 1, 2 };               // u.a = 1, u.b = 2, u.c = 0, u.d = 7
S v = { 1, d:3 };             // v.a = 1, v.b = 0, v.c = 0, v.d = 3
S w = { b:1, 3 };             // v.a = 0, v.b = 1, v.c = 3, v.d = 7
</pre>   <p>Initializing a field more than once is an error:</p>   <pre data-language="d">S x = { 1, a:2 };  // error: duplicate initializer for field `a`
</pre>   <h2 id="default_union_init">Default Initialization of Unions</h2>  <p>Unions are by default initialized to whatever the <a href="../declaration/#Initializer"><i>Initializer</i></a> for the first field is, and if none is supplied, to the default initializer for the first field's type. </p>  <p>If the union is larger than the first field, the remaining bits are set to 0.</p>   <pre data-language="d">union U { int a = 4; long b; }
U x; // x.a is set to 4, x.b to an implementation-defined value

union V { int a; long b = 4; }
V y; // y.a is set to 0, y.b to an implementation-defined value
</pre>    <pre data-language="d">union W { int a = 4; long b = 5; } // error: overlapping default initialization for `a` and `b`
</pre>   <p>The default initializer is evaluated at compile time.</p>  <b>Implementation Defined</b>: The values the fields other than the default initialized field are set to.  <h2 id="static_union_init">Static Initialization of Unions</h2>  <p>Unions are initialized similarly to structs, except that only one initializer is allowed.</p>   <pre data-language="d">union U { int a; double b; }
U u = { 2 };       // u.a = 2
U v = { b : 5.0 }; // v.b = 5.0
</pre>    <pre data-language="d">U w = { 2, 3 };    // error: overlapping initialization for field `a` and `b`
</pre>   <p>If the union is larger than the initialized field, the remaining bits are set to 0.</p>  <b>Implementation Defined</b>: The values the fields other than the initialized field are set to.  <h2 id="dynamic_struct_init">Dynamic Initialization of Structs</h2>  <p>The <a href="#static_struct_init">static initializer syntax</a> can also be used to initialize non-static variables. The initializer need not be evaluable at compile time.</p>   <pre data-language="d">struct S { int a, b, c, d = 7; }

void test(int i)
{
    S q = { 1, b:i }; // q.a = 1, q.b = i, q.c = 0, q.d = 7
}
</pre>   <p>Structs can be dynamically initialized from another value of the same type:</p>   <pre data-language="d">struct S { int a; }
S t;      // default initialized
t.a = 3;
S s = t;  // s.a is set to 3
</pre>   <p>If <code>opCall</code> is overridden for the struct, and the struct is initialized with a value that is of a different type, then the <code>opCall</code> operator is called:</p>   <pre data-language="d">struct S
{
    int a;

    static S opCall(int v)
    {
        S s;
        s.a = v;
        return s;
    }

    static S opCall(S v)
    {
        assert(0);
    }
}

S s = 3; // sets s.a to 3 using S.opCall(int)
S t = s; // sets t.a to 3, S.opCall(S) is not called
</pre>   <h2><span id="StructLiteral">Struct Literals</span></h2>  <p>Struct literals consist of the name of the struct followed by a parenthesized argument list:</p>   <pre data-language="d">struct S { int x; float y; }

int foo(S s) { return s.x; }

foo( S(1, 2) ); // set field x to 1, field y to 2
</pre>   <p>Struct literals are syntactically like function calls. If a struct has a member function named <code>opCall</code>, then struct literals for that struct are not possible. See also <a href="../operatoroverloading/#FunctionCall">opCall operator overloading</a> for the issue workaround. It is an error if there are more arguments than fields of the struct. If there are fewer arguments than fields, the remaining fields are initialized with their respective default initializers. If there are anonymous unions in the struct, only the first member of the anonymous union can be initialized with a struct literal, and all subsequent non-overlapping fields are default initialized. </p>  <h2 id="struct_properties">Struct Properties</h2>  <table>
<caption>Struct Properties</caption>
<tr>
<th class="donthyphenate"><b>Name</b></th>
<th class="donthyphenate"><b>Description</b></th>
</tr> <tr>
<td><code>.sizeof</code></td>
<td>Size in bytes of struct</td>
</tr> <tr>
<td><code>.alignof</code></td>
<td>Size boundary struct needs to be aligned on</td>
</tr> </table>  <h2 id="struct_instance_properties">Struct Instance Properties</h2>  <table>
<caption>Struct Instance Properties</caption>
<tr>
<th class="donthyphenate"><b>Name</b></th>
<th class="donthyphenate"><b>Description</b></th>
</tr> <tr>
<td><code>.tupleof</code></td>
<td>An <a href="../template/#variadic-templates">expression sequence</a> of all struct fields - see <a href="../class/#class_properties">Class Properties</a> for a class-based example.</td>
</tr> </table>  <h2 id="struct_field_properties">Struct Field Properties</h2>  <table>
<caption>Struct Field Properties</caption>
<tr>
<th class="donthyphenate"><b>Name</b></th>
<th class="donthyphenate"><b>Description</b></th>
</tr> <tr>
<td><code>.offsetof</code></td>
<td>Offset in bytes of field from beginning of struct</td>
</tr> </table>  <h2><span id="ConstStruct">Const, Immutable and Shared Structs</span></h2>  <p>A struct declaration can have a storage class of <code>const</code>, <code>immutable</code> or <code>shared</code>. It has an equivalent effect as declaring each member of the struct as <code>const</code>, <code>immutable</code> or <code>shared</code>. </p>   <pre data-language="d">const struct S { int a; int b = 2; }
void main()
{
    S s = S(3); // initializes s.a to 3
    S t;        // initializes t.a to 0
    t = s;      // error, t.a and t.b are const, so cannot modify them.
    t.a = 4;    // error, t.a is const
}
</pre>   <h2><span id="Struct-Constructor">Struct Constructors</span></h2>  <p>Struct constructors are used to initialize an instance of a struct when a more complex construction is needed than is allowed by <a href="#static_struct_init">static initialization</a> or a <a href="#struct-literal">struct literal</a>. </p>  <p>Constructors are defined with a function name of <code>this</code> and having no return value. The grammar is the same as for the class <a href="../class/#Constructor"><i>Constructor</i></a>. </p>  <p>A struct constructor is called by the name of the struct followed by <a href="../class/#Parameters"><i>Parameters</i></a>. </p>
<p>If the <a href="../class/#ParameterList"><i>ParameterList</i></a> is empty, the struct instance is default initialized.</p>   <pre data-language="d">struct S
{
    int x, y = 4, z = 6;
    this(int a, int b)
    {
        x = a;
        y = b;
    }
}

void main()
{
    S a = S(4, 5); // calls S.this(4, 5):  a.x = 4, a.y = 5, a.z = 6
    S b = S();  // default initialized:    a.x = 0, b.y = 4, b.y = 6
    S c = S(1); // error, matching this(int) not found
}
</pre>   <p>A <i>default constructor</i> (i.e. one with an empty <a href="../function/#ParameterList"><i>ParameterList</i></a>) is not allowed.</p>   <pre data-language="d">struct S
{
    int x;
    this() { } // error, struct default constructor not allowed
}
</pre>   <p>Constructors can call other constructors for the same struct in order to share common initializations (this is called a <a href="../class/#delegating-constructors">delegating constructor</a>): </p>   <pre data-language="d">struct S
{
    int j = 1;
    long k = 2;
    this(long k)
    {
        this.k = k;
    }
    this(int i)
    {
        // At this point: j=1, k=2
        this(6); // delegating constructor call
        // At this point: j=1, k=6
        j = i;
        // At this point: j=i, k=6
    }
}
</pre>   <p>The following restrictions apply to struct construction:</p>  <ol> <li>If a constructor's code contains a delegate constructor call, all possible execution paths through the constructor must make exactly one delegate constructor call:   <pre data-language="d">struct S
{
    int a;
    this(int i) { }

    this(char c)
    {
        c || this(1); // error, not on all paths
    }

    this(wchar w)
    {
        (w) ? this(1) : this('c'); } // ok

    this(byte b)
    {
        foreach (i; 0 .. b)
        {
            this(1);  // error, inside loop
        }
    }
}
</pre>  </li>  <li>It is illegal to refer to <code>this</code> implicitly or explicitly prior to making a delegate constructor call.</li>  <li>Once the delegate constructor returns, all fields are considered constructed.</li>  <li>Delegate constructor calls cannot appear after labels.</li> </ol>   <p>When an instance of a struct is created, the following steps happen:</p>  <ol> <li>The raw data is statically initialized using the values provided in the struct definition. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one. </li>  <li>If there is a constructor defined for the struct, the constructor matching the argument list is called. </li>  <li>If struct invariant checking is turned on, the struct invariant is called at the end of the constructor. </li> </ol>   <p>A constructor qualifier (<code>const</code>, <code>immutable</code> or <code>shared</code>) constructs the object instance with that specific qualifier. </p>  <pre data-language="d">struct S1
{
    int[] a;
    this(int n) { a = new int[](n); }
}
struct S2
{
    int[] a;
    this(int n) immutable { a = new int[](n); }
}
void main()
{
    // Mutable constructor creates mutable object.
    S1 m1 = S1(1);

    // Constructed mutable object is implicitly convertible to const.
    const S1 c1 = S1(1);

    // Constructed mutable object is not implicitly convertible to immutable.
    immutable i1 = S1(1); // error

    // Mutable constructor cannot construct immutable object.
    auto x1 = immutable S1(1); // error


    // Immutable constructor creates immutable object.
    immutable i2 = immutable S2(1);

    // Immutable constructor cannot construct mutable object.
    auto x2 = S2(1); // error

    // Constructed immutable object is not implicitly convertible to mutable.
    S2 m2 = immutable S2(1); // error

    // Constructed immutable object is implicitly convertible to const.
    const S2 c2 = immutable S2(1);
}
</pre>   <p>Constructors can be overloaded with different attributes.</p>  <pre data-language="d">struct S
{
    this(int);           // non-shared mutable constructor
    this(int) shared;    // shared mutable constructor
    this(int) immutable; // immutable constructor
}

S m = S(1);
shared s = shared S(2);
immutable i = immutable S(3);
</pre>   <p>If the constructor can create a unique object (i.e. if it is <code>pure</code>), the object is implicitly convertible to any qualifiers. </p>  <pre data-language="d">struct S
{
    this(int) pure;
    // Based on the definition, this creates a mutable object. But the
    // created object cannot contain any mutable global data.
    // Therefore the created object is unique.

    this(int[] arr) immutable pure;
    // Based on the definition, this creates an immutable object. But
    // the argument int[] never appears in the created object so it
    // isn't implicitly convertible to immutable. Also, it cannot store
    // any immutable global data.
    // Therefore the created object is unique.
}

immutable i = immutable S(1); // this(int) pure is called
shared s = shared S(1);       // this(int) pure is called
S m = S([1,2,3]);             // this(int[]) immutable pure is called
</pre>     <h2 id="disable_default_construction">Disabling Default Struct Construction</h2>  <p>If struct constructor is annotated with <code>@disable</code> and has an empty <a href="../function/#ParameterList"><i>ParameterList</i></a>, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty <i>ParameterList</i>. </p>  <p>A struct with a disabled default constructor, and no other constructors, cannot be instantiated other than via a <a href="../declaration/#VoidInitializer"><i>VoidInitializer</i></a>.</p>  <p>A disabled default constructor may not have a <a href="../function/#FunctionBody"><i>FunctionBody</i></a>.</p>  <p>If any fields have disabled default construction, the struct default construction is also disabled.</p>   <pre data-language="d">struct S
{
    int x;

    // Disables default construction
    @disable this();

    this(int v) { x = v; }
}
struct T
{
    int y;
    S s;
}
void main()
{
    S s;          // error: default construction is disabled
    S t = S();    // error: also disabled
    S u = S(1);   // constructed by calling `S.this(1)`
    S v = void;   // not initialized, but allowed
    S w = { 1 };  // error: cannot use { } since constructor exists
    S[3] a;       // error: default construction is disabled
    S[3] b = [S(1), S(20), S(-2)]; // ok
    T t;          // error: default construction is disabled
}
</pre>   <b>Best Practices:</b> Disabling default construction is useful when the default value, such as <code>null</code>, is not acceptable.   <h2 id="UnionConstructor">Union Constructors</h2>  <p>Unions are constructed in the same way as structs.</p>   <h2 id="field-init">Field initialization inside constructor</h2>  <p>In a constructor body, if a delegate constructor is called, all field assignments are considered assignments. Otherwise, the first instance of field assignment is its initialization, and assignments of the form <code>field = expression</code> are treated as equivalent to <code>typeof(field)(expression)</code>. The values of fields may be read before initialization or construction with a delegate constructor. </p>   <pre data-language="d">struct S
{
    int num;
    int ber;
    this(int i)
    {
        num = i + 1;   // initialization
        num = i + 2;   // assignment
        ber = ber + 1; // ok to read before initialization
    }
    this(int i, int j)
    {
        this(i);
        num = i + 1;  // assignment
    }
}
</pre>   <p>If the field type has an <a href="../operatoroverloading/#assignment"><code>opAssign</code></a> method, it will not be used for initialization.</p>   <pre data-language="d">struct A
{
    this(int n) {}
    void opAssign(A rhs) {}
}
struct S
{
    A val;
    this(int i)
    {
        val = A(i);  // val is initialized to the value of A(i)
        val = A(2);  // rewritten to val.opAssign(A(2))
    }
}
</pre>   <p>If the field type is not mutable, multiple initialization will be rejected.</p>   <pre data-language="d">struct S
{
    immutable int num;
    this(int)
    {
        num = 1;  // OK
        num = 2;  // Error: assignment to immutable
    }
}
</pre>   <p>If the field is initialized on one path, it must be initialized on all paths.</p>  <pre data-language="d">struct S
{
    immutable int num;
    immutable int ber;
    this(int i)
    {
        if (i)
            num = 3;   // initialization
        else
            num = 4;   // initialization
    }
    this(long j)
    {
        j ? (num = 3) : (num = 4); // ok
        j || (ber = 3);  // Error: intialized on only one path
        j &amp;&amp; (ber = 3);  // Error: intialized on only one path
    }
}
</pre>   <p>A field initialization may not appear in a loop or after a label.</p>   <pre data-language="d">struct S
{
    immutable int num;
    immutable string str;
    this(int j)
    {
        foreach (i; 0..j)
        {
            num = 1;    // Error: field initialization not allowed in loops
        }
        size_t i = 0;
    Label:
        str = "hello";  // Error: field initialization not allowed after labels
        if (i++ &lt; 2)
            goto Label;
    }
    this(int j, int k)
    {
        switch (j)
        {
            case 1: ++j; break;
            default: break;
        }
        num = j;        // Error: `case` and `default` are also labels
    }
}
</pre>   <p>If a field's type has disabled default construction, then it must be initialized in the constructor.</p>  <pre data-language="d">struct S { int y; @disable this(); }

struct T
{
    S s;
    this(S t) { s = t; }       // ok
    this(int i) { this('c'); } // ok
    this(char) { }             // Error: s not initialized
}
</pre>   <h2><span id="StructPostblit">Struct Postblits</span></h2>  <pre>Postblit:
    this ( this ) MemberFunctionAttributesopt ;
    this ( this ) MemberFunctionAttributesopt FunctionBody
</pre>  <p><i>Copy construction</i> is defined as initializing a struct instance from another struct of the same type. Copy construction is divided into two parts:</p>  <ol> <li>blitting the fields, i.e. copying the bits</li> <li>running <i>postblit</i> on the result</li> </ol>  <p>The first part is done automatically by the language, the second part is done if a postblit function is defined for the struct. The postblit has access only to the destination struct object, not the source. Its job is to ‘fix up’ the destination as necessary, such as making copies of referenced data, incrementing reference counts, etc. For example: </p>   <pre data-language="d">struct S
{
    int[] a;    // array is privately owned by this instance
    this(this)
    {
        a = a.dup;
    }
}
</pre>   <p>Disabling struct postblit makes the object not copyable. </p>   <pre data-language="d">struct T
{
    @disable this(this);  // disabling makes T not copyable
}
struct S
{
    T t;   // uncopyable member makes S also not copyable
}

void main()
{
    S s;
    S t = s; // error, S is not copyable
}
</pre>   <p>Depending on the struct layout, the compiler may generate the following internal postblit functions:</p>  <ol> <li>
<code>void __postblit()</code>. The compiler assigns this name to the explicitly defined postblit <code>this(this)</code> so that it can be treated exactly as a normal function. Note that if a struct defines a postblit, it cannot define a function named <code>__postblit</code> - no matter the signature - as this would result in a compilation error due to the name conflict.</li> <li>
<code>void __fieldPostblit()</code>. If a struct <code>X</code> has at least one <code>struct</code> member that in turn defines (explicitly or implicitly) a postblit, then a field postblit is generated for <code>X</code> that calls all the underlying postblits of the struct fields in declaration order.</li> <li>
<code>void __aggrPostblit()</code>. If a struct has an explicitly defined postblit and at least 1 struct member that has a postblit (explicit or implicit) an aggregated postblit is generated which calls <code>__fieldPostblit</code> first and then <code>__postblit</code>.</li> <li>
<code>void __xpostblit()</code>. The field and aggregated postblits, although generated for a struct, are not actual struct members. In order to be able to call them, the compiler internally creates an alias, called <code>__xpostblit</code> which is a member of the struct and which points to the generated postblit that is the most inclusive.</li> </ol>   <pre data-language="d">// struct with alias __xpostblit = __postblit
struct X
{
    this(this) {}
}

// struct with alias __xpostblit = __fieldPostblit
// which contains a call to X.__xpostblit
struct Y
{
    X a;
}

// struct with alias __xpostblit = __aggrPostblit which contains
// a call to Y.__xpostblit and a call to Z.__postblit
struct Z
{
    Y a;
    this(this) {}
}

void main()
{
    // X has __postblit and __xpostblit (pointing to __postblit)
    static assert(__traits(hasMember, X, "__postblit"));
    static assert(__traits(hasMember, X, "__xpostblit"));

    // Y does not have __postblit, but has __xpostblit (pointing to __fieldPostblit)
    static assert(!__traits(hasMember, Y, "__postblit"));
    static assert(__traits(hasMember, Y, "__xpostblit"));
    // __fieldPostblit is not a member of the struct
    static assert(!__traits(hasMember, Y, "__fieldPostblit"));

    // Z has  __postblit and __xpostblit (pointing to __aggrPostblit)
    static assert(__traits(hasMember, Z, "__postblit"));
    static assert(__traits(hasMember, Z, "__xpostblit"));
    // __aggrPostblit is not a member of the struct
    static assert(!__traits(hasMember, Z, "__aggrPostblit"));
}
</pre>   <p>Neither of the above postblits is defined for structs that don't define <code>this(this)</code> and don't have fields that transitively define it. If a struct does not define a postblit (implicit or explicit) but defines functions that use the same name/signature as the internally generated postblits, the compiler is able to identify that the functions are not actual postblits and does not insert calls to them when the struct is copied. Example:</p>   <pre data-language="d">struct X
{}

int a;

struct Y
{
    int a;
    X b;
    void __fieldPostPostblit()
    {
        a = 42;
    }
}

void main()
{
    static assert(!__traits(hasMember, X, "__postblit"));
    static assert(!__traits(hasMember, X, "__xpostblit"));

    static assert(!__traits(hasMember, Y, "__postblit"));
    static assert(!__traits(hasMember, Y, "__xpostblit"));

    Y y;
    auto y2 = y;
    assert(a == 0); // __fieldPostBlit does not get called
}
</pre>   <p>Postblits cannot be overloaded. If two or more postblits are defined, even if the signatures differ, the compiler assigns the <code>__postblit</code> name to both and later issues a conflicting function name error:</p>   <pre data-language="d">struct X
{
    this(this) {}
    this(this) const {} // error: function X.__postblit conflicts with function X.__postblit
}
</pre>   <p>The following describes the behavior of the qualified postblit definitions:</p>  <ol> <li>
<code>const</code>. When a postblit is qualified with <code>const</code> as in <code>this(this) const;</code> or <code>const this(this);</code> then the postblit is succesfully called on mutable (unqualified), <code>const</code>, and <code>immutable</code> objects, but the postblit cannot modify the object because it regards it as <code>const</code>; hence <code>const</code> postblits are of limited usefulness. Example:</li>   <pre data-language="d">struct S
{
    int n;
    this(this) const
    {
        import std.stdio : writeln;
        writeln("postblit called");
        //++n; // error: cannot modify this.n in `const` function
    }
}

void main()
{
    S s1;
    auto s2 = s1;
    const S s3;
    auto s4 = s3;
    immutable S s5;
    auto s6 = s5;
}
</pre>  <li>
<code>immutable</code>. When a postblit is qualified with <code>immutable</code> as in <code>this(this) immutable</code> or <code>immutable this(this)</code> the code is ill-formed. The <code>immutable</code> postblit passes the compilation phase but cannot be invoked. Example:</li>   <pre data-language="d">struct Y
{
    // not invoked anywhere, no error is issued
    this(this) immutable
    { }
}

struct S
{
    this(this) immutable
    { }
}

void main()
{
    S s1;
    auto s2 = s1;    // error: immutable method `__postblit` is not callable using a mutable object
    const S s3;
    auto s4 = s3;    // error: immutable method `__postblit` is not callable using a mutable object
    immutable S s5;
    auto s6 = s5;    // error: immutable method `__postblit` is not callable using a mutable object
}
</pre>   <li>
<code>shared</code>. When a postblit is qualified with <code>shared</code> as in <code>this(this) shared</code> or <code>shared this(this)</code> solely <code>shared</code> objects may invoke the postblit; attempts of postbliting unshared objects will result in compile time errors:</li>   <pre data-language="d">struct S
{
    this(this) shared
    { }
}

void main()
{
    S s1;
    auto s2 = s1;    // error: shared method `__postblit` is not callable using a non-shared object
    const S s3;
    auto s4 = s3;    // error: shared method `__postblit` is not callable using a non-shared object
    immutable S s5;
    auto s6 = s5;    // error: shared method `__postblit` is not callable using a non-shared object

    // calling the shared postblit on a shared object is accepted
    shared S s7;
    auto s8 = s7;
}
</pre>  </ol>  <p>An unqualified postblit will get called even if the struct is instantiated as <code>immutable</code> or <code>const</code>, but the compiler issues an error if the struct is instantiated as <code>shared</code>:</p>   <pre data-language="d">struct S
{
    int n;
    this(this) { ++n; }
}

void main()
{
    immutable S a;      // shared S a; =&gt; error : non-shared method is not callable using a shared object
    auto a2 = a;
    import std.stdio: writeln;
    writeln(a2.n);     // prints 1
}
</pre>   <p>From a postblit perspective, qualifiying the struct definition yields the same result as explicitly qualifying the postblit.</p>  <p>The following table lists all the possibilities of grouping qualifiers for a postblit associated with the type of object that needs to be used in order to succesfully invoke the postblit:</p>  <table>
<caption>Qualifier Groups</caption> <tr>
<td>object type to be invoked on</td>
<td><code>const</code></td>
<td><code>immutable</code></td>
<td><code>shared</code></td>
</tr> <tr>
<td>any object type</td>
<td> ✔</td>
<td> </td>
<td> </td>
</tr> <tr>
<td>uncallable</td>
<td> </td>
<td> ✔</td>
<td> </td>
</tr> <tr>
<td>shared object</td>
<td> </td>
<td> </td>
<td> ✔</td>
</tr> <tr>
<td>uncallable</td>
<td> ✔</td>
<td> ✔</td>
<td> </td>
</tr> <tr>
<td>shared object</td>
<td> ✔</td>
<td> </td>
<td> ✔</td>
</tr> <tr>
<td>uncallable</td>
<td> </td>
<td> ✔</td>
<td> ✔</td>
</tr> <tr>
<td>uncallable</td>
<td> ✔</td>
<td> ✔</td>
<td> ✔</td>
</tr> </table>  <p>Note that when <code>const</code> and <code>immutable</code> are used to explicitly qualify a postblit as in <code>this(this) const immutable;</code> or <code>const immutable this(this);</code> - the order in which the qualifiers are declared does not matter - the compiler generates a conflicting attribute error, however declaring the struct as <code>const</code>/<code>immutable</code> and the postblit as <code>immutable</code>/<code>const</code> achieves the effect of applying both qualifiers to the postblit. In both cases the postblit is qualified with the more restrictive qualifier, which is <code>immutable</code>. </p>  <p>The postblits <code>__fieldPostblit</code> and <code>__aggrPostblit</code> are generated without any implicit qualifiers and are not considered struct members. This leads to the situation where qualifying an entire struct declaration does not have any impact on the above mentioned postblits. However, since <code>__xpostblit</code> is a member of the struct and an alias of one of the other postblits, the qualifiers applied to the struct will affect the aliased postblit:</p>   <pre data-language="d">struct S
{
    this(this)
    { }
}

// `__xpostblit` aliases the aggregated postblit so the `const` applies to it.
// However, the aggregated postblit calls the field postblit which does not have
// any qualifier applied, resulting in a qualifier mismatch error
const struct B
{
    S a;        // error : mutable method B.__fieldPostblit is not callable using a const object
    this(this)
    { }
}

// `__xpostblit` aliases the field postblit; no error
const struct B2
{
    S a;
}

// Similar to B
immutable struct C
{
    S a;        // error : mutable method C.__fieldPostblit is not callable using a immutable object
    this(this)
    { }
}

// Similar to B2, compiles
immutable struct C2
{
    S a;
}

// Similar to B
shared struct D
{
    // error: non-shared method S.__postblit is not callable using a shared object
    // error: non-shared method D.__fieldPostblit is not callable using a shared object
    S a;
    this(this)
    { }
}

// Unlike B2, this example also does not work due to additional restrictions on shared.
shared struct D2
{
    // error: non-shared method S.__postblit is not callable using a shared object
    S a;
}
</pre>   <p>In the above situations the errors do not contain line numbers because the errors are regarding generated code. In the case of the <code>shared</code> struct, the first error message can be suppressed by qualifying the postblit of <code>S</code> with <code>shared</code>. </p>  <p>Unions may not have fields that have postblits.</p>  <h2><span id="StructDestructor">Struct Destructors</span></h2>  <p>Destructors are called when an object goes out of scope. Their purpose is to free up resources owned by the struct object. </p>  <p>Unions may not have fields that have destructors.</p>  <h2 id="StructInvariant">Struct Invariants</h2>  <pre>StructInvariant:
    invariant ( ) BlockStatement
    invariant BlockStatement
    invariant ( AssertArguments ) ;
</pre>  <p><i>StructInvariant</i>s specify the relationships among the members of a struct instance. Those relationships must hold for any interactions with the instance from its public interface. </p>  <p>The invariant is in the form of a <code>const</code> member function. The invariant is defined to <i>hold</i> if all the <a href="../expression/#AssertExpression"><i>AssertExpression</i></a>s within the invariant that are executed succeed. </p>  <p>If the invariant does not hold, then the program enters an invalid state.</p>  <p>Any invariants for fields are applied before the struct invariant.</p>  <p>There may be multiple invariants in a struct. They are applied in lexical order.</p>  <p><i>StructInvariant</i>s must hold at the exit of the struct constructor (if any), and at the entry of the struct destructor (if any).</p>  <p><i>StructInvariant</i>s must hold at the entry and exit of all public or exported non-static member functions. The order of application of invariants is: </p>
<ol> <li>preconditions</li> <li>invariant</li> <li>function body</li> <li>invariant</li> <li>postconditions</li> </ol>  <p>The invariant need not hold if the struct instance is implicitly constructed using the default <code>.init</code> value.</p>   <pre data-language="d">struct Date
{
    this(int d, int h)
    {
        day = d;    // days are 1..31
        hour = h;   // hours are 0..23
    }

    invariant
    {
        assert(1 &lt;= day &amp;&amp; day &lt;= 31);
        assert(0 &lt;= hour &amp;&amp; hour &lt; 24);
    }

  private:
    int day;
    int hour;
}
</pre>   <p>Public or exported non-static member functions cannot be called from within an invariant.</p>   <pre data-language="d">struct Foo
{
    public void f() { }
    private void g() { }

    invariant
    {
        f();  // error, cannot call public member function from invariant
        g();  // ok, g() is not public
    }
}
</pre>   <b>Undefined Behavior</b>: happens if the invariant does not hold and execution continues.  <b>Implementation Defined</b>: <ol> <li>Whether the <i>StructInvariant</i> is executed at runtime or not. This is typically controlled with a compiler switch.</li> <li>The behavior when the invariant does not hold is typically the same as for when <a href="../expression/#AssertExpression"><i>AssertExpression</i></a>s fail.</li> </ol>   <b>Best Practices:</b> <ol> <li>Do not indirectly call exported or public member functions within a struct invariant, as this can result in infinite recursion.</li> <li>Avoid reliance on side effects in the invariant. as the invariant may or may not be executed.</li> <li>Avoid having mutable public fields of structs with invariants, as then the invariant cannot verify the public interface.</li> </ol>     <h2><span id="AssignOverload">Identity Assignment Overload</span></h2>  <p>While copy construction takes care of initializing an object from another object of the same type, or elaborate destruction is needed for the type, assignment is defined as copying the contents of one object over another, already initialized, type: </p>  <pre data-language="d">struct S { ... }  // S has postblit or destructor
S s;      // default construction of s
S t = s;  // t is copy-constructed from s
t = s;    // t is assigned from s
</pre>  <p>Struct assignment <code>t=s</code> is defined to be semantically equivalent to: </p>  <pre data-language="d">t.opAssign(s);
</pre>  <p>where <code>opAssign</code> is a member function of S:</p>  <pre data-language="d">ref S opAssign(ref S s)
{
    S tmp = this;   // bitcopy this into tmp
    this = s;       // bitcopy s into this
    tmp.__dtor();   // call destructor on tmp
    return this;
}
</pre>  <p>An identity assignment overload is required for a struct if one or more of these conditions hold:</p>  <ul> <li>it has a <a href="#struct-destructor">destructor</a>
</li> <li>it has a <a href="#struct-postblit">postblit</a>
</li> <li>it has a field with an identity assignment overload</li> </ul>  <p>If an identity assignment overload is required and does not exist, an identity assignment overload function of the type <code>ref S opAssign(ref S)</code> will be automatically generated.</p>  <p>A user-defined one can implement the equivalent semantics, but can be more efficient. </p>  <p>One reason a custom <code>opAssign</code> might be more efficient is if the struct has a reference to a local buffer: </p>   <pre data-language="d">struct S
{
    int[] buf;
    int a;

    ref S opAssign(ref const S s)
    {
        a = s.a;
        return this;
    }

    this(this)
    {
        buf = buf.dup;
    }
}
</pre>   <p>Here, <code>S</code> has a temporary workspace <code>buf[]</code>. The normal postblit will pointlessly free and reallocate it. The custom <code>opAssign</code> will reuse the existing storage. </p>  <h2 id="nested">Nested Structs</h2>  <p>A <i>nested struct</i> is a struct that is declared inside the scope of a function or a templated struct that has aliases to local functions as a template argument. Nested structs have member functions. It has access to the context of its enclosing scope (via an added hidden field).</p>   <pre data-language="d">void foo()
{
    int i = 7;
    struct SS
    {
        int x,y;
        int bar() { return x + i + 1; }
    }
    SS s;
    s.x = 3;
    s.bar(); // returns 11
}
</pre>   <p>A struct can be prevented from being nested by using the static attribute, but then of course it will not be able to access variables from its enclosing scope.</p>   <pre data-language="d">void foo()
{
    int i = 7;
    static struct SS
    {
        int x, y;
        int bar()
        {
            return i; // error, SS is not a nested struct
        }
    }
}
</pre>   <h2 id="unions_and_special_memb_funct">Unions and Special Member Functions</h2>  <p>Unions may not have postblits, destructors, or invariants.</p>     <div class="_attribution">
  <p class="_attribution-p">
    © 1999–2018 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/spec/struct.html" class="_attribution-link" target="_blank">https://dlang.org/spec/struct.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
