
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Docker Service Create - Docker 17 - W3cubDocs</title>
  
  <meta name="description" content=" Create a new service ">
  <meta name="keywords" content="docker, service, create, -, docker~17">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/docker~17/engine/reference/commandline/service_create/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/docker~17.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/docker~17/" class="_nav-link" title="" style="margin-left:0;">Docker 17</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _simple">
				
				
<h1>docker service create</h1>    <h2 id="description">Description</h2> <p>Create a new service</p> <h2 id="usage">Usage</h2> <pre data-language="">docker service create [OPTIONS] IMAGE [COMMAND] [ARG...]
</pre> <h2 id="options">Options</h2> <table> <thead> <tr> <th>Name, shorthand</th> <th>Default</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">--config</code></td> <td> </td> <td>Specify configurations to expose to the service</td> </tr> <tr> <td><code class="highlighter-rouge">--constraint</code></td> <td> </td> <td>Placement constraints</td> </tr> <tr> <td><code class="highlighter-rouge">--container-label</code></td> <td> </td> <td>Container labels</td> </tr> <tr> <td><code class="highlighter-rouge">--credential-spec</code></td> <td> </td> <td>Credential spec for managed service account (Windows only)</td> </tr> <tr> <td><code class="highlighter-rouge">--detach, -d</code></td> <td><code class="highlighter-rouge">true</code></td> <td>Exit immediately instead of waiting for the service to converge</td> </tr> <tr> <td><code class="highlighter-rouge">--dns</code></td> <td> </td> <td>Set custom DNS servers</td> </tr> <tr> <td><code class="highlighter-rouge">--dns-option</code></td> <td> </td> <td>Set DNS options</td> </tr> <tr> <td><code class="highlighter-rouge">--dns-search</code></td> <td> </td> <td>Set custom DNS search domains</td> </tr> <tr> <td><code class="highlighter-rouge">--endpoint-mode</code></td> <td><code class="highlighter-rouge">vip</code></td> <td>Endpoint mode (vip or dnsrr)</td> </tr> <tr> <td><code class="highlighter-rouge">--entrypoint</code></td> <td> </td> <td>Overwrite the default ENTRYPOINT of the image</td> </tr> <tr> <td><code class="highlighter-rouge">--env, -e</code></td> <td> </td> <td>Set environment variables</td> </tr> <tr> <td><code class="highlighter-rouge">--env-file</code></td> <td> </td> <td>Read in a file of environment variables</td> </tr> <tr> <td><code class="highlighter-rouge">--group</code></td> <td> </td> <td>Set one or more supplementary user groups for the container</td> </tr> <tr> <td><code class="highlighter-rouge">--health-cmd</code></td> <td> </td> <td>Command to run to check health</td> </tr> <tr> <td><code class="highlighter-rouge">--health-interval</code></td> <td> </td> <td>Time between running the check (ms|s|m|h)</td> </tr> <tr> <td><code class="highlighter-rouge">--health-retries</code></td> <td><code class="highlighter-rouge">0</code></td> <td>Consecutive failures needed to report unhealthy</td> </tr> <tr> <td><code class="highlighter-rouge">--health-start-period</code></td> <td> </td> <td>Start period for the container to initialize before counting retries towards unstable (ms|s|m|h)</td> </tr> <tr> <td><code class="highlighter-rouge">--health-timeout</code></td> <td> </td> <td>Maximum time to allow one check to run (ms|s|m|h)</td> </tr> <tr> <td><code class="highlighter-rouge">--host</code></td> <td> </td> <td>Set one or more custom host-to-IP mappings (host:ip)</td> </tr> <tr> <td><code class="highlighter-rouge">--hostname</code></td> <td> </td> <td>Container hostname</td> </tr> <tr> <td><code class="highlighter-rouge">--label, -l</code></td> <td> </td> <td>Service labels</td> </tr> <tr> <td><code class="highlighter-rouge">--limit-cpu</code></td> <td> </td> <td>Limit CPUs</td> </tr> <tr> <td><code class="highlighter-rouge">--limit-memory</code></td> <td><code class="highlighter-rouge">0</code></td> <td>Limit Memory</td> </tr> <tr> <td><code class="highlighter-rouge">--log-driver</code></td> <td> </td> <td>Logging driver for service</td> </tr> <tr> <td><code class="highlighter-rouge">--log-opt</code></td> <td> </td> <td>Logging driver options</td> </tr> <tr> <td><code class="highlighter-rouge">--mode</code></td> <td><code class="highlighter-rouge">replicated</code></td> <td>Service mode (replicated or global)</td> </tr> <tr> <td><code class="highlighter-rouge">--mount</code></td> <td> </td> <td>Attach a filesystem mount to the service</td> </tr> <tr> <td><code class="highlighter-rouge">--name</code></td> <td> </td> <td>Service name</td> </tr> <tr> <td><code class="highlighter-rouge">--network</code></td> <td> </td> <td>Network attachments</td> </tr> <tr> <td><code class="highlighter-rouge">--no-healthcheck</code></td> <td><code class="highlighter-rouge">false</code></td> <td>Disable any container-specified HEALTHCHECK</td> </tr> <tr> <td><code class="highlighter-rouge">--no-resolve-image</code></td> <td><code class="highlighter-rouge">false</code></td> <td>Do not query the registry to resolve image digest and supported platforms</td> </tr> <tr> <td><code class="highlighter-rouge">--placement-pref</code></td> <td> </td> <td>Add a placement preference</td> </tr> <tr> <td><code class="highlighter-rouge">--publish, -p</code></td> <td> </td> <td>Publish a port as a node port</td> </tr> <tr> <td><code class="highlighter-rouge">--quiet, -q</code></td> <td><code class="highlighter-rouge">false</code></td> <td>Suppress progress output</td> </tr> <tr> <td><code class="highlighter-rouge">--read-only</code></td> <td><code class="highlighter-rouge">false</code></td> <td>Mount the container’s root filesystem as read only</td> </tr> <tr> <td><code class="highlighter-rouge">--replicas</code></td> <td> </td> <td>Number of tasks</td> </tr> <tr> <td><code class="highlighter-rouge">--reserve-cpu</code></td> <td> </td> <td>Reserve CPUs</td> </tr> <tr> <td><code class="highlighter-rouge">--reserve-memory</code></td> <td><code class="highlighter-rouge">0</code></td> <td>Reserve Memory</td> </tr> <tr> <td><code class="highlighter-rouge">--restart-condition</code></td> <td> </td> <td>Restart when condition is met (“none”|“on-failure”|“any”) (default “any”)</td> </tr> <tr> <td><code class="highlighter-rouge">--restart-delay</code></td> <td> </td> <td>Delay between restart attempts (ns|us|ms|s|m|h) (default 5s)</td> </tr> <tr> <td><code class="highlighter-rouge">--restart-max-attempts</code></td> <td> </td> <td>Maximum number of restarts before giving up</td> </tr> <tr> <td><code class="highlighter-rouge">--restart-window</code></td> <td> </td> <td>Window used to evaluate the restart policy (ns|us|ms|s|m|h)</td> </tr> <tr> <td><code class="highlighter-rouge">--rollback-delay</code></td> <td><code class="highlighter-rouge">0s</code></td> <td>Delay between task rollbacks (ns|us|ms|s|m|h) (default 0s)</td> </tr> <tr> <td><code class="highlighter-rouge">--rollback-failure-action</code></td> <td> </td> <td>Action on rollback failure (“pause”|“continue”) (default “pause”)</td> </tr> <tr> <td><code class="highlighter-rouge">--rollback-max-failure-ratio</code></td> <td><code class="highlighter-rouge">0</code></td> <td>Failure rate to tolerate during a rollback (default 0)</td> </tr> <tr> <td><code class="highlighter-rouge">--rollback-monitor</code></td> <td><code class="highlighter-rouge">0s</code></td> <td>Duration after each task rollback to monitor for failure (ns|us|ms|s|m|h) (default 5s)</td> </tr> <tr> <td><code class="highlighter-rouge">--rollback-order</code></td> <td> </td> <td>Rollback order (“start-first”|“stop-first”) (default “stop-first”)</td> </tr> <tr> <td><code class="highlighter-rouge">--rollback-parallelism</code></td> <td><code class="highlighter-rouge">1</code></td> <td>Maximum number of tasks rolled back simultaneously (0 to roll back all at once)</td> </tr> <tr> <td><code class="highlighter-rouge">--secret</code></td> <td> </td> <td>Specify secrets to expose to the service</td> </tr> <tr> <td><code class="highlighter-rouge">--stop-grace-period</code></td> <td> </td> <td>Time to wait before force killing a container (ns|us|ms|s|m|h) (default 10s)</td> </tr> <tr> <td><code class="highlighter-rouge">--stop-signal</code></td> <td> </td> <td>Signal to stop the container</td> </tr> <tr> <td><code class="highlighter-rouge">--tty, -t</code></td> <td><code class="highlighter-rouge">false</code></td> <td>Allocate a pseudo-TTY</td> </tr> <tr> <td><code class="highlighter-rouge">--update-delay</code></td> <td><code class="highlighter-rouge">0s</code></td> <td>Delay between updates (ns|us|ms|s|m|h) (default 0s)</td> </tr> <tr> <td><code class="highlighter-rouge">--update-failure-action</code></td> <td> </td> <td>Action on update failure (“pause”|“continue”|“rollback”) (default “pause”)</td> </tr> <tr> <td><code class="highlighter-rouge">--update-max-failure-ratio</code></td> <td><code class="highlighter-rouge">0</code></td> <td>Failure rate to tolerate during an update (default 0)</td> </tr> <tr> <td><code class="highlighter-rouge">--update-monitor</code></td> <td><code class="highlighter-rouge">0s</code></td> <td>Duration after each task update to monitor for failure (ns|us|ms|s|m|h) (default 5s)</td> </tr> <tr> <td><code class="highlighter-rouge">--update-order</code></td> <td> </td> <td>Update order (“start-first”|“stop-first”) (default “stop-first”)</td> </tr> <tr> <td><code class="highlighter-rouge">--update-parallelism</code></td> <td><code class="highlighter-rouge">1</code></td> <td>Maximum number of tasks updated simultaneously (0 to update all at once)</td> </tr> <tr> <td><code class="highlighter-rouge">--user, -u</code></td> <td> </td> <td>Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</td> </tr> <tr> <td><code class="highlighter-rouge">--with-registry-auth</code></td> <td><code class="highlighter-rouge">false</code></td> <td>Send registry authentication details to swarm agents</td> </tr> <tr> <td><code class="highlighter-rouge">--workdir, -w</code></td> <td> </td> <td>Working directory inside the container</td> </tr> </tbody> </table> <h2 id="parent-command">Parent command</h2> <table> <thead> <tr> <th>Command</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><a href="../service/">docker service</a></td> <td>Manage services</td> </tr> </tbody> </table> <h2 id="related-commands">Related commands</h2> <table> <thead> <tr> <th>Command</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><a href="/">docker service create</a></td> <td>Create a new service</td> </tr> <tr> <td><a href="../service_inspect/">docker service inspect</a></td> <td>Display detailed information on one or more services</td> </tr> <tr> <td><a href="../service_logs/">docker service logs</a></td> <td>Fetch the logs of a service or task</td> </tr> <tr> <td><a href="../service_ls/">docker service ls</a></td> <td>List services</td> </tr> <tr> <td><a href="../service_ps/">docker service ps</a></td> <td>List the tasks of one or more services</td> </tr> <tr> <td><a href="../service_rm/">docker service rm</a></td> <td>Remove one or more services</td> </tr> <tr> <td><a href="../service_scale/">docker service scale</a></td> <td>Scale one or multiple replicated services</td> </tr> <tr> <td><a href="../service_update/">docker service update</a></td> <td>Update a service</td> </tr> </tbody> </table> <h2 id="extended-description">Extended description</h2> <p>Creates a service as described by the specified parameters. You must run this command on a manager node.</p> <h2 id="examples">Examples</h2> <h3 id="create-a-service">Create a service</h3> <pre class="highlight" data-language="bash">$ docker service create --name redis redis:3.0.6

dmu1ept4cxcfe8k8lhtux3ro3

$ docker service create --mode global --name redis2 redis:3.0.6

a8q9dasaafudfs8q8w32udass

$ docker service ls

ID            NAME    MODE        REPLICAS  IMAGE
dmu1ept4cxcf  redis   replicated  1/1       redis:3.0.6
a8q9dasaafud  redis2  global      1/1       redis:3.0.6
</pre>  <h3 id="create-a-service-with-5-replica-tasks-replicas">Create a service with 5 replica tasks (–replicas)</h3> <p>Use the <code class="highlighter-rouge">--replicas</code> flag to set the number of replica tasks for a replicated service. The following command creates a <code class="highlighter-rouge">redis</code> service with <code class="highlighter-rouge">5</code> replica tasks:</p> <pre class="highlight" data-language="bash">$ docker service create --name redis --replicas=5 redis:3.0.6

4cdgfyky7ozwh3htjfw0d12qv
</pre>  <p>The above command sets the <em>desired</em> number of tasks for the service. Even though the command returns immediately, actual scaling of the service may take some time. The <code class="highlighter-rouge">REPLICAS</code> column shows both the <em>actual</em> and <em>desired</em> number of replica tasks for the service.</p> <p>In the following example the desired state is <code class="highlighter-rouge">5</code> replicas, but the current number of <code class="highlighter-rouge">RUNNING</code> tasks is <code class="highlighter-rouge">3</code>:</p> <pre class="highlight" data-language="bash">$ docker service ls

ID            NAME   MODE        REPLICAS  IMAGE
4cdgfyky7ozw  redis  replicated  3/5       redis:3.0.7
</pre>  <p>Once all the tasks are created and <code class="highlighter-rouge">RUNNING</code>, the actual number of tasks is equal to the desired number:</p> <pre class="highlight" data-language="bash">$ docker service ls

ID            NAME   MODE        REPLICAS  IMAGE
4cdgfyky7ozw  redis  replicated  5/5       redis:3.0.7
</pre>  <h3 id="create-a-service-with-secrets">Create a service with secrets</h3> <p>Use the <code class="highlighter-rouge">--secret</code> flag to give a container access to a <a href="../secret_create/">secret</a>.</p> <p>Create a service specifying a secret:</p> <pre class="highlight" data-language="bash">$ docker service create --name redis --secret secret.json redis:3.0.6

4cdgfyky7ozwh3htjfw0d12qv
</pre>  <p>Create a service specifying the secret, target, user/group ID and mode:</p> <pre class="highlight" data-language="bash">$ docker service create --name redis \
    --secret source=ssh-key,target=ssh \
    --secret source=app-key,target=app,uid=1000,gid=1001,mode=0400 \
    redis:3.0.6

4cdgfyky7ozwh3htjfw0d12qv
</pre>  <p>To grant a service access to multiple secrets, use multiple <code class="highlighter-rouge">--secret</code> flags.</p> <p>Secrets are located in <code class="highlighter-rouge">/run/secrets</code> in the container. If no target is specified, the name of the secret will be used as the in memory file in the container. If a target is specified, that will be the filename. In the example above, two files will be created: <code class="highlighter-rouge">/run/secrets/ssh</code> and <code class="highlighter-rouge">/run/secrets/app</code> for each of the secret targets specified.</p> <h3 id="create-a-service-with-a-rolling-update-policy">Create a service with a rolling update policy</h3> <pre class="highlight" data-language="bash">$ docker service create \
  --replicas 10 \
  --name redis \
  --update-delay 10s \
  --update-parallelism 2 \
  redis:3.0.6
</pre>  <p>When you run a <a href="../service_update/">service update</a>, the scheduler updates a maximum of 2 tasks at a time, with <code class="highlighter-rouge">10s</code> between updates. For more information, refer to the <a href="../../../swarm/swarm-tutorial/rolling-update/">rolling updates tutorial</a>.</p> <h3 id="set-environment-variables--e-env">Set environment variables (-e, –env)</h3> <p>This sets an environmental variable for all tasks in a service. For example:</p> <pre class="highlight" data-language="bash">$ docker service create \
  --name redis_2 \
  --replicas 5 \
  --env MYVAR=foo \
  redis:3.0.6
</pre>  <p>To specify multiple environment variables, specify multiple <code class="highlighter-rouge">--env</code> flags, each with a separate key-value pair.</p> <pre class="highlight" data-language="bash">$ docker service create \
  --name redis_2 \
  --replicas 5 \
  --env MYVAR=foo \
  --env MYVAR2=bar \
  redis:3.0.6
</pre>  <h3 id="create-a-service-with-specific-hostname-hostname">Create a service with specific hostname (–hostname)</h3> <p>This option sets the docker service containers hostname to a specific string. For example:</p> <pre class="highlight" data-language="bash">$ docker service create --name redis --hostname myredis redis:3.0.6
</pre>  <h3 id="set-metadata-on-a-service--l-label">Set metadata on a service (-l, –label)</h3> <p>A label is a <code class="highlighter-rouge">key=value</code> pair that applies metadata to a service. To label a service with two labels:</p> <pre class="highlight" data-language="bash">$ docker service create \
  --name redis_2 \
  --label com.example.foo="bar"
  --label bar=baz \
  redis:3.0.6
</pre>  <p>For more information about labels, refer to <a href="../../../userguide/labels-custom-metadata/">apply custom metadata</a>.</p> <h3 id="add-bind-mounts-or-volumes">Add bind-mounts or volumes</h3> <p>Docker supports two different kinds of mounts, which allow containers to read to or write from files or directories on other containers or the host operating system. These types are <em>data volumes</em> (often referred to simply as volumes) and <em>bind-mounts</em>.</p> <p>Additionally, Docker supports <code class="highlighter-rouge">tmpfs</code> mounts.</p> <p>A <strong>bind-mount</strong> makes a file or directory on the host available to the container it is mounted within. A bind-mount may be either read-only or read-write. For example, a container might share its host’s DNS information by means of a bind-mount of the host’s <code class="highlighter-rouge">/etc/resolv.conf</code> or a container might write logs to its host’s <code class="highlighter-rouge">/var/log/myContainerLogs</code> directory. If you use bind-mounts and your host and containers have different notions of permissions, access controls, or other such details, you will run into portability issues.</p> <p>A <strong>named volume</strong> is a mechanism for decoupling persistent data needed by your container from the image used to create the container and from the host machine. Named volumes are created and managed by Docker, and a named volume persists even when no container is currently using it. Data in named volumes can be shared between a container and the host machine, as well as between multiple containers. Docker uses a <em>volume driver</em> to create, manage, and mount volumes. You can back up or restore volumes using Docker commands.</p> <p>A <strong>tmpfs</strong> mounts a tmpfs inside a container for volatile data.</p> <p>Consider a situation where your image starts a lightweight web server. You could use that image as a base image, copy in your website’s HTML files, and package that into another image. Each time your website changed, you’d need to update the new image and redeploy all of the containers serving your website. A better solution is to store the website in a named volume which is attached to each of your web server containers when they start. To update the website, you just update the named volume.</p> <p>For more information about named volumes, see <a href="../../../admin/volumes/volumes/">Data Volumes</a>.</p> <p>The following table describes options which apply to both bind-mounts and named volumes in a service:</p> <table> <tr> <th>Option</th> <th>Required</th> <th>Description</th> </tr> <tr> <td><b>types</b></td> <td></td> <td> <p>The type of mount, can be either <tt>volume</tt>, <tt>bind</tt>, or <tt>tmpfs</tt>. Defaults to <tt>volume</tt> if no type is specified. </p>
<ul> <li>
<tt>volume</tt>: mounts a [managed volume](volume_create.md) into the container.</li> <li>
<tt>bind</tt>: bind-mounts a directory or file from the host into the container.</li> <li>
<tt>tmpfs</tt>: mount a tmpfs in the container</li> </ul> </td> </tr> <tr> <td>
<b>src</b> or <b>source</b>
</td> <td>for <tt>type=bind</tt> only&gt;</td> <td> <ul> <li> <tt>type=volume</tt>: <tt>src</tt> is an optional way to specify the name of the volume (for example, <tt>src=my-volume</tt>). If the named volume does not exist, it is automatically created. If no <tt>src</tt> is specified, the volume is assigned a random name which is guaranteed to be unique on the host, but may not be unique cluster-wide. A randomly-named volume has the same lifecycle as its container and is destroyed when the <i>container</i> is destroyed (which is upon <tt>service update</tt>, or when scaling or re-balancing the service) </li> <li> <tt>type=bind</tt>: <tt>src</tt> is required, and specifies an absolute path to the file or directory to bind-mount (for example, <tt>src=/path/on/host/</tt>). An error is produced if the file or directory does not exist. </li> <li> <tt>type=tmpfs</tt>: <tt>src</tt> is not supported. </li> </ul> </td> </tr> <tr> <td><p><b>dst</b> or <b>destination</b> or <b>target</b></p></td> <td>yes</td> <td> <p>Mount path inside the container, for example <tt>/some/path/in/container/</tt>. If the path does not exist in the container's filesystem, the Engine creates a directory at the specified location before mounting the volume or bind-mount.</p> </td> </tr> <tr> <td><p><b>readonly</b> or <b>ro</b></p></td> <td></td> <td> <p>The Engine mounts binds and volumes <tt>read-write</tt> unless <tt>readonly</tt> option is given when mounting the bind or volume. </p>
<ul> <li>
<tt>true</tt> or <tt>1</tt> or no value: Mounts the bind or volume read-only.</li> <li>
<tt>false</tt> or <tt>0</tt>: Mounts the bind or volume read-write.</li> </ul> </td> </tr> <tr> <td><b>consistency</b></td> <td></td> <td> <p>The consistency requirements for the mount; one of </p>
<ul> <li>
<tt>default</tt>: Equivalent to <tt>consistent</tt>.</li> <li>
<tt>consistent</tt>: Full consistency. The container runtime and the host maintain an identical view of the mount at all times.</li> <li>
<tt>cached</tt>: The host's view of the mount is authoritative. There may be delays before updates made on the host are visible within a container.</li> <li>
<tt>delegated</tt>: The container runtime's view of the mount is authoritative. There may be delays before updates made in a container are are visible on the host.</li> </ul> </td> </tr> </table> <h4 id="bind-propagation">Bind Propagation</h4> <p>Bind propagation refers to whether or not mounts created within a given bind-mount or named volume can be propagated to replicas of that mount. Consider a mount point <code class="highlighter-rouge">/mnt</code>, which is also mounted on <code class="highlighter-rouge">/tmp</code>. The propation settings control whether a mount on <code class="highlighter-rouge">/tmp/a</code> would also be available on <code class="highlighter-rouge">/mnt/a</code>. Each propagation setting has a recursive counterpoint. In the case of recursion, consider that <code class="highlighter-rouge">/tmp/a</code> is also mounted as <code class="highlighter-rouge">/foo</code>. The propagation settings control whether <code class="highlighter-rouge">/mnt/a</code> and/or <code class="highlighter-rouge">/tmp/a</code> would exist.</p> <p>The <code class="highlighter-rouge">bind-propagation</code> option defaults to <code class="highlighter-rouge">rprivate</code> for both bind-mounts and volume mounts, and is only configurable for bind-mounts. In other words, named volumes do not support bind propagation.</p> <ul> <li>
<strong><code class="highlighter-rouge">shared</code></strong>: Sub-mounts of the original mount are exposed to replica mounts, and sub-mounts of replica mounts are also propagated to the original mount.</li> <li>
<strong><code class="highlighter-rouge">slave</code></strong>: similar to a shared mount, but only in one direction. If the original mount exposes a sub-mount, the replica mount can see it. However, if the replica mount exposes a sub-mount, the original mount cannot see it.</li> <li>
<strong><code class="highlighter-rouge">private</code></strong>: The mount is private. Sub-mounts within it are not exposed to replica mounts, and sub-mounts of replica mounts are not exposed to the original mount.</li> <li>
<strong><code class="highlighter-rouge">rshared</code></strong>: The same as shared, but the propagation also extends to and from mount points nested within any of the original or replica mount points.</li> <li>
<strong><code class="highlighter-rouge">rslave</code></strong>: The same as <code class="highlighter-rouge">slave</code>, but the propagation also extends to and from mount points nested within any of the original or replica mount points.</li> <li>
<strong><code class="highlighter-rouge">rprivate</code></strong>: The default. The same as <code class="highlighter-rouge">private</code>, meaning that no mount points anywhere within the original or replica mount points propagate in either direction.</li> </ul> <p>For more information about bind propagation, see the <a href="https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt" target="_blank">Linux kernel documentation for shared subtree</a>.</p> <h4 id="options-for-named-volumes">Options for Named Volumes</h4> <p>The following options can only be used for named volumes (<code class="highlighter-rouge">type=volume</code>);</p> <table> <tr> <th>Option</th> <th>Description</th> </tr> <tr> <td><b>volume-driver</b></td> <td> <p>Name of the volume-driver plugin to use for the volume. Defaults to <tt>"local"</tt>, to use the local volume driver to create the volume if the volume does not exist.</p> </td> </tr> <tr> <td><b>volume-label</b></td> <td> One or more custom metadata ("labels") to apply to the volume upon creation. For example, `volume-label=mylabel=hello-world,my-other-label=hello-mars`. For more information about labels, refer to <a href="../../../userguide/labels-custom-metadata/">apply custom metadata</a>. </td> </tr> <tr> <td><b>volume-nocopy</b></td> <td> By default, if you attach an empty volume to a container, and files or directories already existed at the mount-path in the container (<tt>dst</tt>), the Engine copies those files and directories into the volume, allowing the host to access them. Set `volume-nocopy` to disables copying files from the container's filesystem to the volume and mount the empty volume. A value is optional: <ul> <li>
<tt>true</tt> or <tt>1</tt>: Default if you do not provide a value. Disables copying.</li> <li>
<tt>false</tt> or <tt>0</tt>: Enables copying.</li> </ul> </td> </tr> <tr> <td><b>volume-opt</b></td> <td> Options specific to a given volume driver, which will be passed to the driver when creating the volume. Options are provided as a comma-separated list of key/value pairs, for example, <tt>volume-opt=some-option=some-value,volume-opt=some-other-option=some-other-value</tt>. For available options for a given driver, refer to that driver's documentation. </td> </tr> </table> <h4 id="options-for-tmpfs">Options for tmpfs</h4> <p>The following options can only be used for tmpfs mounts (<code class="highlighter-rouge">type=tmpfs</code>);</p> <table> <tr> <th>Option</th> <th>Description</th> </tr> <tr> <td><b>tmpfs-size</b></td> <td>Size of the tmpfs mount in bytes. Unlimited by default in Linux.</td> </tr> <tr> <td><b>tmpfs-mode</b></td> <td>File mode of the tmpfs in octal. (e.g. <tt>"700"</tt> or <tt>"0700"</tt>.) Defaults to <tt>"1777"</tt> in Linux.</td> </tr> </table> <h4 id="differences-between-mount-and-volume">Differences between “–mount” and “–volume”</h4> <p>The <code class="highlighter-rouge">--mount</code> flag supports most options that are supported by the <code class="highlighter-rouge">-v</code> or <code class="highlighter-rouge">--volume</code> flag for <code class="highlighter-rouge">docker run</code>, with some important exceptions:</p> <ul> <li> <p>The <code class="highlighter-rouge">--mount</code> flag allows you to specify a volume driver and volume driver options <em>per volume</em>, without creating the volumes in advance. In contrast, <code class="highlighter-rouge">docker run</code> allows you to specify a single volume driver which is shared by all volumes, using the <code class="highlighter-rouge">--volume-driver</code> flag.</p> </li> <li> <p>The <code class="highlighter-rouge">--mount</code> flag allows you to specify custom metadata (“labels”) for a volume, before the volume is created.</p> </li> <li> <p>When you use <code class="highlighter-rouge">--mount</code> with <code class="highlighter-rouge">type=bind</code>, the host-path must refer to an <em>existing</em> path on the host. The path will not be created for you and the service will fail with an error if the path does not exist.</p> </li> <li> <p>The <code class="highlighter-rouge">--mount</code> flag does not allow you to relabel a volume with <code class="highlighter-rouge">Z</code> or <code class="highlighter-rouge">z</code> flags, which are used for <code class="highlighter-rouge">selinux</code> labeling.</p> </li> </ul> <h4 id="create-a-service-using-a-named-volume">Create a service using a named volume</h4> <p>The following example creates a service that uses a named volume:</p> <pre class="highlight" data-language="bash">$ docker service create \
  --name my-service \
  --replicas 3 \
  --mount type=volume,source=my-volume,destination=/path/in/container,volume-label="color=red",volume-label="shape=round" \
  nginx:alpine
</pre>  <p>For each replica of the service, the engine requests a volume named “my-volume” from the default (“local”) volume driver where the task is deployed. If the volume does not exist, the engine creates a new volume and applies the “color” and “shape” labels.</p> <p>When the task is started, the volume is mounted on <code class="highlighter-rouge">/path/in/container/</code> inside the container.</p> <p>Be aware that the default (“local”) volume is a locally scoped volume driver. This means that depending on where a task is deployed, either that task gets a <em>new</em> volume named “my-volume”, or shares the same “my-volume” with other tasks of the same service. Multiple containers writing to a single shared volume can cause data corruption if the software running inside the container is not designed to handle concurrent processes writing to the same location. Also take into account that containers can be re-scheduled by the Swarm orchestrator and be deployed on a different node.</p> <h4 id="create-a-service-that-uses-an-anonymous-volume">Create a service that uses an anonymous volume</h4> <p>The following command creates a service with three replicas with an anonymous volume on <code class="highlighter-rouge">/path/in/container</code>:</p> <pre class="highlight" data-language="bash">$ docker service create \
  --name my-service \
  --replicas 3 \
  --mount type=volume,destination=/path/in/container \
  nginx:alpine
</pre>  <p>In this example, no name (<code class="highlighter-rouge">source</code>) is specified for the volume, so a new volume is created for each task. This guarantees that each task gets its own volume, and volumes are not shared between tasks. Anonymous volumes are removed after the task using them is complete.</p> <h4 id="create-a-service-that-uses-a-bind-mounted-host-directory">Create a service that uses a bind-mounted host directory</h4> <p>The following example bind-mounts a host directory at <code class="highlighter-rouge">/path/in/container</code> in the containers backing the service:</p> <pre class="highlight" data-language="bash">$ docker service create \
  --name my-service \
  --mount type=bind,source=/path/on/host,destination=/path/in/container \
  nginx:alpine
</pre>  <h3 id="set-service-mode-mode">Set service mode (–mode)</h3> <p>The service mode determines whether this is a <em>replicated</em> service or a <em>global</em> service. A replicated service runs as many tasks as specified, while a global service runs on each active node in the swarm.</p> <p>The following command creates a global service:</p> <pre class="highlight" data-language="bash">$ docker service create \
 --name redis_2 \
 --mode global \
 redis:3.0.6
</pre>  <h3 id="specify-service-constraints-constraint">Specify service constraints (–constraint)</h3> <p>You can limit the set of nodes where a task can be scheduled by defining constraint expressions. Multiple constraints find nodes that satisfy every expression (AND match). Constraints can match node or Docker Engine labels as follows:</p> <table> <tr> <th>node attribute</th> <th>matches</th> <th>example</th> </tr> <tr> <td><tt>node.id</tt></td> <td>Node ID</td> <td><tt>node.id == 2ivku8v2gvtg4</tt></td> </tr> <tr> <td><tt>node.hostname</tt></td> <td>Node hostname</td> <td><tt>node.hostname != node-2</tt></td> </tr> <tr> <td><tt>node.role</tt></td> <td>Node role</td> <td><tt>node.role == manager</tt></td> </tr> <tr> <td><tt>node.labels</tt></td> <td>user defined node labels</td> <td><tt>node.labels.security == high</tt></td> </tr> <tr> <td><tt>engine.labels</tt></td> <td>Docker Engine's labels</td> <td><tt>engine.labels.operatingsystem == ubuntu 14.04</tt></td> </tr> </table> <p><code class="highlighter-rouge">engine.labels</code> apply to Docker Engine labels like operating system, drivers, etc. Swarm administrators add <code class="highlighter-rouge">node.labels</code> for operational purposes by using the <a href="../node_update/"><code class="highlighter-rouge">docker node update</code></a> command.</p> <p>For example, the following limits tasks for the redis service to nodes where the node type label equals queue:</p> <pre class="highlight" data-language="bash">$ docker service create \
  --name redis_2 \
  --constraint 'node.labels.type == queue' \
  redis:3.0.6
</pre>  <h3 id="specify-service-placement-preferences-placement-pref">Specify service placement preferences (–placement-pref)</h3> <p>You can set up the service to divide tasks evenly over different categories of nodes. One example of where this can be useful is to balance tasks over a set of datacenters or availability zones. The example below illustrates this:</p> <pre class="highlight" data-language="bash">$ docker service create \
  --replicas 9 \
  --name redis_2 \
  --placement-pref 'spread=node.labels.datacenter' \
  redis:3.0.6
</pre>  <p>This uses <code class="highlighter-rouge">--placement-pref</code> with a <code class="highlighter-rouge">spread</code> strategy (currently the only supported strategy) to spread tasks evenly over the values of the <code class="highlighter-rouge">datacenter</code> node label. In this example, we assume that every node has a <code class="highlighter-rouge">datacenter</code> node label attached to it. If there are three different values of this label among nodes in the swarm, one third of the tasks will be placed on the nodes associated with each value. This is true even if there are more nodes with one value than another. For example, consider the following set of nodes:</p> <ul> <li>Three nodes with <code class="highlighter-rouge">node.labels.datacenter=east</code>
</li> <li>Two nodes with <code class="highlighter-rouge">node.labels.datacenter=south</code>
</li> <li>One node with <code class="highlighter-rouge">node.labels.datacenter=west</code>
</li> </ul> <p>Since we are spreading over the values of the <code class="highlighter-rouge">datacenter</code> label and the service has 9 replicas, 3 replicas will end up in each datacenter. There are three nodes associated with the value <code class="highlighter-rouge">east</code>, so each one will get one of the three replicas reserved for this value. There are two nodes with the value <code class="highlighter-rouge">south</code>, and the three replicas for this value will be divided between them, with one receiving two replicas and another receiving just one. Finally, <code class="highlighter-rouge">west</code> has a single node that will get all three replicas reserved for <code class="highlighter-rouge">west</code>.</p> <p>If the nodes in one category (for example, those with <code class="highlighter-rouge">node.labels.datacenter=south</code>) can’t handle their fair share of tasks due to constraints or resource limitations, the extra tasks will be assigned to other nodes instead, if possible.</p> <p>Both engine labels and node labels are supported by placement preferences. The example above uses a node label, because the label is referenced with <code class="highlighter-rouge">node.labels.datacenter</code>. To spread over the values of an engine label, use <code class="highlighter-rouge">--placement-pref spread=engine.labels.&lt;labelname&gt;</code>.</p> <p>It is possible to add multiple placement preferences to a service. This establishes a hierarchy of preferences, so that tasks are first divided over one category, and then further divided over additional categories. One example of where this may be useful is dividing tasks fairly between datacenters, and then splitting the tasks within each datacenter over a choice of racks. To add multiple placement preferences, specify the <code class="highlighter-rouge">--placement-pref</code> flag multiple times. The order is significant, and the placement preferences will be applied in the order given when making scheduling decisions.</p> <p>The following example sets up a service with multiple placement preferences. Tasks are spread first over the various datacenters, and then over racks (as indicated by the respective labels):</p> <pre class="highlight" data-language="bash">$ docker service create \
  --replicas 9 \
  --name redis_2 \
  --placement-pref 'spread=node.labels.datacenter' \
  --placement-pref 'spread=node.labels.rack' \
  redis:3.0.6
</pre>  <p>When updating a service with <code class="highlighter-rouge">docker service update</code>, <code class="highlighter-rouge">--placement-pref-add</code> appends a new placement preference after all existing placement preferences. <code class="highlighter-rouge">--placement-pref-rm</code> removes an existing placement preference that matches the argument.</p> <h3 id="attach-a-service-to-an-existing-network-network">Attach a service to an existing network (–network)</h3> <p>You can use overlay networks to connect one or more services within the swarm.</p> <p>First, create an overlay network on a manager node the docker network create command:</p> <pre class="highlight" data-language="bash">$ docker network create --driver overlay my-network

etjpu59cykrptrgw0z0hk5snf
</pre>  <p>After you create an overlay network in swarm mode, all manager nodes have access to the network.</p> <p>When you create a service and pass the –network flag to attach the service to the overlay network:</p> <pre class="highlight" data-language="bash">$ docker service create \
  --replicas 3 \
  --network my-network \
  --name my-web \
  nginx

716thylsndqma81j6kkkb5aus
</pre>  <p>The swarm extends my-network to each node running the service.</p> <p>Containers on the same network can access each other using <a href="../../../swarm/networking/#use-swarm-mode-service-discovery">service discovery</a>.</p> <h3 id="publish-service-ports-externally-to-the-swarm--p-publish">Publish service ports externally to the swarm (-p, –publish)</h3> <p>You can publish service ports to make them available externally to the swarm using the <code class="highlighter-rouge">--publish</code> flag:</p> <pre class="highlight" data-language="bash">$ docker service create --publish &lt;TARGET-PORT&gt;:&lt;SERVICE-PORT&gt; nginx
</pre>  <p>For example:</p> <pre class="highlight" data-language="bash">$ docker service create --name my_web --replicas 3 --publish 8080:80 nginx
</pre>  <p>When you publish a service port, the swarm routing mesh makes the service accessible at the target port on every node regardless if there is a task for the service running on the node. For more information refer to <a href="../../../swarm/ingress/">Use swarm mode routing mesh</a>.</p> <h3 id="publish-a-port-for-tcp-only-or-udp-only">Publish a port for TCP only or UDP only</h3> <p>By default, when you publish a port, it is a TCP port. You can specifically publish a UDP port instead of or in addition to a TCP port. When you publish both TCP and UDP ports, Docker 1.12.2 and earlier require you to add the suffix <code class="highlighter-rouge">/tcp</code> for TCP ports. Otherwise it is optional.</p> <h4 id="tcp-only">TCP only</h4> <p>The following two commands are equivalent.</p> <pre class="highlight" data-language="bash">$ docker service create --name dns-cache -p 53:53 dns-cache

$ docker service create --name dns-cache -p 53:53/tcp dns-cache
</pre>  <h4 id="tcp-and-udp">TCP and UDP</h4> <pre class="highlight" data-language="bash">$ docker service create --name dns-cache -p 53:53/tcp -p 53:53/udp dns-cache
</pre>  <h4 id="udp-only">UDP only</h4> <pre class="highlight" data-language="bash">$ docker service create --name dns-cache -p 53:53/udp dns-cache
</pre>  <h3 id="provide-credential-specs-for-managed-service-accounts-windows-only">Provide credential specs for managed service accounts (Windows only)</h3> <p>This option is only used for services using Windows containers. The <code class="highlighter-rouge">--credential-spec</code> must be in the format <code class="highlighter-rouge">file://&lt;filename&gt;</code> or <code class="highlighter-rouge">registry://&lt;value-name&gt;</code>.</p> <p>When using the <code class="highlighter-rouge">file://&lt;filename&gt;</code> format, the referenced file must be present in the <code class="highlighter-rouge">CredentialSpecs</code> subdirectory in the docker data directory, which defaults to <code class="highlighter-rouge">C:\ProgramData\Docker\</code> on Windows. For example, specifying <code class="highlighter-rouge">file://spec.json</code> loads <code class="highlighter-rouge">C:\ProgramData\Docker\CredentialSpecs\spec.json</code>.</p> <p>When using the <code class="highlighter-rouge">registry://&lt;value-name&gt;</code> format, the credential spec is read from the Windows registry on the daemon’s host. The specified registry value must be located in:</p> <pre class="highlight" data-language="">HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\Containers\CredentialSpecs
</pre>  <h3 id="create-services-using-templates">Create services using templates</h3> <p>You can use templates for some flags of <code class="highlighter-rouge">service create</code>, using the syntax provided by the Go’s <a href="http://golang.org/pkg/text/template/" target="_blank">text/template</a> package.</p> <p>The supported flags are the following :</p> <ul> <li><code class="highlighter-rouge">--hostname</code></li> <li><code class="highlighter-rouge">--mount</code></li> <li><code class="highlighter-rouge">--env</code></li> </ul> <p>Valid placeholders for the Go template are listed below:</p> <table> <tr> <th>Placeholder</th> <th>Description</th> </tr> <tr> <td><tt>.Service.ID</tt></td> <td>Service ID</td> </tr> <tr> <td><tt>.Service.Name</tt></td> <td>Service name</td> </tr> <tr> <td><tt>.Service.Labels</tt></td> <td>Service labels</td> </tr> <tr> <td><tt>.Node.ID</tt></td> <td>Node ID</td> </tr> <tr> <td><tt>.Task.ID</tt></td> <td>Task ID</td> </tr> <tr> <td><tt>.Task.Name</tt></td> <td>Task name</td> </tr> <tr> <td><tt>.Task.Slot</tt></td> <td>Task slot</td> </tr> </table> <h4 id="template-example">Template example</h4> <p>In this example, we are going to set the template of the created containers based on the service’s name and the node’s ID where it sits.</p> <pre class="highlight" data-language="bash">$ docker service create --name hosttempl \
                        --hostname="{{.Node.ID}}-{{.Service.Name}}"\
                         busybox top

va8ew30grofhjoychbr6iot8c

$ docker service ps va8ew30grofhjoychbr6iot8c

ID            NAME         IMAGE                                                                                   NODE          DESIRED STATE  CURRENT STATE               ERROR  PORTS
wo41w8hg8qan  hosttempl.1  busybox:latest@sha256:29f5d56d12684887bdfa50dcd29fc31eea4aaf4ad3bec43daf19026a7ce69912  2e7a8a9c4da2  Running        Running about a minute ago

$ docker inspect --format="{{.Config.Hostname}}" hosttempl.1.wo41w8hg8qanxwjwsg4kxpprj

x3ti0erg11rjpg64m75kej2mz-hosttempl
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2017 Docker, Inc.<br>Licensed under the Apache License, Version 2.0.<br>Docker and the Docker logo are trademarks or registered trademarks of Docker, Inc. in the United States and/or other countries.<br>Docker, Inc. and other parties may also have trademark rights in other terms used herein.<br>
    <a href="https://docs.docker.com/engine/reference/commandline/service_create/" class="_attribution-link" target="_blank">https://docs.docker.com/engine/reference/commandline/service_create/</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
