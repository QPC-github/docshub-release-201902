
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Mask - Pygame - W3cubDocs</title>
  
  <meta name="description" content=" Useful for fast pixel perfect collision detection. A mask uses 1 bit per-pixel to store which parts collide. ">
  <meta name="keywords" content="pygame, mask, -">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/pygame/ref/mask/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/pygame.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/pygame/" class="_nav-link" title="" style="margin-left:0;">Pygame</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _simple">
				
				
<h1 class="title module" data-name="pygame.mask"> <span class="pre">pygame.mask</span>
</h1> <blockquote class="line-block"> <div class="line"><span class="summaryline">pygame module for image masks.</span></div> </blockquote>  <p>Useful for fast pixel perfect collision detection. A mask uses 1 bit per-pixel to store which parts collide.</p> <p>New in pygame 1.8.</p> <dl class="definition function"> <h3 class="title" id="pygame.mask.from_surface" data-name="pygame.mask.from_surface()">
<code class="signature">pygame.mask.from_surface(Surface, threshold = 127) -&gt; Mask</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns a Mask from the given surface.</span></div>  </blockquote> <p>Makes the transparent parts of the Surface not set, and the opaque parts set.</p> <p>The alpha of each pixel is checked to see if it is greater than the given threshold.</p> <p>If the Surface is color-keyed, then threshold is not used.</p> </dd>
</dl> <dl class="definition function"> <h3 class="title" id="pygame.mask.from_threshold" data-name="pygame.mask.from_threshold()">
<code class="signature">pygame.mask.from_threshold(Surface, color, threshold = (0,0,0,255), othersurface = None, palette_colors = 1) -&gt; Mask</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Creates a mask by thresholding Surfaces</span></div>  </blockquote> <p>This is a more-featureful method of getting a Mask from a Surface. If supplied with only one Surface, all pixels within the threshold of the supplied color are set in the Mask. If given the optional othersurface, all pixels in Surface that are within the threshold of the corresponding pixel in othersurface are set in the Mask.</p> </dd>
</dl> <dl class="definition class"> <h1 class="title" id="pygame.mask.Mask" data-name="pygame.mask.Mask"> pygame.mask.Mask</h1> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">pygame object for representing 2d bitmasks</span></div> <div class="line"><code class="signature">Mask((width, height)) -&gt; Mask</code></div> </blockquote>  <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.get_size" data-name="get_size()">
<code class="signature">get_size() -&gt; width,height</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns the size of the mask.</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.get_at" data-name="get_at()">
<code class="signature">get_at((x,y)) -&gt; int</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns nonzero if the bit at (x,y) is set.</span></div>  </blockquote> <p>Coordinates start at (0,0) is top left - just like Surfaces.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.set_at" data-name="set_at()">
<code class="signature">set_at((x,y),value) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Sets the position in the mask given by x and y.</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.overlap" data-name="overlap()">
<code class="signature">overlap(othermask, offset) -&gt; x,y</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns the point of intersection if the masks overlap with the given offset - or None if it does not overlap.</span></div>  </blockquote> <p>The overlap tests uses the following offsets (which may be negative):</p> <pre class="language-python" data-language="python">+----+----------..
|A   | yoffset
|  +-+----------..
+--|B
|xoffset
|  |
:  :
</pre> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.overlap_area" data-name="overlap_area()">
<code class="signature">overlap_area(othermask, offset) -&gt; numpixels</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns the number of overlapping 'pixels'.</span></div>  </blockquote> <p>You can see how many pixels overlap with the other mask given. This can be used to see in which direction things collide, or to see how much the two masks collide. An approximate collision normal can be found by calculating the gradient of the overlap area through the finite difference.</p> <pre class="language-python" data-language="python">dx = Mask.overlap_area(othermask,(x+1,y)) - Mask.overlap_area(othermask,(x-1,y))
dy = Mask.overlap_area(othermask,(x,y+1)) - Mask.overlap_area(othermask,(x,y-1))
</pre> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.overlap_mask" data-name="overlap_mask()">
<code class="signature">overlap_mask(othermask, offset) -&gt; Mask</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns a mask of the overlapping pixels</span></div>  </blockquote> <p>Returns a Mask the size of the original Mask containing only the overlapping pixels between Mask and othermask.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.fill" data-name="fill()">
<code class="signature">fill() -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Sets all bits to 1</span></div>  </blockquote> <p>Sets all bits in a Mask to 1.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.clear" data-name="clear()">
<code class="signature">clear() -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Sets all bits to 0</span></div>  </blockquote> <p>Sets all bits in a Mask to 0.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.invert" data-name="invert()">
<code class="signature">invert() -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Flips the bits in a Mask</span></div>  </blockquote> <p>Flips all of the bits in a Mask, so that the set pixels turn to unset pixels and the unset pixels turn to set pixels.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.scale" data-name="scale()">
<code class="signature">scale((x, y)) -&gt; Mask</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Resizes a mask</span></div>  </blockquote> <p>Returns a new Mask of the Mask scaled to the requested size.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.draw" data-name="draw()">
<code class="signature">draw(othermask, offset) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Draws a mask onto another</span></div>  </blockquote> <p>Performs a bitwise <code class="docutils literal notranslate"><span class="pre">OR</span></code>, drawing othermask onto Mask.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.erase" data-name="erase()">
<code class="signature">erase(othermask, offset) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Erases a mask from another</span></div>  </blockquote> <p>Erases all pixels set in othermask from Mask.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.count" data-name="count()">
<code class="signature">count() -&gt; pixels</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns the number of set pixels</span></div>  </blockquote> <p>Returns the number of set pixels in the Mask.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.centroid" data-name="centroid()">
<code class="signature">centroid() -&gt; (x, y)</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns the centroid of the pixels in a Mask</span></div>  </blockquote> <p>Finds the centroid, the center of pixel mass, of a Mask. Returns a coordinate tuple for the centroid of the Mask. In the event the Mask is empty, it will return (0,0).</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.angle" data-name="angle()">
<code class="signature">angle() -&gt; theta</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns the orientation of the pixels</span></div>  </blockquote> <p>Finds the approximate orientation of the pixels in the image from -90 to 90 degrees. This works best if performed on one connected component of pixels. It will return 0.0 on an empty Mask.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.outline" data-name="outline()">
<code class="signature">outline(every = 1) -&gt; [(x,y), (x,y) ...]</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">list of points outlining an object</span></div>  </blockquote> <p>Returns a list of points of the outline of the first object it comes across in a Mask. For this to be useful, there should probably only be one connected component of pixels in the Mask. The every option allows you to skip pixels in the outline. For example, setting it to 10 would return a list of every 10th pixel in the outline.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.convolve" data-name="convolve()">
<code class="signature">convolve(othermask, outputmask = None, offset = (0,0)) -&gt; Mask</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Return the convolution of self with another mask.</span></div>  </blockquote> <p>Returns a mask with the (i-offset[0],j-offset[1]) bit set if shifting othermask so that its lower right corner pixel is at (i,j) would cause it to overlap with self.</p> <p>If an outputmask is specified, the output is drawn onto outputmask and outputmask is returned. Otherwise a mask of size <code class="docutils literal notranslate"><span class="pre">self.get_size()</span></code> + <code class="docutils literal notranslate"><span class="pre">othermask.get_size()</span></code> - (1,1) is created.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.connected_component" data-name="connected_component()">
<code class="signature">connected_component((x,y) = None) -&gt; Mask</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns a mask of a connected region of pixels.</span></div>  </blockquote> <p>This uses the <code class="docutils literal notranslate"><span class="pre">SAUF</span></code> algorithm to find a connected component in the Mask. It checks 8 point connectivity. By default, it will return the largest connected component in the image. Optionally, a coordinate pair of a pixel can be specified, and the connected component containing it will be returned. In the event the pixel at that location is not set, the returned Mask will be empty. The Mask returned is the same size as the original Mask.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.connected_components" data-name="connected_components()">
<code class="signature">connected_components(min = 0) -&gt; [Masks]</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns a list of masks of connected regions of pixels.</span></div>  </blockquote> <p>Returns a list of masks of connected regions of pixels. An optional minimum number of pixels per connected region can be specified to filter out noise.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.mask.Mask.get_bounding_rects" data-name="get_bounding_rects()">
<code class="signature">get_bounding_rects() -&gt; Rects</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Returns a list of bounding rects of regions of set pixels.</span></div>  </blockquote> <p>This gets a bounding rect of connected regions of set pixels. A bounding rect is one for which each of the connected pixels is inside the rect.</p> </dd>
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © Pygame Developpers.<br>Licensed under the GNU LGPL License version 2.1.<br>
    <a href="https://www.pygame.org/docs/ref/mask.html" class="_attribution-link" target="_blank">https://www.pygame.org/docs/ref/mask.html</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
