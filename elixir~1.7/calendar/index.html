
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Calendar - Elixir 1.7 - W3cubDocs</title>
  
  <meta name="description" content=" This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir. ">
  <meta name="keywords" content="calendar, summary, types, functions, callbacks, -, elixir, elixir~1.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.7/calendar/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/elixir~1.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.7/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.7</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
				
<h1>  Calendar <small>behaviour</small>  </h1>  <p>This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir.</p> <p>Currently it defines types and the minimal implementation for a calendar behaviour in Elixir. The goal of the Calendar features in Elixir is to provide a base for interoperability instead of full-featured datetime API.</p> <p>For the actual date, time and datetime structures, see <a href="../date/"><code class="inline">Date</code></a>, <a href="../time/"><code class="inline">Time</code></a>, <a href="../naivedatetime/"><code class="inline">NaiveDateTime</code></a> and <a href="../datetime/"><code class="inline">DateTime</code></a>.</p> <p>Note the year, month, day, etc. designations are overspecified (i.e. an integer instead of <code class="inline">1..12</code> for months) because different calendars may have a different number of days per month, months per year and so on.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:calendar/0">calendar()</a> </dt> <dd class="summary-synopsis">
<p>A calendar implementation</p> </dd>   <dt class="summary-signature"> <a href="#t:date/0">date()</a> </dt> <dd class="summary-synopsis">
<p>Any map/struct that contains the date fields</p> </dd>   <dt class="summary-signature"> <a href="#t:datetime/0">datetime()</a> </dt> <dd class="summary-synopsis">
<p>Any map/struct that contains the datetime fields</p> </dd>   <dt class="summary-signature"> <a href="#t:day/0">day()</a> </dt>   <dt class="summary-signature"> <a href="#t:day_fraction/0">day_fraction()</a> </dt> <dd class="summary-synopsis">
<p>The internal time format is used when converting between calendars</p> </dd>   <dt class="summary-signature"> <a href="#t:hour/0">hour()</a> </dt>   <dt class="summary-signature"> <a href="#t:iso_days/0">iso_days()</a> </dt> <dd class="summary-synopsis">
<p>The internal date format that is used when converting between calendars</p> </dd>   <dt class="summary-signature"> <a href="#t:microsecond/0">microsecond()</a> </dt> <dd class="summary-synopsis">
<p>Microseconds with stored precision</p> </dd>   <dt class="summary-signature"> <a href="#t:minute/0">minute()</a> </dt>   <dt class="summary-signature"> <a href="#t:month/0">month()</a> </dt>   <dt class="summary-signature"> <a href="#t:naive_datetime/0">naive_datetime()</a> </dt> <dd class="summary-synopsis">
<p>Any map/struct that contains the naive_datetime fields</p> </dd>   <dt class="summary-signature"> <a href="#t:second/0">second()</a> </dt>   <dt class="summary-signature"> <a href="#t:std_offset/0">std_offset()</a> </dt> <dd class="summary-synopsis">
<p>The time zone standard offset in seconds (not zero in summer times)</p> </dd>   <dt class="summary-signature"> <a href="#t:time/0">time()</a> </dt> <dd class="summary-synopsis">
<p>Any map/struct that contains the time fields</p> </dd>   <dt class="summary-signature"> <a href="#t:time_zone/0">time_zone()</a> </dt> <dd class="summary-synopsis">
<p>The time zone ID according to the IANA tz database (e.g. Europe/Zurich)</p> </dd>   <dt class="summary-signature"> <a href="#t:utc_offset/0">utc_offset()</a> </dt> <dd class="summary-synopsis">
<p>The time zone UTC offset in seconds</p> </dd>   <dt class="summary-signature"> <a href="#t:year/0">year()</a> </dt>   <dt class="summary-signature"> <a href="#t:zone_abbr/0">zone_abbr()</a> </dt> <dd class="summary-synopsis">
<p>The time zone abbreviation (e.g. CET or CEST or BST etc.)</p> </dd>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#compatible_calendars?/2">compatible_calendars?(calendar, calendar)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if two calendars have the same moment of starting a new day, <code class="inline">false</code> otherwise</p> </dd>   <dt class="summary-signature"> <a href="#truncate/2">truncate(microsecond_tuple, atom)</a> </dt> <dd class="summary-synopsis">
<p>Returns a microsecond tuple truncated to a given precision (<code class="inline">:microsecond</code>, <code class="inline">:millisecond</code> or <code class="inline">:second</code>)</p> </dd>  </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">   <dt class="summary-signature"> <a href="#c:date_to_string/3">date_to_string(year, month, day)</a> </dt> <dd class="summary-synopsis">
<p>Converts the date into a string according to the calendar</p> </dd>   <dt class="summary-signature"> <a href="#c:datetime_to_string/11">datetime_to_string(year, month, day, hour, minute, second, microsecond, time_zone, zone_abbr, utc_offset, std_offset)</a> </dt> <dd class="summary-synopsis">
<p>Converts the datetime (with time zone) into a string according to the calendar</p> </dd>   <dt class="summary-signature"> <a href="#c:day_of_week/3">day_of_week(year, month, day)</a> </dt> <dd class="summary-synopsis">
<p>Calculates the day of the week from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code></p> </dd>   <dt class="summary-signature"> <a href="#c:day_rollover_relative_to_midnight_utc/0">day_rollover_relative_to_midnight_utc()</a> </dt> <dd class="summary-synopsis">
<p>Define the rollover moment for the given calendar</p> </dd>   <dt class="summary-signature"> <a href="#c:days_in_month/2">days_in_month(year, month)</a> </dt> <dd class="summary-synopsis">
<p>Returns how many days there are in the given year-month</p> </dd>   <dt class="summary-signature"> <a href="#c:leap_year?/1">leap_year?(year)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if the given year is a leap year</p> </dd>   <dt class="summary-signature"> <a href="#c:months_in_year/1">months_in_year(year)</a> </dt> <dd class="summary-synopsis">
<p>Returns how many months there are in the given year</p> </dd>   <dt class="summary-signature"> <a href="#c:naive_datetime_from_iso_days/1">naive_datetime_from_iso_days(iso_days)</a> </dt> <dd class="summary-synopsis">
<p>Converts <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> to the Calendarâ€™s datetime format</p> </dd>   <dt class="summary-signature"> <a href="#c:naive_datetime_to_iso_days/7">naive_datetime_to_iso_days(year, month, day, hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis">
<p>Converts the given datetime (with time zone) into the <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> format</p> </dd>   <dt class="summary-signature"> <a href="#c:naive_datetime_to_string/7">naive_datetime_to_string(year, month, day, hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis">
<p>Converts the datetime (without time zone) into a string according to the calendar</p> </dd>   <dt class="summary-signature"> <a href="#c:time_from_day_fraction/1">time_from_day_fraction(day_fraction)</a> </dt> <dd class="summary-synopsis">
<p>Converts <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> to the Calendarâ€™s time format</p> </dd>   <dt class="summary-signature"> <a href="#c:time_to_day_fraction/4">time_to_day_fraction(hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis">
<p>Converts the given time to the <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> format</p> </dd>   <dt class="summary-signature"> <a href="#c:time_to_string/4">time_to_string(hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis">
<p>Converts the time into a string according to the calendar</p> </dd>   <dt class="summary-signature"> <a href="#c:valid_date?/3">valid_date?(year, month, day)</a> </dt> <dd class="summary-synopsis">
<p>Should return <code class="inline">true</code> if the given date describes a proper date in the calendar</p> </dd>   <dt class="summary-signature"> <a href="#c:valid_time?/4">valid_time?(hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis">
<p>Should return <code class="inline">true</code> if the given time describes a proper time in the calendar</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:calendar/0">  <span class="signature">calendar()</span>     </h3>
<pre data-language="elixir">calendar() :: module()</pre>  <p>A calendar implementation</p>    <h3 class="detail-header type" id="t:date/0">  <span class="signature">date()</span>     </h3>
<pre data-language="elixir">date() :: %{
  optional(any()) =&gt; any(),
  :calendar =&gt; calendar(),
  :year =&gt; year(),
  :month =&gt; month(),
  :day =&gt; day()
}</pre>  <p>Any map/struct that contains the date fields</p>    <h3 class="detail-header type" id="t:datetime/0">  <span class="signature">datetime()</span>     </h3>
<pre data-language="elixir">datetime() :: %{
  optional(any()) =&gt; any(),
  :calendar =&gt; calendar(),
  :year =&gt; year(),
  :month =&gt; month(),
  :day =&gt; day(),
  :hour =&gt; hour(),
  :minute =&gt; minute(),
  :second =&gt; second(),
  :microsecond =&gt; microsecond(),
  :time_zone =&gt; time_zone(),
  :zone_abbr =&gt; zone_abbr(),
  :utc_offset =&gt; utc_offset(),
  :std_offset =&gt; std_offset()
}</pre>  <p>Any map/struct that contains the datetime fields</p>    <h3 class="detail-header type" id="t:day/0">  <span class="signature">day()</span>     </h3>
<pre data-language="elixir">day() :: integer()</pre>     <h3 class="detail-header type" id="t:day_fraction/0">  <span class="signature">day_fraction()</span>     </h3>
<pre data-language="elixir">day_fraction() ::
  {parts_in_day :: non_neg_integer(), parts_per_day :: pos_integer()}</pre>  <p>The internal time format is used when converting between calendars.</p> <p>It represents time as a fraction of a day (starting from midnight). <code class="inline">parts_in_day</code> specifies how much of the day is already passed, while <code class="inline">parts_per_day</code> signifies how many parts there fit in a day.</p>    <h3 class="detail-header type" id="t:hour/0">  <span class="signature">hour()</span>     </h3>
<pre data-language="elixir">hour() :: integer()</pre>     <h3 class="detail-header type" id="t:iso_days/0">  <span class="signature">iso_days()</span>     </h3>
<pre data-language="elixir">iso_days() :: {days :: integer(), day_fraction()}</pre>  <p>The internal date format that is used when converting between calendars.</p> <p>This is the number of days including the fractional part that has passed of the last day since 0000-01-01+00:00T00:00.00000 in ISO 8601 notation (also known as midnight 1 January BC 1 of the proleptic Gregorian calendar).</p> <p>The <code class="inline">parts_per_day</code> represent how many subparts the current day is subdivided in (for different calendars, picking a different <code class="inline">parts_per_day</code> might make sense). The <code class="inline">parts_in_day</code> represents how many of these <code class="inline">parts_per_day</code> have passed in the last day.</p>    <h3 class="detail-header type" id="t:microsecond/0">  <span class="signature">microsecond()</span>     </h3>
<pre data-language="elixir">microsecond() :: {0..999_999, 0..6}</pre>  <p>Microseconds with stored precision.</p> <p>The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.</p>    <h3 class="detail-header type" id="t:minute/0">  <span class="signature">minute()</span>     </h3>
<pre data-language="elixir">minute() :: integer()</pre>     <h3 class="detail-header type" id="t:month/0">  <span class="signature">month()</span>     </h3>
<pre data-language="elixir">month() :: integer()</pre>     <h3 class="detail-header type" id="t:naive_datetime/0">  <span class="signature">naive_datetime()</span>     </h3>
<pre data-language="elixir">naive_datetime() :: %{
  optional(any()) =&gt; any(),
  :calendar =&gt; calendar(),
  :year =&gt; year(),
  :month =&gt; month(),
  :day =&gt; day(),
  :hour =&gt; hour(),
  :minute =&gt; minute(),
  :second =&gt; second(),
  :microsecond =&gt; microsecond()
}</pre>  <p>Any map/struct that contains the naive_datetime fields</p>    <h3 class="detail-header type" id="t:second/0">  <span class="signature">second()</span>     </h3>
<pre data-language="elixir">second() :: integer()</pre>     <h3 class="detail-header type" id="t:std_offset/0">  <span class="signature">std_offset()</span>     </h3>
<pre data-language="elixir">std_offset() :: integer()</pre>  <p>The time zone standard offset in seconds (not zero in summer times)</p>    <h3 class="detail-header type" id="t:time/0">  <span class="signature">time()</span>     </h3>
<pre data-language="elixir">time() :: %{
  optional(any()) =&gt; any(),
  :hour =&gt; hour(),
  :minute =&gt; minute(),
  :second =&gt; second(),
  :microsecond =&gt; microsecond()
}</pre>  <p>Any map/struct that contains the time fields</p>    <h3 class="detail-header type" id="t:time_zone/0">  <span class="signature">time_zone()</span>     </h3>
<pre data-language="elixir">time_zone() :: String.t()</pre>  <p>The time zone ID according to the IANA tz database (e.g. Europe/Zurich)</p>    <h3 class="detail-header type" id="t:utc_offset/0">  <span class="signature">utc_offset()</span>     </h3>
<pre data-language="elixir">utc_offset() :: integer()</pre>  <p>The time zone UTC offset in seconds</p>    <h3 class="detail-header type" id="t:year/0">  <span class="signature">year()</span>     </h3>
<pre data-language="elixir">year() :: integer()</pre>     <h3 class="detail-header type" id="t:zone_abbr/0">  <span class="signature">zone_abbr()</span>     </h3>
<pre data-language="elixir">zone_abbr() :: String.t()</pre>  <p>The time zone abbreviation (e.g. CET or CEST or BST etc.)</p>      <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="compatible_calendars?/2">  <span class="signature">compatible_calendars?(calendar, calendar)</span>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">compatible_calendars?(Calendar.calendar(), Calendar.calendar()) :: boolean()</pre>  <p>Returns <code class="inline">true</code> if two calendars have the same moment of starting a new day, <code class="inline">false</code> otherwise.</p> <p>If two calendars are not compatible, we can only convert datetimes and times between them. If they are compatible, this means that we can also convert dates as well as naive datetimes between them.</p>    <h3 class="detail-header function" id="truncate/2">  <span class="signature">truncate(microsecond_tuple, atom)</span>  <span class="note">(since 1.6.0)</span>    </h3>
<pre data-language="elixir">truncate(Calendar.microsecond(), :microsecond | :millisecond | :second) ::
  Calendar.microsecond()</pre>  <p>Returns a microsecond tuple truncated to a given precision (<code class="inline">:microsecond</code>, <code class="inline">:millisecond</code> or <code class="inline">:second</code>).</p>     <h1 class="section-heading" id="callbacks">  Callbacks </h1>  <h3 class="detail-header callback" id="c:date_to_string/3">  <span class="signature">date_to_string(year, month, day)</span>     </h3>
<pre data-language="elixir">date_to_string(year(), month(), day()) :: String.t()</pre>  <p>Converts the date into a string according to the calendar.</p>    <h3 class="detail-header callback" id="c:datetime_to_string/11">  <span class="signature">datetime_to_string(year, month, day, hour, minute, second, microsecond, time_zone, zone_abbr, utc_offset, std_offset)</span>     </h3>
<pre data-language="elixir">datetime_to_string(
  year(),
  month(),
  day(),
  hour(),
  minute(),
  second(),
  microsecond(),
  time_zone(),
  zone_abbr(),
  utc_offset(),
  std_offset()
) :: String.t()</pre>  <p>Converts the datetime (with time zone) into a string according to the calendar.</p>    <h3 class="detail-header callback" id="c:day_of_week/3">  <span class="signature">day_of_week(year, month, day)</span>     </h3>
<pre data-language="elixir">day_of_week(year(), month(), day()) :: non_neg_integer()</pre>  <p>Calculates the day of the week from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p>    <h3 class="detail-header callback" id="c:day_rollover_relative_to_midnight_utc/0">  <span class="signature">day_rollover_relative_to_midnight_utc()</span>     </h3>
<pre data-language="elixir">day_rollover_relative_to_midnight_utc() :: day_fraction()</pre>  <p>Define the rollover moment for the given calendar.</p> <p>This is the moment, in your calendar, when the current day ends and the next day starts.</p> <p>The result of this function is used to check if two calendars rollover at the same time of day. If they do not, we can only convert datetimes and times between them. If they do, this means that we can also convert dates as well as naive datetimes between them.</p> <p>This day fraction should be in its most simplified form possible, to make comparisons fast.</p> <h4 id="c:day_rollover_relative_to_midnight_utc/0-examples" class="section-heading">  Examples </h4> <ul> <li>If, in your Calendar, a new day starts at midnight, return {0, 1}. </li> <li>If, in your Calendar, a new day starts at sunrise, return {1, 4}. </li> <li>If, in your Calendar, a new day starts at noon, return {1, 2}. </li> <li>If, in your Calendar, a new day starts at sunset, return {3, 4}. </li> </ul>    <h3 class="detail-header callback" id="c:days_in_month/2">  <span class="signature">days_in_month(year, month)</span>     </h3>
<pre data-language="elixir">days_in_month(year(), month()) :: day()</pre>  <p>Returns how many days there are in the given year-month.</p>    <h3 class="detail-header callback" id="c:leap_year?/1">  <span class="signature">leap_year?(year)</span>     </h3>
<pre data-language="elixir">leap_year?(year()) :: boolean()</pre>  <p>Returns <code class="inline">true</code> if the given year is a leap year.</p> <p>A leap year is a year of a longer length than normal. The exact meaning is up to the calendar. A calendar must return <code class="inline">false</code> if it does not support the concept of leap years.</p>    <h3 class="detail-header callback" id="c:months_in_year/1">  <span class="signature">months_in_year(year)</span>     </h3>
<pre data-language="elixir">months_in_year(year()) :: month()</pre>  <p>Returns how many months there are in the given year.</p>    <h3 class="detail-header callback" id="c:naive_datetime_from_iso_days/1">  <span class="signature">naive_datetime_from_iso_days(iso_days)</span>     </h3>
<pre data-language="elixir">naive_datetime_from_iso_days(iso_days()) ::
  {year(), month(), day(), hour(), minute(), second(), microsecond()}</pre>  <p>Converts <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> to the Calendarâ€™s datetime format.</p>    <h3 class="detail-header callback" id="c:naive_datetime_to_iso_days/7">  <span class="signature">naive_datetime_to_iso_days(year, month, day, hour, minute, second, microsecond)</span>     </h3>
<pre data-language="elixir">naive_datetime_to_iso_days(
  year(),
  month(),
  day(),
  hour(),
  minute(),
  second(),
  microsecond()
) :: iso_days()</pre>  <p>Converts the given datetime (with time zone) into the <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> format.</p>    <h3 class="detail-header callback" id="c:naive_datetime_to_string/7">  <span class="signature">naive_datetime_to_string(year, month, day, hour, minute, second, microsecond)</span>     </h3>
<pre data-language="elixir">naive_datetime_to_string(
  year(),
  month(),
  day(),
  hour(),
  minute(),
  second(),
  microsecond()
) :: String.t()</pre>  <p>Converts the datetime (without time zone) into a string according to the calendar.</p>    <h3 class="detail-header callback" id="c:time_from_day_fraction/1">  <span class="signature">time_from_day_fraction(day_fraction)</span>     </h3>
<pre data-language="elixir">time_from_day_fraction(day_fraction()) ::
  {hour(), minute(), second(), microsecond()}</pre>  <p>Converts <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> to the Calendarâ€™s time format.</p>    <h3 class="detail-header callback" id="c:time_to_day_fraction/4">  <span class="signature">time_to_day_fraction(hour, minute, second, microsecond)</span>     </h3>
<pre data-language="elixir">time_to_day_fraction(hour(), minute(), second(), microsecond()) ::
  day_fraction()</pre>  <p>Converts the given time to the <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> format.</p>    <h3 class="detail-header callback" id="c:time_to_string/4">  <span class="signature">time_to_string(hour, minute, second, microsecond)</span>     </h3>
<pre data-language="elixir">time_to_string(hour(), minute(), second(), microsecond()) :: String.t()</pre>  <p>Converts the time into a string according to the calendar.</p>    <h3 class="detail-header callback" id="c:valid_date?/3">  <span class="signature">valid_date?(year, month, day)</span>     </h3>
<pre data-language="elixir">valid_date?(year(), month(), day()) :: boolean()</pre>  <p>Should return <code class="inline">true</code> if the given date describes a proper date in the calendar.</p>    <h3 class="detail-header callback" id="c:valid_time?/4">  <span class="signature">valid_time?(hour, minute, second, microsecond)</span>     </h3>
<pre data-language="elixir">valid_time?(hour(), minute(), second(), microsecond()) :: boolean()</pre>  <p>Should return <code class="inline">true</code> if the given time describes a proper time in the calendar.</p>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.7.3/Calendar.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.7.3/Calendar.html</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
