
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Basic Types - Kotlin - W3cubDocs</title>
  
  <meta name="description" content="In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a &hellip;">
  <meta name="keywords" content="basic, types, -, kotlin">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/kotlin/docs/reference/basic-types/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/kotlin.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/kotlin/" class="_nav-link" title="" style="margin-left:0;">Kotlin</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _kotlin">
				
				
<h1 id="basic-types">Basic Types</h1> <p>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings.</p> <h2 id="numbers">Numbers</h2> <p>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</p> <p>Kotlin provides the following built-in types representing numbers (this is close to Java):</p> <table> <thead> <tr> <th>Type</th> <th>Bit width</th> </tr> </thead> <tbody> <tr> <td>Double</td> <td>64</td> </tr> <tr> <td>Float</td> <td>32</td> </tr> <tr> <td>Long</td> <td>64</td> </tr> <tr> <td>Int</td> <td>32</td> </tr> <tr> <td>Short</td> <td>16</td> </tr> <tr> <td>Byte</td> <td>8</td> </tr> </tbody> </table> <p>Note that characters are not numbers in Kotlin.</p> <h3 id="literal-constants">Literal Constants</h3> <p>There are the following kinds of literal constants for integral values:</p> <ul> <li>Decimals: <code>123</code> <ul> <li>Longs are tagged by a capital <code>L</code>: <code>123L</code>
</li> </ul> </li> <li>Hexadecimals: <code>0x0F</code>
</li> <li>Binaries: <code>0b00001011</code>
</li> </ul> <p>NOTE: Octal literals are not supported.</p> <p>Kotlin also supports a conventional notation for floating-point numbers:</p> <ul> <li>Doubles by default: <code>123.5</code>, <code>123.5e10</code>
</li> <li>Floats are tagged by <code>f</code> or <code>F</code>: <code>123.5f</code>
</li> </ul> <h3 id="underscores-in-numeric-literals-since-11">Underscores in numeric literals (since 1.1)</h3> <p>You can use underscores to make number constants more readable:</p> <pre data-language="kotlin">val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
</pre> <h3 id="representation">Representation</h3> <p>On the Java platform, numbers are physically stored as JVM primitive types, unless we need a nullable number reference (e.g. <code>Int?</code>) or generics are involved. In the latter cases numbers are boxed.</p> <p>Note that boxing of numbers does not necessarily preserve identity:</p> <pre data-language="kotlin">val a: Int = 10000
print(a === a) // Prints 'true'
val boxedA: Int? = a
val anotherBoxedA: Int? = a
print(boxedA === anotherBoxedA) // !!!Prints 'false'!!!
</pre> <p>On the other hand, it preserves equality:</p> <pre data-language="kotlin">val a: Int = 10000
print(a == a) // Prints 'true'
val boxedA: Int? = a
val anotherBoxedA: Int? = a
print(boxedA == anotherBoxedA) // Prints 'true'
</pre> <h3 id="explicit-conversions">Explicit Conversions</h3> <p>Due to different representations, smaller types are not subtypes of bigger ones. If they were, we would have troubles of the following sort:</p> <pre data-language="kotlin">// Hypothetical code, does not actually compile:
val a: Int? = 1 // A boxed Int (java.lang.Integer)
val b: Long? = a // implicit conversion yields a boxed Long (java.lang.Long)
print(a == b) // Surprise! This prints "false" as Long's equals() check for other part to be Long as well
</pre> <p>So not only identity, but even equality would have been lost silently all over the place.</p> <p>As a consequence, smaller types are NOT implicitly converted to bigger types. This means that we cannot assign a value of type <code>Byte</code> to an <code>Int</code> variable without an explicit conversion</p> <pre data-language="kotlin">val b: Byte = 1 // OK, literals are checked statically
val i: Int = b // ERROR
</pre> <p>We can use explicit conversions to widen numbers</p> <pre data-language="kotlin">val i: Int = b.toInt() // OK: explicitly widened
</pre> <p>Every number type supports the following conversions:</p> <ul> <li><code>toByte(): Byte</code></li> <li><code>toShort(): Short</code></li> <li><code>toInt(): Int</code></li> <li><code>toLong(): Long</code></li> <li><code>toFloat(): Float</code></li> <li><code>toDouble(): Double</code></li> <li><code>toChar(): Char</code></li> </ul> <p>Absence of implicit conversions is rarely noticeable because the type is inferred from the context, and arithmetical operations are overloaded for appropriate conversions, for example</p> <pre data-language="kotlin">val l = 1L + 3 // Long + Int =&gt; Long
</pre> <h3 id="operations">Operations</h3> <p>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See <a href="../operator-overloading/">Operator overloading</a>.</p> <p>As of bitwise operations, there're no special characters for them, but just named functions that can be called in infix form, for example:</p> <pre data-language="kotlin">val x = (1 shl 2) and 0x000FF000
</pre> <p>Here is the complete list of bitwise operations (available for <code>Int</code> and <code>Long</code> only):</p> <ul> <li>
<code>shl(bits)</code> – signed shift left (Java's <code>&lt;&lt;</code>)</li> <li>
<code>shr(bits)</code> – signed shift right (Java's <code>&gt;&gt;</code>)</li> <li>
<code>ushr(bits)</code> – unsigned shift right (Java's <code>&gt;&gt;&gt;</code>)</li> <li>
<code>and(bits)</code> – bitwise and</li> <li>
<code>or(bits)</code> – bitwise or</li> <li>
<code>xor(bits)</code> – bitwise xor</li> <li>
<code>inv()</code> – bitwise inversion</li> </ul> <h3 id="floating-point-numbers-comparison">Floating Point Numbers Comparison</h3> <p>The operations on floating point numbers discussed in this section are:</p> <ul> <li>Equality checks: <code>a == b</code> and <code>a != b</code>
</li> <li>Comparison operators: <code>a &lt; b</code>, <code>a &gt; b</code>, <code>a &lt;= b</code>, <code>a &gt;= b</code>
</li> <li>Range instantiation and range checks: <code>a..b</code>, <code>x in a..b</code>, <code>x !in a..b</code>
</li> </ul> <p>When the operands <code>a</code> and <code>b</code> are statically known to be <code>Float</code> or <code>Double</code> or their nullable counterparts (the type is declared or inferred or is a result of a <a href="../typecasts/#smart-casts">smart cast</a>), the operations on the numbers and the range that they form follow the IEEE 754 Standard for Floating-Point Arithmetic.</p> <p>However, to support generic use cases and provide total ordering, when the operands are <strong>not</strong> statically typed as floating point numbers (e.g. <code>Any</code>, <code>Comparable&lt;...&gt;</code>, a type parameter), the operations use the <code>equals</code> and <code>compareTo</code> implementations for <code>Float</code> and <code>Double</code>, which disagree with the standard, so that:</p> <ul> <li>
<code>NaN</code> is considered equal to itself</li> <li>
<code>NaN</code> is considered greater than any other element including <code>POSITIVE_INFINITY</code>
</li> <li>
<code>-0.0</code> is considered less than <code>0.0</code>
</li> </ul> <h2 id="characters">Characters</h2> <p>Characters are represented by the type <code>Char</code>. They can not be treated directly as numbers</p> <pre data-language="kotlin">fun check(c: Char) {
    if (c == 1) { // ERROR: incompatible types
        // ...
    }
}
</pre> <p>Character literals go in single quotes: <code>'1'</code>. Special characters can be escaped using a backslash. The following escape sequences are supported: <code>\t</code>, <code>\b</code>, <code>\n</code>, <code>\r</code>, <code>\'</code>, <code>\"</code>, <code>\\</code> and <code>\$</code>. To encode any other character, use the Unicode escape sequence syntax: <code>'\uFF00'</code>.</p> <p>We can explicitly convert a character to an <code>Int</code> number:</p> <pre data-language="kotlin">fun decimalDigitValue(c: Char): Int {
    if (c !in '0'..'9')
        throw IllegalArgumentException("Out of range")
    return c.toInt() - '0'.toInt() // Explicit conversions to numbers
}
</pre> <p>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</p> <h2 id="booleans">Booleans</h2> <p>The type <code>Boolean</code> represents booleans, and has two values: <em class="keyword">true</em> and <em class="keyword">false</em>.</p> <p>Booleans are boxed if a nullable reference is needed.</p> <p>Built-in operations on booleans include</p> <ul> <li>
<code>||</code> – lazy disjunction</li> <li>
<code>&amp;&amp;</code> – lazy conjunction</li> <li>
<code>!</code> - negation</li> </ul> <h2 id="arrays">Arrays</h2> <p>Arrays in Kotlin are represented by the <code>Array</code> class, that has <code>get</code> and <code>set</code> functions (that turn into <code>[]</code> by operator overloading conventions), and <code>size</code> property, along with a few other useful member functions:</p> <pre data-language="kotlin">class Array&lt;T&gt; private constructor() {
    val size: Int
    operator fun get(index: Int): T
    operator fun set(index: Int, value: T): Unit

    operator fun iterator(): Iterator&lt;T&gt;
    // ...
}
</pre> <p>To create an array, we can use a library function <code>arrayOf()</code> and pass the item values to it, so that <code>arrayOf(1, 2, 3)</code> creates an array [1, 2, 3]. Alternatively, the <code>arrayOfNulls()</code> library function can be used to create an array of a given size filled with null elements.</p> <p>Another option is to use the <code>Array</code> constructor that takes the array size and the function that can return the initial value of each array element given its index:</p> <pre data-language="kotlin">// Creates an Array&lt;String&gt; with values ["0", "1", "4", "9", "16"]
val asc = Array(5, { i -&gt; (i * i).toString() })
</pre> <p>As we said above, the <code>[]</code> operation stands for calls to member functions <code>get()</code> and <code>set()</code>.</p> <p>Note: unlike Java, arrays in Kotlin are invariant. This means that Kotlin does not let us assign an <code>Array&lt;String&gt;</code> to an <code>Array&lt;Any&gt;</code>, which prevents a possible runtime failure (but you can use <code>Array&lt;out Any&gt;</code>, see <a href="../generics/#type-projections">Type Projections</a>).</p> <p>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: <code>ByteArray</code>, <code>ShortArray</code>, <code>IntArray</code> and so on. These classes have no inheritance relation to the <code>Array</code> class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</p> <pre data-language="kotlin">val x: IntArray = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2]
</pre> <h2 id="strings">Strings</h2> <p>Strings are represented by the type <code>String</code>. Strings are immutable. Elements of a string are characters that can be accessed by the indexing operation: <code>s[i]</code>. A string can be iterated over with a <em class="keyword">for</em>-loop:</p> <div class="sample"> <pre>fun main(args: Array&lt;String&gt;) {
val str = "abcd"
//sampleStart
for (c in str) {
    println(c)
}
//sampleEnd
}
</pre> </div> <p>You can concatenate strings using the <code>+</code> operator. This also works for concatenating strings with values of other types, as long as the first element in the expression is a string:</p> <div class="sample"> <pre>fun main(args: Array&lt;String&gt;) {
//sampleStart
val s = "abc" + 1
println(s + "def")
//sampleEnd
}
</pre> </div> <p>Note that in most cases using <a href="#string-templates">string templates</a> or raw strings is preferable to string concatenation.</p> <h3 id="string-literals">String Literals</h3> <p>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</p> <pre data-language="kotlin">val s = "Hello, world!\n"
</pre> <p>Escaping is done in the conventional way, with a backslash. See <a href="#characters">Characters</a> above for the list of supported escape sequences.</p> <p>A raw string is delimited by a triple quote (<code>"""</code>), contains no escaping and can contain newlines and any other characters:</p> <pre data-language="kotlin">val text = """
    for (c in "foo")
        print(c)
"""
</pre> <p>You can remove leading whitespace with <a href="../../../api/latest/jvm/stdlib/kotlin.text/trim-margin/"><code>trimMargin()</code></a> function:</p> <pre data-language="kotlin">val text = """
    |Tell me and I forget.
    |Teach me and I remember.
    |Involve me and I learn.
    |(Benjamin Franklin)
    """.trimMargin()
</pre> <p>By default <code>|</code> is used as margin prefix, but you can choose another character and pass it as a parameter, like <code>trimMargin("&gt;")</code>.</p> <h3 id="string-templates">String Templates</h3> <p>Strings may contain template expressions, i.e. pieces of code that are evaluated and whose results are concatenated into the string. A template expression starts with a dollar sign ($) and consists of either a simple name:</p> <div class="sample"> <pre>fun main(args: Array&lt;String&gt;) {
//sampleStart
val i = 10
println("i = $i") // prints "i = 10"
//sampleEnd
}
</pre> </div> <p>or an arbitrary expression in curly braces:</p> <div class="sample"> <pre>fun main(args: Array&lt;String&gt;) {
//sampleStart
val s = "abc"
println("$s.length is ${s.length}") // prints "abc.length is 3"
//sampleEnd
}
</pre> </div> <p>Templates are supported both inside raw strings and inside escaped strings. If you need to represent a literal <code>$</code> character in a raw string (which doesn't support backslash escaping), you can use the following syntax:</p> <pre data-language="kotlin">val price = """
${'$'}9.99
"""
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2018 JetBrains s.r.o.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://kotlinlang.org/docs/reference/basic-types.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/reference/basic-types.html</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
