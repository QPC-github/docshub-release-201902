
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>backends.backend_pdf - Matplotlib 3.0 - W3cubDocs</title>
  
  <meta name="description" content=" A PDF matplotlib backend Author&#58; Jouni K Seppänen &#60;jks&#64;iki.fi&#62; ">
  <meta name="keywords" content="matplotlib, backends, backend, pdf, -, matplotlib~3.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~3.0/backend_pdf_api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/matplotlib~3.0.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~3.0/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 3.0</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1 id="matplotlib-backends-backend-pdf">matplotlib.backends.backend_pdf</h1> <p id="module-matplotlib.backends.backend_pdf">A PDF matplotlib backend Author: Jouni K Seppänen &lt;<a class="reference external" href="https://matplotlib.org/cdn-cgi/l/email-protection#640e0f17424757535f424751565f4247505c5f0d0f0d424750525f020d" target="_blank">jks<span>@</span>iki<span>.</span>fi</a>&gt;</p> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.FigureCanvas">
<code>matplotlib.backends.backend_pdf.FigureCanvas</code> </dt> <dd>
<p>alias of <a class="reference internal" href="#matplotlib.backends.backend_pdf.FigureCanvasPdf" title="matplotlib.backends.backend_pdf.FigureCanvasPdf"><code>matplotlib.backends.backend_pdf.FigureCanvasPdf</code></a></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf">
<code>class matplotlib.backends.backend_pdf.FigureCanvasPdf(figure)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#FigureCanvasPdf" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="../backend_bases_api/#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><code>matplotlib.backend_bases.FigureCanvasBase</code></a></p> <p>The canvas the figure renders into. Calls the draw and print fig methods, creates the renderers, etc...</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>figure : matplotlib.figure.Figure</code> </dt> <dd>
<p class="first last">A high-level Figure instance</p> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf.draw">
<code>draw()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#FigureCanvasPdf.draw" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Render the <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf.filetypes">
<code>filetypes = {'pdf': 'Portable Document Format'}</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf.fixed_dpi">
<code>fixed_dpi = 72</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf.get_default_filetype">
<code>get_default_filetype()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#FigureCanvasPdf.get_default_filetype" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the default savefig file format as specified in rcParam <code>savefig.format</code>. Returned string excludes period. Overridden in backends that only support a single file type.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf">
<code>print_pdf(filename, *, dpi=72, bbox_inches_restore=None, metadata=None, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#FigureCanvasPdf.print_pdf" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf">
<code>class matplotlib.backends.backend_pdf.GraphicsContextPdf(file)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="../backend_bases_api/#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><code>matplotlib.backend_bases.GraphicsContextBase</code></a></p> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd">
<code>alpha_cmd(alpha, forced, effective_alphas)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.alpha_cmd" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd">
<code>capstyle_cmd(style)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.capstyle_cmd" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyles">
<code>capstyles = {'butt': 0, 'projecting': 2, 'round': 1}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd">
<code>clip_cmd(cliprect, clippath)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.clip_cmd" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set clip rectangle. Calls self.pop() and self.push().</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.commands">
<code>commands = ((('_cliprect', '_clippath'), &lt;function GraphicsContextPdf.clip_cmd&gt;), (('_alpha', '_forced_alpha', '_effective_alphas'), &lt;function GraphicsContextPdf.alpha_cmd&gt;), (('_capstyle',), &lt;function GraphicsContextPdf.capstyle_cmd&gt;), (('_fillcolor',), &lt;function GraphicsContextPdf.fillcolor_cmd&gt;), (('_joinstyle',), &lt;function GraphicsContextPdf.joinstyle_cmd&gt;), (('_linewidth',), &lt;function GraphicsContextPdf.linewidth_cmd&gt;), (('_dashes',), &lt;function GraphicsContextPdf.dash_cmd&gt;), (('_rgb',), &lt;function GraphicsContextPdf.rgb_cmd&gt;), (('_hatch', '_hatch_color'), &lt;function GraphicsContextPdf.hatch_cmd&gt;))</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties">
<code>copy_properties(other)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.copy_properties" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Copy properties of other into self.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.dash_cmd">
<code>dash_cmd(dashes)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.dash_cmd" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.delta">
<code>delta(other)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.delta" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Copy properties of other into self and return PDF commands needed to transform self into other.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.fill">
<code>fill(*args)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.fill" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predicate: does the path need to be filled?</p> <p>An optional argument can be used to specify an alternative _fillcolor, as needed by RendererPdf.draw_markers.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd">
<code>fillcolor_cmd(rgb)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.fillcolor_cmd" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize">
<code>finalize()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.finalize" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Make sure every pushed graphics state is popped.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd">
<code>hatch_cmd(hatch, hatch_color)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.hatch_cmd" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd">
<code>joinstyle_cmd(style)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.joinstyle_cmd" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyles">
<code>joinstyles = {'bevel': 2, 'miter': 0, 'round': 1}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.linewidth_cmd">
<code>linewidth_cmd(width)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.linewidth_cmd" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.paint">
<code>paint()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.paint" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the appropriate pdf operator to cause the path to be stroked, filled, or both.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.pop">
<code>pop()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.pop" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.push">
<code>push()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.push" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd">
<code>rgb_cmd(rgb)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.rgb_cmd" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.GraphicsContextPdf.stroke">
<code>stroke()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#GraphicsContextPdf.stroke" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predicate: does the path need to be stroked (its outline drawn)? This tests for the various conditions that disable stroking the path, in which case it would presumably be filled.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.Name">
<code>class matplotlib.backends.backend_pdf.Name(name)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Name" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)" target="_blank"><code>object</code></a></p> <p>PDF name object.</p> <dl class="staticmethod"> <dt id="matplotlib.backends.backend_pdf.Name.hexify">
<code>static hexify(match)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Name.hexify" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Name.name">
<code>name</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Name.pdfRepr">
<code>pdfRepr()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Name.pdfRepr" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.Operator">
<code>class matplotlib.backends.backend_pdf.Operator(op)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Operator" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)" target="_blank"><code>object</code></a></p> <p>PDF operator object.</p> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Operator.op">
<code>op</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Operator.pdfRepr">
<code>pdfRepr()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Operator.pdfRepr" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.PdfFile">
<code>class matplotlib.backends.backend_pdf.PdfFile(filename, metadata=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)" target="_blank"><code>object</code></a></p> <p>PDF file object.</p> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles">
<code>addGouraudTriangles(points, colors)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.addGouraudTriangles" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.alphaState">
<code>alphaState(alpha)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.alphaState" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return name of an ExtGState that sets alpha to the given value.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.beginStream">
<code>beginStream(id, len, extra=None, png=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.beginStream" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.close">
<code>close()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.close" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Flush all buffers and free all resources.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor">
<code>createType1Descriptor(t1font, fontfile)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.createType1Descriptor" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.dviFontName">
<code>dviFontName(dvifont)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.dviFontName" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Given a dvi font object, return a name suitable for Op.selectfont. This registers the font information in self.dviFontInfo if not yet registered.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.embedTTF">
<code>embedTTF(filename, characters)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.embedTTF" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Embed the TTF font from the named file into the document.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.endStream">
<code>endStream()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.endStream" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.finalize">
<code>finalize()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.finalize" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Write out the various deferred objects and the pdf end matter.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.fontName">
<code>fontName(fontprop)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.fontName" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Select a font based on fontprop and return a name suitable for Op.selectfont. If fontprop is a string, it will be interpreted as the filename of the font.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.hatchPattern">
<code>hatchPattern(hatch_style)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.hatchPattern" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.imageObject">
<code>imageObject(image)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.imageObject" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return name of an image XObject representing the given image.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.markerObject">
<code>markerObject(path, trans, fill, stroke, lw, joinstyle, capstyle)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.markerObject" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return name of a marker XObject representing the given path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.newPage">
<code>newPage(width, height)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.newPage" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.newTextnote">
<code>newTextnote(text, positionRect=[-100, -100, 0, 0])</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.newTextnote" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.output">
<code>output(*data)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.output" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject">
<code>pathCollectionObject(gc, path, trans, padding, filled, stroked)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.pathCollectionObject" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="staticmethod"> <dt id="matplotlib.backends.backend_pdf.PdfFile.pathOperations">
<code>static pathOperations(path, transform, clip=None, simplify=None, sketch=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.pathOperations" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.recordXref">
<code>recordXref(id)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.recordXref" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.reserveObject">
<code>reserveObject(name='')</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.reserveObject" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Reserve an ID for an indirect object. The name is used for debugging in case we forget to print out the object with writeObject.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.PdfFile.texFontMap">
<code>texFontMap</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.0: </span>The texFontMap function was deprecated in Matplotlib 3.0 and will be removed in 3.2.</p> </div>  </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.write">
<code>write(data)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.write" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeFonts">
<code>writeFonts()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.writeFonts" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeGouraudTriangles">
<code>writeGouraudTriangles()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.writeGouraudTriangles" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeHatches">
<code>writeHatches()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.writeHatches" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeImages">
<code>writeImages()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.writeImages" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeInfoDict">
<code>writeInfoDict()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.writeInfoDict" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Write out the info dictionary, checking it for good form</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeMarkers">
<code>writeMarkers()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.writeMarkers" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeObject">
<code>writeObject(object, contents)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.writeObject" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writePath">
<code>writePath(path, transform, clip=False, sketch=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.writePath" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates">
<code>writePathCollectionTemplates()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.writePathCollectionTemplates" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeTrailer">
<code>writeTrailer()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.writeTrailer" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Write out the PDF trailer.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfFile.writeXref">
<code>writeXref()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfFile.writeXref" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Write out the xref table.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.PdfPages">
<code>class matplotlib.backends.backend_pdf.PdfPages(filename, keep_empty=True, metadata=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfPages" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)" target="_blank"><code>object</code></a></p> <p>A multi-page PDF file.</p> <h4 class="rubric">Notes</h4> <p>In reality <a class="reference internal" href="#matplotlib.backends.backend_pdf.PdfPages" title="matplotlib.backends.backend_pdf.PdfPages"><code>PdfPages</code></a> is a thin wrapper around <a class="reference internal" href="#matplotlib.backends.backend_pdf.PdfFile" title="matplotlib.backends.backend_pdf.PdfFile"><code>PdfFile</code></a>, in order to avoid confusion when using <a class="reference internal" href="../_as_gen/matplotlib.pyplot.savefig/#matplotlib.pyplot.savefig" title="matplotlib.pyplot.savefig"><code>savefig()</code></a> and forgetting the format argument.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; # Initialize:
&gt;&gt;&gt; with PdfPages('foo.pdf') as pdf:
...     # As many times as you like, create a figure fig and save it:
...     fig = plt.figure()
...     pdf.savefig(fig)
...     # When no figure is specified the current figure is saved
...     pdf.savefig()
</pre> <p>Create a new PdfPages object.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filename : str</code> </dt> <dd>
<p class="first last">Plots using <a class="reference internal" href="#matplotlib.backends.backend_pdf.PdfPages.savefig" title="matplotlib.backends.backend_pdf.PdfPages.savefig"><code>PdfPages.savefig()</code></a> will be written to a file at this location. The file is opened at once and any older file with the same name is overwritten.</p> </dd> <dt>
<code>keep_empty : bool, optional</code> </dt> <dd>
<p class="first last">If set to False, then empty pdf files will be deleted automatically when closed.</p> </dd> <dt>
<code>metadata : dictionary, optional</code> </dt> <dd>
<p class="first">Information dictionary object (see PDF reference section 10.2.1 'Document Information Dictionary'), e.g.: <code>{'Creator': 'My software', 'Author': 'Me',
'Title': 'Awesome fig'}</code></p> <p class="last">The standard keys are <code>'Title'</code>, <code>'Author'</code>, <code>'Subject'</code>, <code>'Keywords'</code>, <code>'Creator'</code>, <code>'Producer'</code>, <code>'CreationDate'</code>, <code>'ModDate'</code>, and <code>'Trapped'</code>. Values have been predefined for <code>'Creator'</code>, <code>'Producer'</code> and <code>'CreationDate'</code>. They can be removed by setting them to <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)" target="_blank"><code>None</code></a>.</p> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfPages.attach_note">
<code>attach_note(text, positionRect=[-100, -100, 0, 0])</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfPages.attach_note" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a new text note to the page to be saved next. The optional positionRect specifies the position of the new note on the page. It is outside the page per default to make sure it is invisible on printouts.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfPages.close">
<code>close()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfPages.close" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Finalize this object, making the underlying file a complete PDF file.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfPages.get_pagecount">
<code>get_pagecount()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfPages.get_pagecount" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the current number of pages in the multipage pdf file.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfPages.infodict">
<code>infodict()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfPages.infodict" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a modifiable information dictionary object (see PDF reference section 10.2.1 'Document Information Dictionary').</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.PdfPages.keep_empty">
<code>keep_empty</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.PdfPages.savefig">
<code>savefig(figure=None, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#PdfPages.savefig" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Saves a <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> to this file as a new page.</p> <p>Any other keyword arguments are passed to <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure.savefig" title="matplotlib.figure.Figure.savefig"><code>savefig()</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>figure : Figure or int, optional</code> </dt> <dd>
<p class="first last">Specifies what figure is saved to file. If not specified, the active figure is saved. If a <a class="reference internal" href="../_as_gen/matplotlib.figure.figure/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance is provided, this figure is saved. If an int is specified, the figure instance to save is looked up by number.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.Reference">
<code>class matplotlib.backends.backend_pdf.Reference(id)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Reference" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)" target="_blank"><code>object</code></a></p> <p>PDF reference object. Use PdfFile.reserveObject() to create References.</p> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Reference.pdfRepr">
<code>pdfRepr()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Reference.pdfRepr" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Reference.write">
<code>write(contents, file)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Reference.write" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.RendererPdf">
<code>class matplotlib.backends.backend_pdf.RendererPdf(file, image_dpi, height, width)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="../backend_bases_api/#matplotlib.backend_bases.RendererBase" title="matplotlib.backend_bases.RendererBase"><code>matplotlib.backend_bases.RendererBase</code></a></p> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.afm_font_cache">
<code>afm_font_cache = {}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.check_gc">
<code>check_gc(gc, fillcolor=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.check_gc" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle">
<code>draw_gouraud_triangle(gc, points, colors, trans)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.draw_gouraud_triangle" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw a Gouraud-shaded triangle.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>points : array_like, shape=(3, 2)</code> </dt> <dd>
<p class="first last">Array of (x, y) points for the triangle.</p> </dd> <dt>
<code>colors : array_like, shape=(3, 4)</code> </dt> <dd>
<p class="first last">RGBA colors for each point of the triangle.</p> </dd> <dt>
<code>transform : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform to apply to the points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles">
<code>draw_gouraud_triangles(gc, points, colors, trans)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.draw_gouraud_triangles" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a series of Gouraud triangles.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>points : array_like, shape=(N, 3, 2)</code> </dt> <dd>
<p class="first last">Array of <em>N</em> (x, y) points for the triangles.</p> </dd> <dt>
<code>colors : array_like, shape=(N, 3, 4)</code> </dt> <dd>
<p class="first last">Array of <em>N</em> RGBA colors for each point of the triangles.</p> </dd> <dt>
<code>transform : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform to apply to the points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_image">
<code>draw_image(gc, x, y, im, transform=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.draw_image" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw an RGBA image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gc : GraphicsContextBase</code> </dt> <dd>
<p class="first last">a graphics context with clipping information.</p> </dd> <dt>
<code>x : scalar</code> </dt> <dd>
<p class="first last">the distance in physical units (i.e., dots or pixels) from the left hand side of the canvas.</p> </dd> <dt>
<code>y : scalar</code> </dt> <dd>
<p class="first last">the distance in physical units (i.e., dots or pixels) from the bottom side of the canvas.</p> </dd> <dt>
<code>im : array_like, shape=(N, M, 4), dtype=np.uint8</code> </dt> <dd>
<p class="first last">An array of RGBA pixels.</p> </dd> <dt>
<code>transform : matplotlib.transforms.Affine2DBase</code> </dt> <dd>
<p class="first last">If and only if the concrete backend is written such that <a class="reference internal" href="#matplotlib.backends.backend_pdf.RendererPdf.option_scale_image" title="matplotlib.backends.backend_pdf.RendererPdf.option_scale_image"><code>option_scale_image()</code></a> returns <code>True</code>, an affine transformation <em>may</em> be passed to <a class="reference internal" href="#matplotlib.backends.backend_pdf.RendererPdf.draw_image" title="matplotlib.backends.backend_pdf.RendererPdf.draw_image"><code>draw_image()</code></a>. It takes the form of a <a class="reference internal" href="../transformations/#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a> instance. The translation vector of the transformation is given in physical units (i.e., dots or pixels). Note that the transformation does not override <code>x</code> and <code>y</code>, and has to be applied <em>before</em> translating the result by <code>x</code> and <code>y</code> (this can be accomplished by adding <code>x</code> and <code>y</code> to the translation vector defined by <code>transform</code>).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_markers">
<code>draw_markers(gc, marker_path, marker_trans, path, trans, rgbFace=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.draw_markers" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a marker at each of the vertices in path. This includes all vertices, including control points on curves. To avoid that behavior, those vertices should be removed before calling this function.</p> <p>This provides a fallback implementation of draw_markers that makes multiple calls to <a class="reference internal" href="#matplotlib.backends.backend_pdf.RendererPdf.draw_path" title="matplotlib.backends.backend_pdf.RendererPdf.draw_path"><code>draw_path()</code></a>. Some backends may want to override this method in order to draw the marker only once and reuse it multiple times.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gc : GraphicsContextBase</code> </dt> <dd>
<p class="first last">The graphics context</p> </dd> <dt>
<code>marker_trans : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform applied to the marker.</p> </dd> <dt>
<code>trans : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform applied to the path.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext">
<code>draw_mathtext(gc, x, y, s, prop, angle)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.draw_mathtext" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_path">
<code>draw_path(gc, path, transform, rgbFace=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.draw_path" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a <a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance using the given affine transform.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection">
<code>draw_path_collection(gc, master_transform, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.draw_path_collection" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a collection of paths selecting drawing properties from the lists <em>facecolors</em>, <em>edgecolors</em>, <em>linewidths</em>, <em>linestyles</em> and <em>antialiaseds</em>. <em>offsets</em> is a list of offsets to apply to each of the paths. The offsets in <em>offsets</em> are first transformed by <em>offsetTrans</em> before being applied. <em>offset_position</em> may be either "screen" or "data" depending on the space that the offsets are in.</p> <p>This provides a fallback implementation of <a class="reference internal" href="#matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection" title="matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection"><code>draw_path_collection()</code></a> that makes multiple calls to <a class="reference internal" href="#matplotlib.backends.backend_pdf.RendererPdf.draw_path" title="matplotlib.backends.backend_pdf.RendererPdf.draw_path"><code>draw_path()</code></a>. Some backends may want to override this in order to render each set of path data only once, and then reference that path multiple times with the different offsets, colors, styles etc. The generator methods <code>_iter_collection_raw_paths()</code> and <code>_iter_collection()</code> are provided to help with (and standardize) the implementation across backends. It is highly recommended to use those generators, so that changes to the behavior of <a class="reference internal" href="#matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection" title="matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection"><code>draw_path_collection()</code></a> can be made globally.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_tex">
<code>draw_tex(gc, x, y, s, prop, angle, ismath='TeX!', mtext=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.draw_tex" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.draw_text">
<code>draw_text(gc, x, y, s, prop, angle, ismath=False, mtext=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.draw_text" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw the text instance</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gc : GraphicsContextBase</code> </dt> <dd>
<p class="first last">the graphics context</p> </dd> <dt>
<code>x : scalar</code> </dt> <dd>
<p class="first last">the x location of the text in display coords</p> </dd> <dt>
<code>y : scalar</code> </dt> <dd>
<p class="first last">the y location of the text baseline in display coords</p> </dd> <dt>
<code>s : str</code> </dt> <dd>
<p class="first last">the text string</p> </dd> <dt>
<code>prop : matplotlib.font_manager.FontProperties</code> </dt> <dd>
<p class="first last">font properties</p> </dd> <dt>
<code>angle : scalar</code> </dt> <dd>
<p class="first last">the rotation angle in degrees</p> </dd> <dt>
<code>mtext : matplotlib.text.Text</code> </dt> <dd>
<p class="first last">the original text object to be rendered</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p><strong>backend implementers note</strong></p> <p>When you are trying to determine if you have gotten your bounding box right (which is what enables the text layout/alignment to work properly), it helps to change the line in text.py:</p> <pre data-language="python">if 0: bbox_artist(self, renderer)
</pre> <p>to if 1, and then the actual bounding box will be plotted along with your text.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.encode_string">
<code>encode_string(s, fonttype)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.encode_string" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.finalize">
<code>finalize()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.finalize" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.flipy">
<code>flipy()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.flipy" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return true if y small numbers are top for renderer Is used for drawing text (<a class="reference internal" href="../text_api/#module-matplotlib.text" title="matplotlib.text"><code>matplotlib.text</code></a>) and images (<a class="reference internal" href="../image_api/#module-matplotlib.image" title="matplotlib.image"><code>matplotlib.image</code></a>) only</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.get_canvas_width_height">
<code>get_canvas_width_height()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.get_canvas_width_height" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>return the canvas width and height in display coords</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.get_image_magnification">
<code>get_image_magnification()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.get_image_magnification" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the factor by which to magnify images passed to <a class="reference internal" href="#matplotlib.backends.backend_pdf.RendererPdf.draw_image" title="matplotlib.backends.backend_pdf.RendererPdf.draw_image"><code>draw_image()</code></a>. Allows a backend to have images at a different resolution to other artists.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.get_text_width_height_descent">
<code>get_text_width_height_descent(s, prop, ismath)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.get_text_width_height_descent" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the width, height, and descent (offset from the bottom to the baseline), in display coords, of the string <em>s</em> with <a class="reference internal" href="../font_manager_api/#matplotlib.font_manager.FontProperties" title="matplotlib.font_manager.FontProperties"><code>FontProperties</code></a> <em>prop</em></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.merge_used_characters">
<code>merge_used_characters(other)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.merge_used_characters" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.new_gc">
<code>new_gc()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.new_gc" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return an instance of a <code>GraphicsContextBase</code></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.option_image_nocomposite">
<code>option_image_nocomposite()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.option_image_nocomposite" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>return whether to generate a composite image from multiple images on a set of axes</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.option_scale_image">
<code>option_scale_image()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.option_scale_image" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>pdf backend support arbitrary scaling of image.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.RendererPdf.track_characters">
<code>track_characters(font, s)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#RendererPdf.track_characters" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Keeps track of which characters are required from each font.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.Stream">
<code>class matplotlib.backends.backend_pdf.Stream(id, len, file, extra=None, png=None)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Stream" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)" target="_blank"><code>object</code></a></p> <p>PDF stream object.</p> <p>This has no pdfRepr method. Instead, call begin(), then output the contents of the stream by calling write(), and finally call end().</p> <p>id: object id of stream; len: an unused Reference object for the length of the stream, or None (to use a memory buffer); file: a PdfFile; extra: a dictionary of extra key-value pairs to include in the stream header; png: if the data is already png compressed, the decode parameters</p> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.compressobj">
<code>compressobj</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Stream.end">
<code>end()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Stream.end" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Finalize stream.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.extra">
<code>extra</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.file">
<code>file</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.id">
<code>id</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.len">
<code>len</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.pdfFile">
<code>pdfFile</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_pdf.Stream.pos">
<code>pos</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Stream.write">
<code>write(data)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Stream.write" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Write some data on the stream.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_pdf.Verbatim">
<code>class matplotlib.backends.backend_pdf.Verbatim(x)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Verbatim" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)" target="_blank"><code>object</code></a></p> <p>Store verbatim PDF command content for later inclusion in the stream.</p> <dl class="method"> <dt id="matplotlib.backends.backend_pdf.Verbatim.pdfRepr">
<code>pdfRepr()</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#Verbatim.pdfRepr" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backends.backend_pdf.fill">
<code>matplotlib.backends.backend_pdf.fill(strings, linelen=75)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#fill" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Make one string from sequence of strings, with whitespace in between. The whitespace is chosen to form lines of at most linelen characters, if possible.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backends.backend_pdf.pdfRepr">
<code>matplotlib.backends.backend_pdf.pdfRepr(obj)</code> <a class="reference internal" href="https://matplotlib.org/3.0.0/_modules/matplotlib/backends/backend_pdf.html#pdfRepr" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Map Python objects to PDF syntax.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2018 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.0.0/api/backend_pdf_api.html" class="_attribution-link" target="_blank">https://matplotlib.org/3.0.0/api/backend_pdf_api.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
