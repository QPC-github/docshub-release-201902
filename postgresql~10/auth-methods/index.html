
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Authentication Methods - PostgreSQL 10 - W3cubDocs</title>
  
  <meta name="description" content=" The following subsections describe the authentication methods in more detail. ">
  <meta name="keywords" content="authentication, methods, -, postgresql, postgresql~10">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~10/auth-methods/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/postgresql~10.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~10/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 10</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1>20.3. Authentication Methods</h1>    <div class="toc"> <dl class="toc"> <dt><a href="../auth-methods/#AUTH-TRUST">20.3.1. Trust Authentication</a></dt> <dt><a href="../auth-methods/#AUTH-PASSWORD">20.3.2. Password Authentication</a></dt> <dt><a href="../auth-methods/#GSSAPI-AUTH">20.3.3. GSSAPI Authentication</a></dt> <dt><a href="../auth-methods/#SSPI-AUTH">20.3.4. SSPI Authentication</a></dt> <dt><a href="../auth-methods/#AUTH-IDENT">20.3.5. Ident Authentication</a></dt> <dt><a href="../auth-methods/#AUTH-PEER">20.3.6. Peer Authentication</a></dt> <dt><a href="../auth-methods/#AUTH-LDAP">20.3.7. LDAP Authentication</a></dt> <dt><a href="../auth-methods/#AUTH-RADIUS">20.3.8. RADIUS Authentication</a></dt> <dt><a href="../auth-methods/#AUTH-CERT">20.3.9. Certificate Authentication</a></dt> <dt><a href="../auth-methods/#AUTH-PAM">20.3.10. PAM Authentication</a></dt> <dt><a href="../auth-methods/#AUTH-BSD">20.3.11. BSD Authentication</a></dt> </dl> </div> <p>The following subsections describe the authentication methods in more detail.</p> <div class="sect2" id="AUTH-TRUST">    <h2 class="title">20.3.1. Trust Authentication</h2>    <p>When <code class="literal">trust</code> authentication is specified, PostgreSQL assumes that anyone who can connect to the server is authorized to access the database with whatever database user name they specify (even superuser names). Of course, restrictions made in the <code class="literal">database</code> and <code class="literal">user</code> columns still apply. This method should only be used when there is adequate operating-system-level protection on connections to the server.</p> <p><code class="literal">trust</code> authentication is appropriate and very convenient for local connections on a single-user workstation. It is usually <span class="emphasis"><em>not</em></span> appropriate by itself on a multiuser machine. However, you might be able to use <code class="literal">trust</code> even on a multiuser machine, if you restrict access to the server's Unix-domain socket file using file-system permissions. To do this, set the <code class="varname">unix_socket_permissions</code> (and possibly <code class="varname">unix_socket_group</code>) configuration parameters as described in <a class="xref" href="../runtime-config-connection/" title="19.3. Connections and Authentication">Section 19.3</a>. Or you could set the <code class="varname">unix_socket_directories</code> configuration parameter to place the socket file in a suitably restricted directory.</p> <p>Setting file-system permissions only helps for Unix-socket connections. Local TCP/IP connections are not restricted by file-system permissions. Therefore, if you want to use file-system permissions for local security, remove the <code class="literal">host ... 127.0.0.1 ...</code> line from <code class="filename">pg_hba.conf</code>, or change it to a non-<code class="literal">trust</code> authentication method.</p> <p><code class="literal">trust</code> authentication is only suitable for TCP/IP connections if you trust every user on every machine that is allowed to connect to the server by the <code class="filename">pg_hba.conf</code> lines that specify <code class="literal">trust</code>. It is seldom reasonable to use <code class="literal">trust</code> for any TCP/IP connections other than those from <span class="systemitem">localhost</span> (127.0.0.1).</p> </div> <div class="sect2" id="AUTH-PASSWORD">    <h2 class="title">20.3.2. Password Authentication</h2>     <p>There are several password-based authentication methods. These methods operate similarly but differ in how the users' passwords are stored on the server and how the password provided by a client is sent across the connection.</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">scram-sha-256</code></dt> <dd> <p>The method <code class="literal">scram-sha-256</code> performs SCRAM-SHA-256 authentication, as described in <a class="ulink" href="https://tools.ietf.org/html/rfc7677" target="_blank">RFC 7677</a>. It is a challenge-response scheme that prevents password sniffing on untrusted connections and supports storing passwords on the server in a cryptographically hashed form that is thought to be secure.</p> <p>This is the most secure of the currently provided methods, but it is not supported by older client libraries.</p> </dd> <dt><code class="literal">md5</code></dt> <dd> <p>The method <code class="literal">md5</code> uses a custom less secure challenge-response mechanism. It prevents password sniffing and avoids storing passwords on the server in plain text but provides no protection if an attacker manages to steal the password hash from the server. Also, the MD5 hash algorithm is nowadays no longer considered secure against determined attacks.</p> <p>The <code class="literal">md5</code> method cannot be used with the <a class="xref" href="../runtime-config-connection/#GUC-DB-USER-NAMESPACE">db_user_namespace</a> feature.</p> <p>To ease transition from the <code class="literal">md5</code> method to the newer SCRAM method, if <code class="literal">md5</code> is specified as a method in <code class="filename">pg_hba.conf</code> but the user's password on the server is encrypted for SCRAM (see below), then SCRAM-based authentication will automatically be chosen instead.</p> </dd> <dt><code class="literal">password</code></dt> <dd> <p>The method <code class="literal">password</code> sends the password in clear-text and is therefore vulnerable to password <span class="quote">“<span class="quote">sniffing</span>”</span> attacks. It should always be avoided if possible. If the connection is protected by SSL encryption then <code class="literal">password</code> can be used safely, though. (Though SSL certificate authentication might be a better choice if one is depending on using SSL).</p> </dd> </dl> </div> <p>PostgreSQL database passwords are separate from operating system user passwords. The password for each database user is stored in the <code class="literal">pg_authid</code> system catalog. Passwords can be managed with the SQL commands <a class="xref" href="../sql-createuser/" title="CREATE USER">CREATE USER</a> and <a class="xref" href="../sql-alterrole/" title="ALTER ROLE">ALTER ROLE</a>, e.g., <strong class="userinput"><code>CREATE USER foo WITH PASSWORD 'secret'</code></strong>, or the psql command <code class="literal">\password</code>. If no password has been set up for a user, the stored password is null and password authentication will always fail for that user.</p> <p>The availability of the different password-based authentication methods depends on how a user's password on the server is encrypted (or hashed, more accurately). This is controlled by the configuration parameter <a class="xref" href="../runtime-config-connection/#GUC-PASSWORD-ENCRYPTION">password_encryption</a> at the time the password is set. If a password was encrypted using the <code class="literal">scram-sha-256</code> setting, then it can be used for the authentication methods <code class="literal">scram-sha-256</code> and <code class="literal">password</code> (but password transmission will be in plain text in the latter case). The authentication method specification <code class="literal">md5</code> will automatically switch to using the <code class="literal">scram-sha-256</code> method in this case, as explained above, so it will also work. If a password was encrypted using the <code class="literal">md5</code> setting, then it can be used only for the <code class="literal">md5</code> and <code class="literal">password</code> authentication method specifications (again, with the password transmitted in plain text in the latter case). (Previous PostgreSQL releases supported storing the password on the server in plain text. This is no longer possible.) To check the currently stored password hashes, see the system catalog <code class="literal">pg_authid</code>.</p> <p>To upgrade an existing installation from <code class="literal">md5</code> to <code class="literal">scram-sha-256</code>, after having ensured that all client libraries in use are new enough to support SCRAM, set <code class="literal">password_encryption = 'scram-sha-256'</code> in <code class="filename">postgresql.conf</code>, make all users set new passwords, and change the authentication method specifications in <code class="filename">pg_hba.conf</code> to <code class="literal">scram-sha-256</code>.</p> </div> <div class="sect2" id="GSSAPI-AUTH">    <h2 class="title">20.3.3. GSSAPI Authentication</h2>     <p>GSSAPI is an industry-standard protocol for secure authentication defined in RFC 2743. PostgreSQL supports GSSAPI with Kerberos authentication according to RFC 1964. GSSAPI provides automatic authentication (single sign-on) for systems that support it. The authentication itself is secure, but the data sent over the database connection will be sent unencrypted unless SSL is used.</p> <p>GSSAPI support has to be enabled when PostgreSQL is built; see <a class="xref" href="https://www.postgresql.org/docs/10/static/installation.html" title="Chapter 16.  Installation from Source Code" target="_blank">Chapter 16</a> for more information.</p> <p>When GSSAPI uses Kerberos, it uses a standard principal in the format <code class="literal">servicename/hostname@realm</code>. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the <code class="literal">krbsrvname</code> connection parameter. (See also <a class="xref" href="https://www.postgresql.org/docs/10/static/libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="33.1.2. Parameter Key Words" target="_blank">Section 33.1.2</a>.) The installation default can be changed from the default <code class="literal">postgres</code> at build time using <code class="literal">./configure --with-krb-srvnam=</code><code>whatever</code>. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (<code class="literal">POSTGRES</code>).</p> <p><code>hostname</code> is the fully qualified host name of the server machine. The service principal's realm is the preferred realm of the server machine.</p> <p>Client principals can be mapped to different PostgreSQL database user names with <code class="filename">pg_ident.conf</code>. For example, <code class="literal">pgusername@realm</code> could be mapped to just <code class="literal">pgusername</code>. Alternatively, you can use the full <code class="literal">username@realm</code> principal as the role name in PostgreSQL without any mapping.</p> <p>PostgreSQL also supports a parameter to strip the realm from the principal. This method is supported for backwards compatibility and is strongly discouraged as it is then impossible to distinguish different users with the same user name but coming from different realms. To enable this, set <code class="literal">include_realm</code> to 0. For simple single-realm installations, doing that combined with setting the <code class="literal">krb_realm</code> parameter (which checks that the principal's realm matches exactly what is in the <code class="literal">krb_realm</code> parameter) is still secure; but this is a less capable approach compared to specifying an explicit mapping in <code class="filename">pg_ident.conf</code>.</p> <p>Make sure that your server keytab file is readable (and preferably only readable, not writable) by the PostgreSQL server account. (See also <a class="xref" href="../postgres-user/" title="18.1. The PostgreSQL User Account">Section 18.1</a>.) The location of the key file is specified by the <a class="xref" href="../runtime-config-connection/#GUC-KRB-SERVER-KEYFILE">krb_server_keyfile</a> configuration parameter. The default is <code class="filename">/usr/local/pgsql/etc/krb5.keytab</code> (or whatever directory was specified as <code class="varname">sysconfdir</code> at build time). For security reasons, it is recommended to use a separate keytab just for the PostgreSQL server rather than opening up permissions on the system keytab file.</p> <p>The keytab file is generated by the Kerberos software; see the Kerberos documentation for details. The following example is for MIT-compatible Kerberos 5 implementations:</p> <pre>kadmin% <strong class="userinput">ank -randkey postgres/server.my.domain.org</strong>
kadmin% <strong class="userinput">ktadd -k krb5.keytab postgres/server.my.domain.org</strong></pre> <p>When connecting to the database make sure you have a ticket for a principal matching the requested database user name. For example, for database user name <code class="literal">fred</code>, principal <code class="literal">fred@EXAMPLE.COM</code> would be able to connect. To also allow principal <code class="literal">fred/users.example.com@EXAMPLE.COM</code>, use a user name map, as described in <a class="xref" href="../auth-username-maps/" title="20.2. User Name Maps">Section 20.2</a>.</p> <p>The following configuration options are supported for GSSAPI:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">include_realm</code></dt> <dd> <p>If set to 0, the realm name from the authenticated user principal is stripped off before being passed through the user name mapping (<a class="xref" href="../auth-username-maps/" title="20.2. User Name Maps">Section 20.2</a>). This is discouraged and is primarily available for backwards compatibility, as it is not secure in multi-realm environments unless <code class="literal">krb_realm</code> is also used. It is recommended to leave <code class="literal">include_realm</code> set to the default (1) and to provide an explicit mapping in <code class="filename">pg_ident.conf</code> to convert principal names to PostgreSQL user names.</p> </dd> <dt><code class="literal">map</code></dt> <dd> <p>Allows for mapping between system and database user names. See <a class="xref" href="../auth-username-maps/" title="20.2. User Name Maps">Section 20.2</a> for details. For a GSSAPI/Kerberos principal, such as <code class="literal">username@EXAMPLE.COM</code> (or, less commonly, <code class="literal">username/hostbased@EXAMPLE.COM</code>), the user name used for mapping is <code class="literal">username@EXAMPLE.COM</code> (or <code class="literal">username/hostbased@EXAMPLE.COM</code>, respectively), unless <code class="literal">include_realm</code> has been set to 0, in which case <code class="literal">username</code> (or <code class="literal">username/hostbased</code>) is what is seen as the system user name when mapping.</p> </dd> <dt><code class="literal">krb_realm</code></dt> <dd> <p>Sets the realm to match user principal names against. If this parameter is set, only users of that realm will be accepted. If it is not set, users of any realm can connect, subject to whatever user name mapping is done.</p> </dd> </dl> </div> </div> <div class="sect2" id="SSPI-AUTH">    <h2 class="title">20.3.4. SSPI Authentication</h2>     <p>SSPI is a Windows technology for secure authentication with single sign-on. PostgreSQL will use SSPI in <code class="literal">negotiate</code> mode, which will use Kerberos when possible and automatically fall back to NTLM in other cases. SSPI authentication only works when both server and client are running Windows, or, on non-Windows platforms, when GSSAPI is available.</p> <p>When using Kerberos authentication, SSPI works the same way GSSAPI does; see <a class="xref" href="../auth-methods/#GSSAPI-AUTH" title="20.3.3. GSSAPI Authentication">Section 20.3.3</a> for details.</p> <p>The following configuration options are supported for SSPI:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">include_realm</code></dt> <dd> <p>If set to 0, the realm name from the authenticated user principal is stripped off before being passed through the user name mapping (<a class="xref" href="../auth-username-maps/" title="20.2. User Name Maps">Section 20.2</a>). This is discouraged and is primarily available for backwards compatibility, as it is not secure in multi-realm environments unless <code class="literal">krb_realm</code> is also used. It is recommended to leave <code class="literal">include_realm</code> set to the default (1) and to provide an explicit mapping in <code class="filename">pg_ident.conf</code> to convert principal names to PostgreSQL user names.</p> </dd> <dt><code class="literal">compat_realm</code></dt> <dd> <p>If set to 1, the domain's SAM-compatible name (also known as the NetBIOS name) is used for the <code class="literal">include_realm</code> option. This is the default. If set to 0, the true realm name from the Kerberos user principal name is used.</p> <p>Do not disable this option unless your server runs under a domain account (this includes virtual service accounts on a domain member system) and all clients authenticating through SSPI are also using domain accounts, or authentication will fail.</p> </dd> <dt><code class="literal">upn_username</code></dt> <dd> <p>If this option is enabled along with <code class="literal">compat_realm</code>, the user name from the Kerberos UPN is used for authentication. If it is disabled (the default), the SAM-compatible user name is used. By default, these two names are identical for new user accounts.</p> <p>Note that libpq uses the SAM-compatible name if no explicit user name is specified. If you use libpq or a driver based on it, you should leave this option disabled or explicitly specify user name in the connection string.</p> </dd> <dt><code class="literal">map</code></dt> <dd> <p>Allows for mapping between system and database user names. See <a class="xref" href="../auth-username-maps/" title="20.2. User Name Maps">Section 20.2</a> for details. For a SSPI/Kerberos principal, such as <code class="literal">username@EXAMPLE.COM</code> (or, less commonly, <code class="literal">username/hostbased@EXAMPLE.COM</code>), the user name used for mapping is <code class="literal">username@EXAMPLE.COM</code> (or <code class="literal">username/hostbased@EXAMPLE.COM</code>, respectively), unless <code class="literal">include_realm</code> has been set to 0, in which case <code class="literal">username</code> (or <code class="literal">username/hostbased</code>) is what is seen as the system user name when mapping.</p> </dd> <dt><code class="literal">krb_realm</code></dt> <dd> <p>Sets the realm to match user principal names against. If this parameter is set, only users of that realm will be accepted. If it is not set, users of any realm can connect, subject to whatever user name mapping is done.</p> </dd> </dl> </div> </div> <div class="sect2" id="AUTH-IDENT">    <h2 class="title">20.3.5. Ident Authentication</h2>     <p>The ident authentication method works by obtaining the client's operating system user name from an ident server and using it as the allowed database user name (with an optional user name mapping). This is only supported on TCP/IP connections.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>When ident is specified for a local (non-TCP/IP) connection, peer authentication (see <a class="xref" href="../auth-methods/#AUTH-PEER" title="20.3.6. Peer Authentication">Section 20.3.6</a>) will be used instead.</p> </blockquote> <p>The following configuration options are supported for ident:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">map</code></dt> <dd> <p>Allows for mapping between system and database user names. See <a class="xref" href="../auth-username-maps/" title="20.2. User Name Maps">Section 20.2</a> for details.</p> </dd> </dl> </div> <p>The <span class="quote">“<span class="quote">Identification Protocol</span>”</span> is described in RFC 1413. Virtually every Unix-like operating system ships with an ident server that listens on TCP port 113 by default. The basic functionality of an ident server is to answer questions like <span class="quote">“<span class="quote">What user initiated the connection that goes out of your port <code>X</code> and connects to my port <code>Y</code>?</span>”</span>. Since PostgreSQL knows both <code>X</code> and <code>Y</code> when a physical connection is established, it can interrogate the ident server on the host of the connecting client and can theoretically determine the operating system user for any given connection.</p> <p>The drawback of this procedure is that it depends on the integrity of the client: if the client machine is untrusted or compromised, an attacker could run just about any program on port 113 and return any user name they choose. This authentication method is therefore only appropriate for closed networks where each client machine is under tight control and where the database and system administrators operate in close contact. In other words, you must trust the machine running the ident server. Heed the warning:</p> <div class="blockquote"> <table class="blockquote" style="width: 100%; cellspacing: 0; cellpadding: 0;" summary="Block quote"> <tr> <td width="10%"> </td> <td width="80%"> <p>The Identification Protocol is not intended as an authorization or access control protocol.</p> </td> <td width="10%"> </td> </tr> <tr> <td width="10%"> </td> <td colspan="2" align="right">--<span class="attribution">RFC 1413</span>
</td> </tr> </table> </div> <p>Some ident servers have a nonstandard option that causes the returned user name to be encrypted, using a key that only the originating machine's administrator knows. This option <span class="emphasis"><em>must not</em></span> be used when using the ident server with PostgreSQL, since PostgreSQL does not have any way to decrypt the returned string to determine the actual user name.</p> </div> <div class="sect2" id="AUTH-PEER">    <h2 class="title">20.3.6. Peer Authentication</h2>     <p>The peer authentication method works by obtaining the client's operating system user name from the kernel and using it as the allowed database user name (with optional user name mapping). This method is only supported on local connections.</p> <p>The following configuration options are supported for peer:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">map</code></dt> <dd> <p>Allows for mapping between system and database user names. See <a class="xref" href="../auth-username-maps/" title="20.2. User Name Maps">Section 20.2</a> for details.</p> </dd> </dl> </div> <p>Peer authentication is only available on operating systems providing the <code class="function">getpeereid()</code> function, the <code class="symbol">SO_PEERCRED</code> socket parameter, or similar mechanisms. Currently that includes <span class="systemitem">Linux</span>, most flavors of <span class="systemitem">BSD</span> including <span class="systemitem">macOS</span>, and <span class="systemitem">Solaris</span>.</p> </div> <div class="sect2" id="AUTH-LDAP">    <h2 class="title">20.3.7. LDAP Authentication</h2>     <p>This authentication method operates similarly to <code class="literal">password</code> except that it uses LDAP as the password verification method. LDAP is used only to validate the user name/password pairs. Therefore the user must already exist in the database before LDAP can be used for authentication.</p> <p>LDAP authentication can operate in two modes. In the first mode, which we will call the simple bind mode, the server will bind to the distinguished name constructed as <code>prefix</code> <code>username</code> <code>suffix</code>. Typically, the <code>prefix</code> parameter is used to specify <code class="literal">cn=</code>, or <code>DOMAIN</code><code class="literal">\</code> in an Active Directory environment. <code>suffix</code> is used to specify the remaining part of the DN in a non-Active Directory environment.</p> <p>In the second mode, which we will call the search+bind mode, the server first binds to the LDAP directory with a fixed user name and password, specified with <code>ldapbinddn</code> and <code>ldapbindpasswd</code>, and performs a search for the user trying to log in to the database. If no user and password is configured, an anonymous bind will be attempted to the directory. The search will be performed over the subtree at <code>ldapbasedn</code>, and will try to do an exact match of the attribute specified in <code>ldapsearchattribute</code>. Once the user has been found in this search, the server disconnects and re-binds to the directory as this user, using the password specified by the client, to verify that the login is correct. This mode is the same as that used by LDAP authentication schemes in other software, such as Apache <code class="literal">mod_authnz_ldap</code> and <code class="literal">pam_ldap</code>. This method allows for significantly more flexibility in where the user objects are located in the directory, but will cause two separate connections to the LDAP server to be made.</p> <p>The following configuration options are used in both modes:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">ldapserver</code></dt> <dd> <p>Names or IP addresses of LDAP servers to connect to. Multiple servers may be specified, separated by spaces.</p> </dd> <dt><code class="literal">ldapport</code></dt> <dd> <p>Port number on LDAP server to connect to. If no port is specified, the LDAP library's default port setting will be used.</p> </dd> <dt><code class="literal">ldaptls</code></dt> <dd> <p>Set to 1 to make the connection between PostgreSQL and the LDAP server use TLS encryption. Note that this only encrypts the traffic to the LDAP server — the connection to the client will still be unencrypted unless SSL is used.</p> </dd> </dl> </div> <p>The following options are used in simple bind mode only:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">ldapprefix</code></dt> <dd> <p>String to prepend to the user name when forming the DN to bind as, when doing simple bind authentication.</p> </dd> <dt><code class="literal">ldapsuffix</code></dt> <dd> <p>String to append to the user name when forming the DN to bind as, when doing simple bind authentication.</p> </dd> </dl> </div> <p>The following options are used in search+bind mode only:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">ldapbasedn</code></dt> <dd> <p>Root DN to begin the search for the user in, when doing search+bind authentication.</p> </dd> <dt><code class="literal">ldapbinddn</code></dt> <dd> <p>DN of user to bind to the directory with to perform the search when doing search+bind authentication.</p> </dd> <dt><code class="literal">ldapbindpasswd</code></dt> <dd> <p>Password for user to bind to the directory with to perform the search when doing search+bind authentication.</p> </dd> <dt><code class="literal">ldapsearchattribute</code></dt> <dd> <p>Attribute to match against the user name in the search when doing search+bind authentication. If no attribute is specified, the <code class="literal">uid</code> attribute will be used.</p> </dd> <dt><code class="literal">ldapurl</code></dt> <dd> <p>An RFC 4516 LDAP URL. This is an alternative way to write some of the other LDAP options in a more compact and standard form. The format is</p> <pre data-language="sql">ldap://host[:port]/basedn[?[attribute][?[scope]]]</pre> <p><code>scope</code> must be one of <code class="literal">base</code>, <code class="literal">one</code>, <code class="literal">sub</code>, typically the latter. Only one attribute is used, and some other components of standard LDAP URLs such as filters and extensions are not supported.</p> <p>For non-anonymous binds, <code class="literal">ldapbinddn</code> and <code class="literal">ldapbindpasswd</code> must be specified as separate options.</p> <p>To use encrypted LDAP connections, the <code class="literal">ldaptls</code> option has to be used in addition to <code class="literal">ldapurl</code>. The <code class="literal">ldaps</code> URL scheme (direct SSL connection) is not supported.</p> <p>LDAP URLs are currently only supported with OpenLDAP, not on Windows.</p> </dd> </dl> </div> <p>It is an error to mix configuration options for simple bind with options for search+bind.</p> <p>Here is an example for a simple-bind LDAP configuration:</p> <pre data-language="sql">
host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"</pre> <p>When a connection to the database server as database user <code class="literal">someuser</code> is requested, PostgreSQL will attempt to bind to the LDAP server using the DN <code class="literal">cn=someuser, dc=example, dc=net</code> and the password provided by the client. If that connection succeeds, the database access is granted.</p> <p>Here is an example for a search+bind configuration:</p> <pre data-language="sql">
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid</pre> <p>When a connection to the database server as database user <code class="literal">someuser</code> is requested, PostgreSQL will attempt to bind anonymously (since <code class="literal">ldapbinddn</code> was not specified) to the LDAP server, perform a search for <code class="literal">(uid=someuser)</code> under the specified base DN. If an entry is found, it will then attempt to bind using that found information and the password supplied by the client. If that second connection succeeds, the database access is granted.</p> <p>Here is the same search+bind configuration written as a URL:</p> <pre data-language="sql">
host ... ldap ldapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"</pre> <p>Some other software that supports authentication against LDAP uses the same URL format, so it will be easier to share the configuration.</p> <blockquote class="tip"> <h3 class="title">Tip</h3> <p>Since LDAP often uses commas and spaces to separate the different parts of a DN, it is often necessary to use double-quoted parameter values when configuring LDAP options, as shown in the examples.</p> </blockquote> </div> <div class="sect2" id="AUTH-RADIUS">    <h2 class="title">20.3.8. RADIUS Authentication</h2>     <p>This authentication method operates similarly to <code class="literal">password</code> except that it uses RADIUS as the password verification method. RADIUS is used only to validate the user name/password pairs. Therefore the user must already exist in the database before RADIUS can be used for authentication.</p> <p>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type <code class="literal">Authenticate Only</code>, and include parameters for <code class="literal">user name</code>, <code class="literal">password</code> (encrypted) and <code class="literal">NAS Identifier</code>. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this server with either <code class="literal">Access Accept</code> or <code class="literal">Access Reject</code>. There is no support for RADIUS accounting.</p> <p>Multiple RADIUS servers can be specified, in which case they will be tried sequentially. If a negative response is received from a server, the authentication will fail. If no response is received, the next server in the list will be tried. To specify multiple servers, put the names within quotes and separate the server names with a comma. If multiple servers are specified, all other RADIUS options can also be given as a comma separate list, to apply individual values to each server. They can also be specified as a single value, in which case this value will apply to all servers.</p> <p>The following configuration options are supported for RADIUS:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">radiusservers</code></dt> <dd> <p>The name or IP addresses of the RADIUS servers to connect to. This parameter is required.</p> </dd> <dt><code class="literal">radiussecrets</code></dt> <dd> <p>The shared secrets used when talking securely to the RADIUS server. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>The encryption vector used will only be cryptographically strong if PostgreSQL is built with support for OpenSSL. In other cases, the transmission to the RADIUS server should only be considered obfuscated, not secured, and external security measures should be applied if necessary.</p> </blockquote> </dd> <dt><code class="literal">radiusports</code></dt> <dd> <p>The port number on the RADIUS servers to connect to. If no port is specified, the default port <code class="literal">1812</code> will be used.</p> </dd> <dt><code class="literal">radiusidentifiers</code></dt> <dd> <p>The string used as <code class="literal">NAS Identifier</code> in the RADIUS requests. This parameter can be used as a second parameter identifying for example which database user the user is attempting to authenticate as, which can be used for policy matching on the RADIUS server. If no identifier is specified, the default <code class="literal">postgresql</code> will be used.</p> </dd> </dl> </div> </div> <div class="sect2" id="AUTH-CERT">    <h2 class="title">20.3.9. Certificate Authentication</h2>     <p>This authentication method uses SSL client certificates to perform authentication. It is therefore only available for SSL connections. When using this authentication method, the server will require that the client provide a valid, trusted certificate. No password prompt will be sent to the client. The <code class="literal">cn</code> (Common Name) attribute of the certificate will be compared to the requested database user name, and if they match the login will be allowed. User name mapping can be used to allow <code class="literal">cn</code> to be different from the database user name.</p> <p>The following configuration options are supported for SSL certificate authentication:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">map</code></dt> <dd> <p>Allows for mapping between system and database user names. See <a class="xref" href="../auth-username-maps/" title="20.2. User Name Maps">Section 20.2</a> for details.</p> </dd> </dl> </div> <p>In a <code class="filename">pg_hba.conf</code> record specifying certificate authentication, the authentication option <code class="literal">clientcert</code> is assumed to be <code class="literal">1</code>, and it cannot be turned off since a client certificate is necessary for this method. What the <code class="literal">cert</code> method adds to the basic <code class="literal">clientcert</code> certificate validity test is a check that the <code class="literal">cn</code> attribute matches the database user name.</p> </div> <div class="sect2" id="AUTH-PAM">    <h2 class="title">20.3.10. PAM Authentication</h2>     <p>This authentication method operates similarly to <code class="literal">password</code> except that it uses PAM (Pluggable Authentication Modules) as the authentication mechanism. The default PAM service name is <code class="literal">postgresql</code>. PAM is used only to validate user name/password pairs and optionally the connected remote host name or IP address. Therefore the user must already exist in the database before PAM can be used for authentication. For more information about PAM, please read the <a class="ulink" href="http://www.kernel.org/pub/linux/libs/pam/" target="_blank">Linux-PAM Page</a>.</p> <p>The following configuration options are supported for PAM:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">pamservice</code></dt> <dd> <p>PAM service name.</p> </dd> <dt><code class="literal">pam_use_hostname</code></dt> <dd> <p>Determines whether the remote IP address or the host name is provided to PAM modules through the <code class="symbol">PAM_RHOST</code> item. By default, the IP address is used. Set this option to 1 to use the resolved host name instead. Host name resolution can lead to login delays. (Most PAM configurations don't use this information, so it is only necessary to consider this setting if a PAM configuration was specifically created to make use of it.)</p> </dd> </dl> </div> <blockquote class="note"> <h3 class="title">Note</h3> <p>If PAM is set up to read <code class="filename">/etc/shadow</code>, authentication will fail because the PostgreSQL server is started by a non-root user. However, this is not an issue when PAM is configured to use LDAP or other authentication methods.</p> </blockquote> </div> <div class="sect2" id="AUTH-BSD">    <h2 class="title">20.3.11. BSD Authentication</h2>     <p>This authentication method operates similarly to <code class="literal">password</code> except that it uses BSD Authentication to verify the password. BSD Authentication is used only to validate user name/password pairs. Therefore the user's role must already exist in the database before BSD Authentication can be used for authentication. The BSD Authentication framework is currently only available on OpenBSD.</p> <p>BSD Authentication in PostgreSQL uses the <code class="literal">auth-postgresql</code> login type and authenticates with the <code class="literal">postgresql</code> login class if that's defined in <code class="filename">login.conf</code>. By default that login class does not exist, and PostgreSQL will use the default login class.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>To use BSD Authentication, the PostgreSQL user account (that is, the operating system user running the server) must first be added to the <code class="literal">auth</code> group. The <code class="literal">auth</code> group exists by default on OpenBSD systems.</p> </blockquote> </div>  <div class="navfooter">  <table summary="Navigation footer"> <tr> <td width="40%" align="left">
<a accesskey="p" href="../auth-username-maps/">Prev</a> </td> <td width="20%" align="center"><a accesskey="u" href="https://www.postgresql.org/docs/10/static/client-authentication.html" target="_blank">Up</a></td> <td width="40%" align="right"> <a accesskey="n" href="../client-authentication-problems/">Next</a>
</td> </tr> <tr> <td width="40%" align="left">20.2. User Name Maps </td> <td width="20%" align="center"><a accesskey="h" href="https://www.postgresql.org/docs/10/static/index.html" target="_blank">Home</a></td> <td width="40%" align="right"> 20.4. Authentication Problems</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2018 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/10/static/auth-methods.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/10/static/auth-methods.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
