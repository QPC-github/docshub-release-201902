
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Form Validation - Angular 2 - W3cubDocs</title>
  
  <meta name="description" content=" Validate user&#39;s form entries. ">
  <meta name="keywords" content="form, validation, -, angular, angular~2">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/angular~2/cookbook/form-validation/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/angular~2.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angular~2/" class="_nav-link" title="" style="margin-left:0;">Angular 2</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _angular">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1>Form Validation </h1>

<blockquote class="banner"><p class="text-body">Validate user's form entries.</p></blockquote>
<p>Improve overall data quality by validating user input for accuracy and completeness.</p> <p>This cookbook shows how to validate user input in the UI and display useful validation messages using first the template-driven forms and then the reactive forms approach.</p> <blockquote class="l-sub-section">
<p>Read more about these choices in the <a href="../../guide/forms/">Forms</a> and the <a href="../../guide/reactive-forms/">Reactive Forms</a> guides.</p> </blockquote>
<h2 id="toc">Contents</h2> <ul> <li><a href="#template1">Simple template-driven forms</a></li> <li>
<a href="#template2">Template-driven forms with validation messages in code</a><ul> <li><a href="#component-class">Component Class</a></li> <li><a href="#improvement">The benefits of messages in code</a></li> <li><a href="#formmodule"><code>FormModule</code> and template-driven forms</a></li> </ul> </li> <li>
<a href="#reactive">Reactive forms with validation in code</a><ul> <li><a href="#reactive-forms-module">Switch to the <code>ReactiveFormsModule</code></a></li> <li><a href="#reactive-component-template">Component template</a></li> <li>
<a href="#reactive-component-class">Component class</a><ul> <li><a href="#formbuilder"><code>FormBuilder</code> declaration</a></li> <li><a href="#committing-changes">Committing hero value changes</a></li> </ul> </li> </ul> </li> <li>
<a href="#custom-validation">Custom validation</a><ul> <li><a href="#custom-validation-directive">Custom validation directive</a></li> </ul> </li> <li><a href="#testing">Testing considerations</a></li> </ul> <p id="live-example"><strong>Try the live example to see and download the full cookbook source code.</strong></p> <h2 id="template1">Simple template-driven forms</h2> <p>In the template-driven approach, you arrange <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms_in_HTML" target="_blank">form elements</a> in the component's template.</p> <p>You add Angular form directives (mostly directives beginning <code>ng...</code>) to help Angular construct a corresponding internal control model that implements form functionality. In template-drive forms, the control model is <em>implicit</em> in the template.</p> <p>To validate user input, you add <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation" target="_blank">HTML validation attributes</a> to the elements. Angular interprets those as well, adding validator functions to the control model.</p> <p>Angular exposes information about the state of the controls including whether the user has "touched" the control or made changes and if the control values are valid.</p> <p>In this first template validation example, notice the HTML that reads the control state and updates the display appropriately. Here's an excerpt from the template HTML for a single input control bound to the hero name:</p> <div class="code-example">
<h4 class="pre-title">template/hero-form-template1.component.html (Hero name)</h4>
<pre data-language="html">&lt;label for="name"&gt;Name&lt;/label&gt;

&lt;input type="text" id="name" class="form-control"
       required minlength="4" maxlength="24"
       name="name" [(ngModel)]="hero.name"
       #name="ngModel" &gt;

&lt;div *ngIf="name.errors &amp;&amp; (name.dirty || name.touched)"
     class="alert alert-danger"&gt;
    &lt;div [hidden]="!name.errors.required"&gt;
      Name is required
    &lt;/div&gt;
    &lt;div [hidden]="!name.errors.minlength"&gt;
      Name must be at least 4 characters long.
    &lt;/div&gt;
    &lt;div [hidden]="!name.errors.maxlength"&gt;
      Name cannot be more than 24 characters long.
    &lt;/div&gt;
&lt;/div&gt;
</pre>
</div>
<p>Note the following:</p> <ul> <li>
<p>The <code>&lt;input&gt;</code> element carries the HTML validation attributes: <code>required</code>, <code>minlength</code>, and <code>maxlength</code>.</p> </li> <li>
<p>The <code>name</code> attribute of the input is set to <code>"name"</code> so Angular can track this input element and associate it with an Angular form control called <code>name</code> in its internal control model.</p> </li> <li>
<p>The <code>[(ngModel)]</code> directive allows two-way data binding between the input box to the <code>hero.name</code> property.</p> </li> <li>
<p>The template variable (<code>#name</code>) has the value <code>"ngModel"</code> (always <code>ngModel</code>). This gives you a reference to the Angular <code>NgModel</code> directive associated with this control that you can use <em>in the template</em> to check for control states such as <code>valid</code> and <code>dirty</code>.</p> </li> <li>
<p>The <code>*ngIf</code> on the <code>&lt;div&gt;</code> element reveals a set of nested message <code>divs</code> but only if there are "name" errors and the control is either <code>dirty</code> or <code>touched</code>.</p> </li> <li>
<p>Each nested <code>&lt;div&gt;</code> can present a custom message for one of the possible validation errors. There are messages for <code>required</code>, <code>minlength</code>, and <code>maxlength</code>.</p> </li> </ul> <p>The full template repeats this kind of layout for each data entry control on the form.</p> <blockquote class="l-sub-section" id="why-check">
<h4 id="why-check-_dirty_-and-_touched_-">Why check <em>dirty</em> and <em>touched</em>?</h4> <p>The app shouldn't show errors for a new hero before the user has had a chance to edit the value. The checks for <code>dirty</code> and <code>touched</code> prevent premature display of errors.</p> <p>Learn about <code>dirty</code> and <code>touched</code> in the <a href="../../guide/forms/">Forms</a> guide.</p> </blockquote>
<p>The component class manages the hero model used in the data binding as well as other code to support the view.</p> <div class="code-example">
<h4 class="pre-title">template/hero-form-template1.component.ts (class)</h4>
<pre data-language="typescript">export class HeroFormTemplate1Component {

  powers = ['Really Smart', 'Super Flexible', 'Weather Changer'];

  hero = new Hero(18, 'Dr. WhatIsHisWayTooLongName', this.powers[0], 'Dr. What');

  submitted = false;

  onSubmit() {
    this.submitted = true;
  }

  addHero() {
    this.hero = new Hero(42, '', '');
  }
}
</pre>
</div>
<p>Use this template-driven validation technique when working with static forms with simple, standard validation rules.</p> <p>Here are the complete files for the first version of <code>HeroFormTemplateCompononent</code> in the template-driven approach:</p> <div class="pre-title">template/hero-form-template1.component.html</div>
<pre name="template/hero-form-template1.component.html" data-language="html">&lt;div class="container"&gt;
  &lt;div [hidden]="submitted"&gt;
    &lt;h1&gt;Hero Form 1 (Template)&lt;/h1&gt;
    &lt;form #heroForm="ngForm"  *ngIf="active"  (ngSubmit)="onSubmit()"&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="name"&gt;Name&lt;/label&gt;

        &lt;input type="text" id="name" class="form-control"
               required minlength="4" maxlength="24"
               name="name" [(ngModel)]="hero.name"
               #name="ngModel" &gt;

        &lt;div *ngIf="name.errors &amp;&amp; (name.dirty || name.touched)"
             class="alert alert-danger"&gt;
            &lt;div [hidden]="!name.errors.required"&gt;
              Name is required
            &lt;/div&gt;
            &lt;div [hidden]="!name.errors.minlength"&gt;
              Name must be at least 4 characters long.
            &lt;/div&gt;
            &lt;div [hidden]="!name.errors.maxlength"&gt;
              Name cannot be more than 24 characters long.
            &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class="form-group"&gt;
        &lt;label for="alterEgo"&gt;Alter Ego&lt;/label&gt;
        &lt;input type="text" id="alterEgo" class="form-control"
               name="alterEgo"
               [(ngModel)]="hero.alterEgo" &gt;
      &lt;/div&gt;

      &lt;div class="form-group"&gt;
        &lt;label for="power"&gt;Hero Power&lt;/label&gt;
        &lt;select id="power" class="form-control"
                name="power"
                [(ngModel)]="hero.power" required
                #power="ngModel" &gt;
          &lt;option *ngFor="let p of powers" [value]="p"&gt;{{p}}&lt;/option&gt;
        &lt;/select&gt;

        &lt;div *ngIf="power.errors &amp;&amp; power.touched" class="alert alert-danger"&gt;
          &lt;div [hidden]="!power.errors.required"&gt;Power is required&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;button type="submit" class="btn btn-default"
             [disabled]="!heroForm.form.valid"&gt;Submit&lt;/button&gt;
      &lt;button type="button" class="btn btn-default"
             (click)="addHero()"&gt;New Hero&lt;/button&gt;
    &lt;/form&gt;
  &lt;/div&gt;

  &lt;hero-submitted [hero]="hero" [(submitted)]="submitted"&gt;&lt;/hero-submitted&gt;
&lt;/div&gt;
</pre>
<div class="pre-title">template/hero-form-template1.component.ts</div>
<pre name="template/hero-form-template1.component.ts" data-language="typescript">import { Component } from '@angular/core';


import { Hero }      from '../shared/hero';

@Component({
  selector: 'hero-form-template1',
  templateUrl: './hero-form-template1.component.html'
})
export class HeroFormTemplate1Component {

  powers = ['Really Smart', 'Super Flexible', 'Weather Changer'];

  hero = new Hero(18, 'Dr. WhatIsHisWayTooLongName', this.powers[0], 'Dr. What');

  submitted = false;

  onSubmit() {
    this.submitted = true;
  }

  addHero() {
    this.hero = new Hero(42, '', '');
  }
}
</pre>
<h2 id="template2">Template-driven forms with validation messages in code</h2> <p>While the layout is straightforward, there are obvious shortcomings with the way it's handling validation messages:</p> <ul> <li>
<p>It takes a lot of HTML to represent all possible error conditions. This gets out of hand when there are many controls and many validation rules.</p> </li> <li>
<p>There's a lot of JavaScript logic in the HTML.</p> </li> <li>
<p>The messages are static strings, hard-coded into the template. It's easier to maintain <em>dynamic</em> messages in the component class.</p> </li> </ul> <p>In this example, you can move the logic and the messages into the component with a few changes to the template and component.</p> <p>Here's the hero name again, excerpted from the revised template (Template 2), next to the original version:</p> <div class="pre-title">hero-form-template2.component.html (name #2)</div>
<pre name="hero-form-template2.component.html (name #2)" data-language="html">        &lt;label for="name"&gt;Name&lt;/label&gt;

        &lt;input type="text" id="name" class="form-control"
               required minlength="4" maxlength="24" forbiddenName="bob"
               name="name" [(ngModel)]="hero.name" &gt;

        &lt;div *ngIf="formErrors.name" class="alert alert-danger"&gt;
          {{ formErrors.name }}
        &lt;/div&gt;
</pre>
<div class="pre-title">hero-form-template1.component.html (name #1)</div>
<pre name="hero-form-template1.component.html (name #1)" data-language="html">&lt;label for="name"&gt;Name&lt;/label&gt;

&lt;input type="text" id="name" class="form-control"
       required minlength="4" maxlength="24"
       name="name" [(ngModel)]="hero.name"
       #name="ngModel" &gt;

&lt;div *ngIf="name.errors &amp;&amp; (name.dirty || name.touched)"
     class="alert alert-danger"&gt;
    &lt;div [hidden]="!name.errors.required"&gt;
      Name is required
    &lt;/div&gt;
    &lt;div [hidden]="!name.errors.minlength"&gt;
      Name must be at least 4 characters long.
    &lt;/div&gt;
    &lt;div [hidden]="!name.errors.maxlength"&gt;
      Name cannot be more than 24 characters long.
    &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>The <code>&lt;input&gt;</code> element HTML is almost the same. There are noteworthy differences:</p> <ul> <li>
<p>The hard-code error message <code>&lt;divs&gt;</code> are gone.</p> </li> <li>
<p>There's a new attribute, <code>forbiddenName</code>, that is actually a custom validation directive. It invalidates the control if the user enters "bob" in the name <code>&lt;input&gt;</code>(<a href="#live-example">try it</a>). See the <a href="#custom-validation">custom validation</a> section later in this cookbook for more information on custom validation directives.</p> </li> <li>
<p>The <code>#name</code> template variable is gone because the app no longer refers to the Angular control for this element.</p> </li> <li>
<p>Binding to the new <code>formErrors.name</code> property is sufficent to display all name validation error messages.</p> </li> </ul> <h3 id="component-class">Component class</h3> <p>The original component code for Template 1 stayed the same; however, Template 2 requires some changes in the component. This section covers the code necessary in Template 2's component class to acquire the Angular form control and compose error messages.</p> <p>The first step is to acquire the form control that Angular created from the template by querying for it.</p> <p>Look back at the top of the component template at the <code>#heroForm</code> template variable in the <code>&lt;form&gt;</code> element:</p> <div class="code-example">
<h4 class="pre-title">template/hero-form-template1.component.html (form tag)</h4>
<pre data-language="html">&lt;form #heroForm="ngForm"  *ngIf="active"  (ngSubmit)="onSubmit()"&gt;
</pre>
</div>
<p>The <code>heroForm</code> variable is a reference to the control model that Angular derived from the template. Tell Angular to inject that model into the component class's <code>currentForm</code> property using a <code>@ViewChild</code> query:</p> <div class="code-example">
<h4 class="pre-title">template/hero-form-template2.component.ts (heroForm)</h4>
<pre data-language="typescript">heroForm: NgForm;
@ViewChild('heroForm') currentForm: NgForm;

ngAfterViewChecked() {
  this.formChanged();
}

formChanged() {
  if (this.currentForm === this.heroForm) { return; }
  this.heroForm = this.currentForm;
  if (this.heroForm) {
    this.heroForm.valueChanges
      .subscribe(data =&gt; this.onValueChanged(data));
  }
}
</pre>
</div>
<p>Some observations:</p> <ul> <li>
<p>Angular <code>@ViewChild</code> queries for a template variable when you pass it the name of that variable as a string (<code>'heroForm'</code> in this case).</p> </li> <li>
<p>The <code>heroForm</code> object changes several times during the life of the component, most notably when you add a new hero. Periodically inspecting it reveals these changes.</p> </li> <li>
<p>Angular calls the <code>ngAfterViewChecked</code> <a href="../../guide/lifecycle-hooks/#afterview">lifecycle hook method</a> when anything changes in the view. That's the right time to see if there's a new <code>heroForm</code> object.</p> </li> <li>
<p>When there <em>is</em> a new <code>heroForm</code> model, <code>formChanged()</code> subscribes to its <code>valueChanges</code> <em>Observable</em> property. The <code>onValueChanged</code> handler looks for validation errors after every keystroke. </p> </li> </ul> <div class="code-example">
<h4 class="pre-title">template/hero-form-template2.component.ts (handler)</h4>
<pre data-language="typescript">onValueChanged(data?: any) {
  if (!this.heroForm) { return; }
  const form = this.heroForm.form;

  for (const field in this.formErrors) {
    // clear previous error message (if any)
    this.formErrors[field] = '';
    const control = form.get(field);

    if (control &amp;&amp; control.dirty &amp;&amp; !control.valid) {
      const messages = this.validationMessages[field];
      for (const key in control.errors) {
        this.formErrors[field] += messages[key] + ' ';
      }
    }
  }
}

formErrors = {
  'name': '',
  'power': ''
};
</pre>
</div>
<p>The <code>onValueChanged</code> handler interprets user data entry. The <code>data</code> object passed into the handler contains the current element values. The handler ignores them. Instead, it iterates over the fields of the component's <code>formErrors</code> object.</p> <p>The <code>formErrors</code> is a dictionary of the hero fields that have validation rules and their current error messages. Only two hero properties have validation rules, <code>name</code> and <code>power</code>. The messages are empty strings when the hero data are valid.</p> <p>For each field, the <code>onValueChanged</code> handler does the following:</p> <ul> <li>Clears the prior error message, if any.</li> <li>Acquires the field's corresponding Angular form control. </li> <li>If such a control exists <em>and</em> it's been changed ("dirty") <em>and</em> it's invalid, the handler composes a consolidated error message for all of the control's errors.</li> </ul> <p>Next, the component needs some error messages of course—a set for each validated property with one message per validation rule:</p> <div class="code-example">
<h4 class="pre-title">template/hero-form-template2.component.ts (messages)</h4>
<pre data-language="typescript">validationMessages = {
  'name': {
    'required':      'Name is required.',
    'minlength':     'Name must be at least 4 characters long.',
    'maxlength':     'Name cannot be more than 24 characters long.',
    'forbiddenName': 'Someone named "Bob" cannot be a hero.'
  },
  'power': {
    'required': 'Power is required.'
  }
};
</pre>
</div>
<p>Now every time the user makes a change, the <code>onValueChanged</code> handler checks for validation errors and produces messages accordingly.</p> <h3 id="improvement">The benefits of messages in code</h3> <p>Clearly the template got substantially smaller while the component code got substantially larger. It's not easy to see the benefit when there are just three fields and only two of them have validation rules.</p> <p>Consider what happens as the number of validated fields and rules increases. In general, HTML is harder to read and maintain than code. The initial template was already large and threatening to get rapidly worse with the addition of more validation message <code>&lt;div&gt;</code> elements.</p> <p>After moving the validation messaging to the component, the template grows more slowly and proportionally. Each field has approximately the same number of lines no matter its number of validation rules. The component also grows proportionally, at the rate of one line per validated field and one line per validation message.</p> <p>Both trends are manageable.</p> <p>Now that the messages are in code, you have more flexibility and can compose messages more efficiently. You can refactor the messages out of the component, perhaps to a service class that retrieves them from the server. In short, there are more opportunities to improve message handling now that text and logic have moved from template to code.</p> <h3 id="formmodule">
<em>FormModule</em> and template-driven forms</h3> <p>Angular has two different forms modules—<code>FormsModule</code> and <code>ReactiveFormsModule</code>—that correspond with the two approaches to form development. Both modules come from the same <code>@angular/forms</code> library package.</p> <p>You've been reviewing the "Template-driven" approach which requires the <code>FormsModule</code>. Here's how you imported it in the <code>HeroFormTemplateModule</code>.</p> <div class="code-example">
<h4 class="pre-title">template/hero-form-template.module.ts</h4>
<pre data-language="typescript">import { NgModule }     from '@angular/core';
import { FormsModule }  from '@angular/forms';

import { SharedModule }               from '../shared/shared.module';
import { HeroFormTemplate1Component } from './hero-form-template1.component';
import { HeroFormTemplate2Component } from './hero-form-template2.component';

@NgModule({
  imports:      [ SharedModule, FormsModule ],
  declarations: [ HeroFormTemplate1Component, HeroFormTemplate2Component ],
  exports:      [ HeroFormTemplate1Component, HeroFormTemplate2Component ]
})
export class HeroFormTemplateModule { }
</pre>
</div>
<blockquote class="l-sub-section">
<p>This guide hasn't talked about the <code>SharedModule</code> or its <code>SubmittedComponent</code> which appears at the bottom of every form template in this cookbook. </p> <p>They're not germane to the validation story. Look at the <a href="#live-example">live example</a> if you're interested.</p> </blockquote>
<h2 id="reactive">Reactive forms with validation in code</h2> <p>In the template-driven approach, you markup the template with form elements, validation attributes, and <code>ng...</code> directives from the Angular <code>FormsModule</code>. At runtime, Angular interprets the template and derives its <em>form control model</em>.</p> <p><strong>Reactive Forms</strong> takes a different approach. You create the form control model in code. You write the template with form elements and <code>form...</code> directives from the Angular <code>ReactiveFormsModule</code>. At runtime, Angular binds the template elements to your control model based on your instructions.</p> <p>This approach requires a bit more effort. <em>You have to write the control model and manage it</em>.</p> <p>This allows you to do the following:</p> <ul> <li>Add, change, and remove validation functions on the fly.</li> <li>Manipulate the control model dynamically from within the component.</li> <li>
<a href="#testing">Test</a> validation and control logic with isolated unit tests.</li> </ul> <p>The following cookbook sample re-writes the hero form in <em>reactive forms</em> style.</p> <h3 id="reactive-forms-module">Switch to the <em>ReactiveFormsModule</em>
</h3> <p>The reactive forms classes and directives come from the Angular <code>ReactiveFormsModule</code>, not the <code>FormsModule</code>. The application module for the reactive forms feature in this sample looks like this:</p> <div class="code-example">
<h4 class="pre-title">src/app/reactive/hero-form-reactive.module.ts</h4>
<pre data-language="typescript">import { NgModule }            from '@angular/core';
import { ReactiveFormsModule } from '@angular/forms';

import { SharedModule }              from '../shared/shared.module';
import { HeroFormReactiveComponent } from './hero-form-reactive.component';

@NgModule({
  imports:      [ SharedModule, ReactiveFormsModule ],
  declarations: [ HeroFormReactiveComponent ],
  exports:      [ HeroFormReactiveComponent ]
})
export class HeroFormReactiveModule { }
</pre>
</div>
<p>The reactive forms feature module and component are in the <code>src/app/reactive</code> folder. Focus on the <code>HeroFormReactiveComponent</code> there, starting with its template.</p> <h3 id="reactive-component-template">Component template</h3> <p>Begin by changing the <code>&lt;form&gt;</code> tag so that it binds the Angular <code>formGroup</code> directive in the template to the <code>heroForm</code> property in the component class. The <code>heroForm</code> is the control model that the component class builds and maintains.</p> <div class="code-example"><pre data-language="html">&lt;form [formGroup]="heroForm"  *ngIf="active"  (ngSubmit)="onSubmit()"&gt;
</pre></div>
<p>Next, modify the template HTML elements to match the <em>reactive forms</em> style. Here is the "name" portion of the template again, revised for reactive forms and compared with the template-driven version:</p> <div class="pre-title">hero-form-reactive.component.html (name #3)</div>
<pre name="hero-form-reactive.component.html (name #3)" data-language="html">&lt;label for="name"&gt;Name&lt;/label&gt;

&lt;input type="text" id="name" class="form-control"
       formControlName="name" required &gt;

&lt;div *ngIf="formErrors.name" class="alert alert-danger"&gt;
  {{ formErrors.name }}
&lt;/div&gt;
</pre>
<div class="pre-title">hero-form-template1.component.html (name #2)</div>
<pre name="hero-form-template1.component.html (name #2)" data-language="html">        &lt;label for="name"&gt;Name&lt;/label&gt;

        &lt;input type="text" id="name" class="form-control"
               required minlength="4" maxlength="24" forbiddenName="bob"
               name="name" [(ngModel)]="hero.name" &gt;

        &lt;div *ngIf="formErrors.name" class="alert alert-danger"&gt;
          {{ formErrors.name }}
        &lt;/div&gt;
</pre>
<p>Key changes are:</p> <ul> <li>
<p>The validation attributes are gone (except <code>required</code>) because validating happens in code.</p> </li> <li>
<p><code>required</code> remains, not for validation purposes (that's in the code), but rather for css styling and accessibility.</p> </li> </ul> <blockquote class="l-sub-section">
<p>A future version of reactive forms will add the <code>required</code> HTML validation attribute to the DOM element (and perhaps the <code>aria-required</code> attribute) when the control has the <code>required</code> validator function. </p> <p>Until then, apply the <code>required</code> attribute <em>and</em> add the <code>Validator.required</code> function to the control model, as you'll see below.</p> </blockquote>
<ul> <li>
<p>The <code>formControlName</code> replaces the <code>name</code> attribute; it serves the same purpose of correlating the input with the Angular form control.</p> </li> <li>
<p>The two-way <code>[(ngModel)]</code> binding is gone. The reactive approach does not use data binding to move data into and out of the form controls. That's all in code.</p> </li> </ul> <blockquote class="l-sub-section">
<p>The retreat from data binding is a principle of the reactive paradigm rather than a technical limitation.</p> </blockquote>
<h3 id="reactive-component-class">Component class</h3> <p>The component class is now responsible for defining and managing the form control model. </p> <p>Angular no longer derives the control model from the template so you can no longer query for it. You can create the Angular form control model explicitly with the help of the <code>FormBuilder</code> class.</p> <p>Here's the section of code devoted to that process, paired with the template-driven code it replaces:</p> <div class="pre-title">reactive/hero-form-reactive.component.ts (FormBuilder)</div>
<pre name="reactive/hero-form-reactive.component.ts (FormBuilder)" data-language="typescript">  heroForm: FormGroup;
  constructor(private fb: FormBuilder) { }

  ngOnInit(): void {
    this.buildForm();
  }

  buildForm(): void {
    this.heroForm = this.fb.group({
      'name': [this.hero.name, [
          Validators.required,
          Validators.minLength(4),
          Validators.maxLength(24),
          forbiddenNameValidator(/bob/i)
        ]
      ],
      'alterEgo': [this.hero.alterEgo],
      'power':    [this.hero.power, Validators.required]
    });

    this.heroForm.valueChanges
      .subscribe(data =&gt; this.onValueChanged(data));

    this.onValueChanged(); // (re)set validation messages now
  }
</pre>
<div class="pre-title">template/hero-form-template2.component.ts (ViewChild)</div>
<pre name="template/hero-form-template2.component.ts (ViewChild)" data-language="typescript">heroForm: NgForm;
@ViewChild('heroForm') currentForm: NgForm;

ngAfterViewChecked() {
  this.formChanged();
}

formChanged() {
  if (this.currentForm === this.heroForm) { return; }
  this.heroForm = this.currentForm;
  if (this.heroForm) {
    this.heroForm.valueChanges
      .subscribe(data =&gt; this.onValueChanged(data));
  }
}
</pre>
<ul> <li>
<p>Inject <code>FormBuilder</code> in a constructor.</p> </li> <li>
<p>Call a <code>buildForm</code> method in the <code>ngOnInit</code> <a href="../../guide/lifecycle-hooks/#hooks-overview">lifecycle hook method</a> because that's when you'll have the hero data. Call it again in the <code>addHero</code> method.</p> </li> </ul> <blockquote class="l-sub-section">
<p>A real app would retrieve the hero asynchronously from a data service, a task best performed in the <code>ngOnInit</code> hook.</p> </blockquote>
<ul> <li>The <code>buildForm</code> method uses the <code>FormBuilder</code>, <code>fb</code>, to declare the form control model. Then it attaches the same <code>onValueChanged</code> handler (there's a one line difference) to the form's <code>valueChanges</code> event and calls it immediately to set error messages for the new control model.</li> </ul> <h4 id="formbuilder">
<em>FormBuilder</em> declaration</h4> <p>The <code>FormBuilder</code> declaration object specifies the three controls of the sample's hero form. </p> <p>Each control spec is a control name with an array value. The first array element is the current value of the corresponding hero field. The optional second value is a validator function or an array of validator functions.</p> <p>Most of the validator functions are stock validators provided by Angular as static methods of the <code>Validators</code> class. Angular has stock validators that correspond to the standard HTML validation attributes.</p> <p>The <code>forbiddenNames</code> validator on the <code>"name"</code> control is a custom validator, discussed in a separate <a href="#custom-validation">section below</a>.</p> <blockquote class="l-sub-section"> <p>Learn more about <code>FormBuilder</code> in the <a href="../../guide/reactive-forms/#formbuilder">Introduction to FormBuilder</a> section of Reactive Forms guide. </p> </blockquote>
<h4 id="committing-changes">Committing hero value changes</h4> <p>In two-way data binding, the user's changes flow automatically from the controls back to the data model properties. Reactive forms do not use data binding to update data model properties. The developer decides <em>when and how</em> to update the data model from control values.</p> <p>This sample updates the model twice:</p> <ol> <li>When the user submits the form.</li> <li>When the user adds a new hero.</li> </ol> <p>The <code>onSubmit()</code> method simply replaces the <code>hero</code> object with the combined values of the form:</p> <div class="code-example"><pre data-language="typescript">onSubmit() {
  this.submitted = true;
  this.hero = this.heroForm.value;
}
</pre></div>
<blockquote class="l-sub-section">
<p>This example is lucky in that the <code>heroForm.value</code> properties <em>just happen</em> to correspond <em>exactly</em> to the hero data object properties.</p> </blockquote>
<p>The <code>addHero()</code> method discards pending changes and creates a brand new <code>hero</code> model object.</p> <div class="code-example"><pre data-language="typescript">addHero() {
  this.hero = new Hero(42, '', '');
  this.buildForm();
}
</pre></div>
<p>Then it calls <code>buildForm()</code> again which replaces the previous <code>heroForm</code> control model with a new one. The <code>&lt;form&gt;</code> tag's <code>[formGroup]</code> binding refreshes the page with the new control model.</p> <p>Here's the complete reactive component file, compared to the two template-driven component files.</p> <div class="pre-title">reactive/hero-form-reactive.component.ts (#3)</div>
<pre name="reactive/hero-form-reactive.component.ts (#3)" data-language="typescript">import { Component, OnInit }                  from '@angular/core';
import { FormGroup, FormBuilder, Validators } from '@angular/forms';

import { Hero }                   from '../shared/hero';
import { forbiddenNameValidator } from '../shared/forbidden-name.directive';

@Component({
  selector: 'hero-form-reactive3',
  templateUrl: './hero-form-reactive.component.html'
})
export class HeroFormReactiveComponent implements OnInit {

  powers = ['Really Smart', 'Super Flexible', 'Weather Changer'];

  hero = new Hero(18, 'Dr. WhatIsHisName', this.powers[0], 'Dr. What');

  submitted = false;

  onSubmit() {
    this.submitted = true;
    this.hero = this.heroForm.value;
  }
  }

  heroForm: FormGroup;
  constructor(private fb: FormBuilder) { }

  ngOnInit(): void {
    this.buildForm();
  }

  buildForm(): void {
    this.heroForm = this.fb.group({
      'name': [this.hero.name, [
          Validators.required,
          Validators.minLength(4),
          Validators.maxLength(24),
          forbiddenNameValidator(/bob/i)
        ]
      ],
      'alterEgo': [this.hero.alterEgo],
      'power':    [this.hero.power, Validators.required]
    });

    this.heroForm.valueChanges
      .subscribe(data =&gt; this.onValueChanged(data));

    this.onValueChanged(); // (re)set validation messages now
  }


  onValueChanged(data?: any) {
    if (!this.heroForm) { return; }
    const form = this.heroForm;

    for (const field in this.formErrors) {
      // clear previous error message (if any)
      this.formErrors[field] = '';
      const control = form.get(field);

      if (control &amp;&amp; control.dirty &amp;&amp; !control.valid) {
        const messages = this.validationMessages[field];
        for (const key in control.errors) {
          this.formErrors[field] += messages[key] + ' ';
        }
      }
    }
  }

  formErrors = {
    'name': '',
    'power': ''
  };

  validationMessages = {
    'name': {
      'required':      'Name is required.',
      'minlength':     'Name must be at least 4 characters long.',
      'maxlength':     'Name cannot be more than 24 characters long.',
      'forbiddenName': 'Someone named "Bob" cannot be a hero.'
    },
    'power': {
      'required': 'Power is required.'
    }
  };
}
</pre>
<div class="pre-title">template/hero-form-template2.component.ts (#2)</div>
<pre name="template/hero-form-template2.component.ts (#2)" data-language="typescript">import { Component, AfterViewChecked, ViewChild } from '@angular/core';
import { NgForm } from '@angular/forms';

import { Hero }      from '../shared/hero';

@Component({
  selector: 'hero-form-template2',
  templateUrl: './hero-form-template2.component.html'
})
export class HeroFormTemplate2Component implements AfterViewChecked {

  powers = ['Really Smart', 'Super Flexible', 'Weather Changer'];

  hero = new Hero(18, 'Dr. WhatIsHisWayTooLongName', this.powers[0], 'Dr. What');

  submitted = false;

  onSubmit() {
    this.submitted = true;
  }

  addHero() {
    this.hero = new Hero(42, '', '');
  }

  heroForm: NgForm;
  @ViewChild('heroForm') currentForm: NgForm;

  ngAfterViewChecked() {
    this.formChanged();
  }

  formChanged() {
    if (this.currentForm === this.heroForm) { return; }
    this.heroForm = this.currentForm;
    if (this.heroForm) {
      this.heroForm.valueChanges
        .subscribe(data =&gt; this.onValueChanged(data));
    }
  }

  onValueChanged(data?: any) {
    if (!this.heroForm) { return; }
    const form = this.heroForm.form;

    for (const field in this.formErrors) {
      // clear previous error message (if any)
      this.formErrors[field] = '';
      const control = form.get(field);

      if (control &amp;&amp; control.dirty &amp;&amp; !control.valid) {
        const messages = this.validationMessages[field];
        for (const key in control.errors) {
          this.formErrors[field] += messages[key] + ' ';
        }
      }
    }
  }

  formErrors = {
    'name': '',
    'power': ''
  };

  validationMessages = {
    'name': {
      'required':      'Name is required.',
      'minlength':     'Name must be at least 4 characters long.',
      'maxlength':     'Name cannot be more than 24 characters long.',
      'forbiddenName': 'Someone named "Bob" cannot be a hero.'
    },
    'power': {
      'required': 'Power is required.'
    }
  };
}
</pre>
<div class="pre-title">template/hero-form-template1.component.ts (#1)</div>
<pre name="template/hero-form-template1.component.ts (#1)" data-language="typescript">import { Component } from '@angular/core';


import { Hero }      from '../shared/hero';

@Component({
  selector: 'hero-form-template1',
  templateUrl: './hero-form-template1.component.html'
})
export class HeroFormTemplate1Component {

  powers = ['Really Smart', 'Super Flexible', 'Weather Changer'];

  hero = new Hero(18, 'Dr. WhatIsHisWayTooLongName', this.powers[0], 'Dr. What');

  submitted = false;

  onSubmit() {
    this.submitted = true;
  }

  addHero() {
    this.hero = new Hero(42, '', '');
  }
}
</pre>
<blockquote class="l-sub-section">
<p>Run the <a href="#live-example">live example</a> to see how the reactive form behaves, and to compare all of the files in this cookbook sample.</p> </blockquote>
<h2 id="custom-validation">Custom validation</h2> <p>This cookbook sample has a custom <code>forbiddenNamevalidator()</code> function that's applied to both the template-driven and the reactive form controls. It's in the <code>src/app/shared</code> folder and declared in the <code>SharedModule</code>.</p> <p>Here's the <code>forbiddenNamevalidator()</code> function:</p> <div class="code-example">
<h4 class="pre-title">shared/forbidden-name.directive.ts (forbiddenNameValidator)</h4>
<pre data-language="typescript">/** A hero's name can't match the given regular expression */
export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {
  return (control: AbstractControl): {[key: string]: any} =&gt; {
    const name = control.value;
    const no = nameRe.test(name);
    return no ? {'forbiddenName': {name}} : null;
  };
}
</pre>
</div>
<p>The function is actually a factory that takes a regular expression to detect a <em>specific</em> forbidden name and returns a validator function.</p> <p>In this sample, the forbidden name is "bob"; the validator rejects any hero name containing "bob". Elsewhere it could reject "alice" or any name that the configuring regular expression matches.</p> <p>The <code>forbiddenNameValidator</code> factory returns the configured validator function. That function takes an Angular control object and returns <em>either</em> null if the control value is valid <em>or</em> a validation error object. The validation error object typically has a property whose name is the validation key, <code>'forbiddenName'</code>, and whose value is an arbitrary dictionary of values that you could insert into an error message (<code>{name}</code>).</p> <h3 id="custom-validation-directive">Custom validation directive</h3> <p>In the reactive forms component, the <code>'name'</code> control's validator function list has a <code>forbiddenNameValidator</code> at the bottom.</p> <div class="code-example">
<h4 class="pre-title">reactive/hero-form-reactive.component.ts (name validators)</h4>
<pre data-language="typescript">'name': [this.hero.name, [
    Validators.required,
    Validators.minLength(4),
    Validators.maxLength(24),
    forbiddenNameValidator(/bob/i)
  ]
],
</pre>
</div>
<p>In the <em>template-driven</em> example, the <code>&lt;input&gt;</code> has the selector (<code>forbiddenName</code>) of a custom <em>attribute directive</em>, which rejects "bob".</p> <div class="code-example">
<h4 class="pre-title">template/hero-form-template2.component.html (name input)</h4>
<pre data-language="html">&lt;input type="text" id="name" class="form-control"
       required minlength="4" maxlength="24" forbiddenName="bob"
       name="name" [(ngModel)]="hero.name" &gt;
</pre>
</div>
<p>The corresponding <code>ForbiddenValidatorDirective</code> is a wrapper around the <code>forbiddenNameValidator</code>.</p> <p>Angular <code>forms</code> recognizes the directive's role in the validation process because the directive registers itself with the <code>NG_VALIDATORS</code> provider, a provider with an extensible collection of validation directives.</p> <div class="code-example">
<h4 class="pre-title">shared/forbidden-name.directive.ts (providers)</h4>
<pre data-language="typescript">providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}]
</pre>
</div>
<p>Here is the rest of the directive to help you get an idea of how it all comes together:</p> <div class="code-example">
<h4 class="pre-title">shared/forbidden-name.directive.ts (directive)</h4>
<pre data-language="typescript">@Directive({
  selector: '[forbiddenName]',
  providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}]
})
export class ForbiddenValidatorDirective implements Validator, OnChanges {
  @Input() forbiddenName: string;
  private valFn = Validators.nullValidator;

  ngOnChanges(changes: SimpleChanges): void {
    const change = changes['forbiddenName'];
    if (change) {
      const val: string | RegExp = change.currentValue;
      const re = val instanceof RegExp ? val : new RegExp(val, 'i');
      this.valFn = forbiddenNameValidator(re);
    } else {
      this.valFn = Validators.nullValidator;
    }
  }

  validate(control: AbstractControl): {[key: string]: any} {
    return this.valFn(control);
  }
}
</pre>
</div>
<blockquote class="l-sub-section">
<p>If you are familiar with Angular validations, you may have noticed that the custom validation directive is instantiated with <code>useExisting</code> rather than <code>useClass</code>. The registered validator must be <em>this instance</em> of the <code>ForbiddenValidatorDirective</code>—the instance in the form with its <code>forbiddenName</code> property bound to “bob". If you were to replace <code>useExisting</code> with <code>useClass</code>, then you’d be registering a new class instance, one that doesn’t have a <code>forbiddenName</code>.</p> <p>To see this in action, run the example and then type “bob” in the name of Hero Form 2. Notice that you get a validation error. Now change from <code>useExisting</code> to <code>useClass</code> and try again. This time, when you type “bob”, there's no "bob" error message.</p> </blockquote>
<blockquote class="l-sub-section">
<p>For more information on attaching behavior to elements, see <a href="../../guide/attribute-directives/">Attribute Directives</a>.</p> </blockquote>
<h2 id="testing">Testing Considerations</h2> <p>You can write <em>isolated unit tests</em> of validation and control logic in <em>Reactive Forms</em>.</p> <p><em>Isolated unit tests</em> probe the component class directly, independent of its interactions with its template, the DOM, other dependencies, or Angular itself.</p> <p>Such tests have minimal setup, are quick to write, and easy to maintain. They do not require the <code>Angular TestBed</code> or asynchronous testing practices.</p> <p>That's not possible with <em>template-driven</em> forms. The template-driven approach relies on Angular to produce the control model and to derive validation rules from the HTML validation attributes. You must use the <code>Angular TestBed</code> to create component test instances, write asynchronous tests, and interact with the DOM.</p> <p>While not difficult, this takes more time, work and skill—factors that tend to diminish test code coverage and quality.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://v2.angular.io/docs/ts/latest/cookbook/form-validation.html" class="_attribution-link" target="_blank">https://v2.angular.io/docs/ts/latest/cookbook/form-validation.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
