
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>TypeScript to JavaScript - Angular 2 - W3cubDocs</title>
  
  <meta name="description" content=" Convert Angular TypeScript examples into ES6 and ES5 JavaScript. ">
  <meta name="keywords" content="typescript, javascript, -, angular, angular~2">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/angular~2/cookbook/ts-to-js/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/angular~2.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angular~2/" class="_nav-link" title="" style="margin-left:0;">Angular 2</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _angular">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1>TypeScript to JavaScript </h1>

<blockquote class="banner"><p class="text-body">Convert Angular TypeScript examples into ES6 and ES5 JavaScript.</p></blockquote>
<p>Anything you can do with Angular in <em>TypeScript</em>, you can also do in JavaScript. Translating from one language to the other is mostly a matter of changing the way you organize your code and access Angular APIs.</p> <p><em>TypeScript</em> is a popular language option for Angular development. Most code examples on the Internet as well as on this site are written in <em>TypeScript</em>. This cookbook contains recipes for translating <em>TypeScript</em> code examples to <em>ES6</em> and to <em>ES5</em> so that JavaScript developers can read and write Angular apps in their preferred dialect.</p> <h2 id="toc">Table of contents</h2> <p><a href="#from-ts"><em>TypeScript</em> to <em>ES6</em> to <em>ES5</em></a> <a href="#modularity">Modularity: imports and exports</a> <a href="#class-metadata">Classes and Class Metadata</a> <a href="#dsl"><em>ES5</em> DSL</a> <a href="#interfaces">Interfaces</a> <a href="#io-decorators">Input and Output Metadata</a> <a href="#dependency-injection">Dependency Injection</a> <a href="#host-binding">Host Binding</a> <a href="#view-child-decorators">View and Child Decorators</a> <a href="#aot">AOT compilation in <em>TypeScript</em> Only</a></p> <p><strong>Run and compare the live <span name="cb-ts-to-js"><em>TypeScript</em></span> and <span name="cb-ts-to-js" lang="js">JavaScript</span> code shown in this cookbook.</strong></p> <h2 id="from-ts">
<em>TypeScript</em> to <em>ES6</em> to <em>ES5</em>
</h2> <p><em>TypeScript</em> <a href="https://www.typescriptlang.org" target="_blank" title='"TypeScript is a typed, superset of JavaScript"'>is a typed superset of <em>ES6 JavaScript</em></a>. <em>ES6 JavaScript</em> is a superset of <em>ES5 JavaScript</em>. <em>ES5</em> is the kind of JavaScript that runs natively in all modern browsers. The transformation of <em>TypeScript</em> code all the way down to <em>ES5</em> code can be seen as "shedding" features.</p> <p>The downgrade progression is</p> <ul> <li>
<em>TypeScript</em> to <em>ES6-with-decorators</em>
</li> <li>
<em>ES6-with-decorators</em> to <em>ES6-without-decorators</em> ("<em>plain ES6</em>")</li> <li>
<em>ES6-without-decorators</em> to <em>ES5</em>
</li> </ul> <p>When translating from <em>TypeScript</em> to <em>ES6-with-decorators</em>, remove <a href="http://www.typescriptlang.org/docs/handbook/classes.html#public-private-and-protected-modifiers" target="_blank">class property access modifiers</a> such as <code>public</code> and <code>private</code>. Remove most of the <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank">type declarations</a>, such as <code>:string</code> and <code>:boolean</code> but <strong>keep the constructor parameter types which are used for dependency injection</strong>.</p> <p>From <em>ES6-with-decorators</em> to <em>plain ES6</em>, remove all <a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank">decorators</a> and the remaining types. You must declare properties in the class constructor (<code>this.title = '...'</code>) rather than in the body of the class.</p> <p>Finally, from <em>plain ES6</em> to <em>ES5</em>, the main missing features are <code>import</code> statements and <code>class</code> declarations. </p> <p>For <em>plain ES6</em> transpilation you can <em>start</em> with a setup similar to the <a href="https://github.com/angular/quickstart" target="_blank"><em>TypeScript</em> quickstart</a> and adjust the application code accordingly. Transpile with <a href="https://babeljs.io/" target="_blank">Babel</a> using the <code>es2015</code> preset. To use decorators and annotations with Babel, install the <a href="https://github.com/shuhei/babel-plugin-angular2-annotations" target="_blank"><code>angular2</code></a> preset as well.</p> <h2 id="modularity">Importing and Exporting</h2> <h3 id="importing-angular-code">Importing Angular Code</h3> <p>In both <em>TypeScript</em> and <em>ES6</em>, you import Angular classes, functions, and other members with <em>ES6</em> <code>import</code> statements.</p> <p>In <em>ES5</em>, you access the Angular entities of the <a href="../../glossary/#scoped-package">the Angular packages</a> through the global <code>ng</code> object. Anything you can import from <code>@angular</code> is a nested member of this <code>ng</code> object:</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import {
  LocationStrategy,
  HashLocationStrategy
} from '@angular/common';
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import {
  LocationStrategy,
  HashLocationStrategy
} from '@angular/common';
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import {
  LocationStrategy,
  HashLocationStrategy
} from '@angular/common';
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">var platformBrowserDynamic = ng.platformBrowserDynamic.platformBrowserDynamic;
var LocationStrategy = ng.common.LocationStrategy;
var HashLocationStrategy = ng.common.HashLocationStrategy;
</pre>
<h3 id="exporting-application-code">Exporting Application Code</h3> <p>Each file in a <em>TypeScript</em> or <em>ES6</em> Angular application constitutes an <em>ES6</em> module. When you want to make something available to other modules, you <code>export</code> it.</p> <p><em>ES5</em> lacks native support for modules. In an Angular <em>ES5</em> application, you load each file manually by adding a <code>&lt;script&gt;</code> tag to <code>index.html</code>. </p> <blockquote class="alert is-important">
<p>The order of <code>&lt;script&gt;</code> tags is often significant. You must load a file that defines a public JavaScript entity before a file that references that entity.</p> </blockquote>
<p>The best practice in <em>ES5</em> is to create a form of modularity that avoids polluting the global scope. Add one application namespace object such as <code>app</code> to the global <code>document</code>. Then each code file "exports" public entities by attaching them to that namespace object, e.g., <code>app.HeroComponent</code>. You could factor a large application into several sub-namespaces which leads to "exports" along the lines of <code>app.heroQueries.HeroComponent</code>.</p> <p>Every <em>ES5</em> file should wrap code in an <a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression" target="_blank">Immediately Invoked Function Expression (IIFE)</a> to limit unintentional leaking of private symbols into the global scope.</p> <p>Here is a <code>HeroComponent</code> as it might be defined and "exported" in each of the four language variants.</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">export class HeroComponent {
  title = 'Hero Detail';
  getName() {return 'Windstorm'; }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">export class HeroComponent {
  title = 'Hero Detail';
  getName() {return 'Windstorm'; }
}
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">export class HeroComponent {
  constructor() {
    this.title = 'Hero Detail';
  }
  getName() {return 'Windstorm'; }
}
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">app.HeroComponent = HeroComponent; // "export"

HeroComponent.annotations = [
  new ng.core.Component({
    selector: 'hero-view',
    template: '&lt;h1&gt;{{title}}: {{getName()}}&lt;/h1&gt;'
  })
];

function HeroComponent() {
  this.title = "Hero Detail";
}

HeroComponent.prototype.getName = function() { return 'Windstorm'; };
</pre>
<h3 id="importing-application-code">Importing Application Code</h3> <p>In <em>TypeScript</em> and <em>ES6</em> apps, you <code>import</code> things that have been exported from other modules.</p> <p>In <em>ES5</em> you use the shared namespace object to access "exported" entities from other files.</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">import { HeroComponent } from './hero.component';
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">import { HeroComponent } from './hero.component';
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">import { HeroComponent } from './hero.component';
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">var HeroComponent = app.HeroComponent;
</pre>
<blockquote class="alert is-helpful">
<p>Alternatively, you can use a module loader such as Webpack or Browserify in an Angular JavaScript project. In such a project, you would use <em>CommonJS</em> modules and the <code>require</code> function to load Angular framework code. Then use <code>module.exports</code> and <code>require</code> to export and import application code.</p> </blockquote>
<h2 id="class-metadata">Classes and Class Metadata</h2> <h3 id="classes">Classes</h3> <p>Most Angular <em>TypeScript</em> and <em>ES6</em> code is written as classes.</p> <p>Properties and method parameters of <em>TypeScript</em> classes may be marked with the access modifiers <code>private</code>, <code>internal</code>, and <code>public</code>. Remove these modifiers when translating to JavaScript.</p> <p>Most type declarations (e.g, <code>:string</code> and <code>:boolean</code>) should be removed when translating to JavaScript. When translating to <em>ES6-with-decorators</em>, <strong><em>do not remove types from constructor parameters!</em></strong></p> <p>Look for types in <em>TypeScript</em> property declarations. In general it is better to initialize such properties with default values because many browser JavaScript engines can generate more performant code. When <em>TypeScript</em> code follows this same advice, it can infer the property types and there is nothing to remove during translation. </p> <p>In <em>ES6-without-decorators</em>, properties of classes must be assigned inside the constructor.</p> <p><em>ES5</em> JavaScript has no classes. Use the constructor function pattern instead, adding methods to the prototype.</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">export class HeroComponent {
  title = 'Hero Detail';
  getName() {return 'Windstorm'; }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">export class HeroComponent {
  title = 'Hero Detail';
  getName() {return 'Windstorm'; }
}
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">export class HeroComponent {
  constructor() {
    this.title = 'Hero Detail';
  }
  getName() {return 'Windstorm'; }
}
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">function HeroComponent() {
  this.title = "Hero Detail";
}

HeroComponent.prototype.getName = function() { return 'Windstorm'; };
</pre>
<h3 id="metadata">Metadata</h3> <p>When writing in <em>TypeScript</em> or <em>ES6-with-decorators</em>, provide configuration and metadata by adorning a class with one or more <em>decorators</em>. For example, you supply metadata to a component class by preceding its definition with a <a href="../../api/core/index/component-decorator/"><code>@Component</code></a> decorator function whose argument is an object literal with metadata properties.</p> <p>In <em>plain ES6</em>, you provide metadata by attaching an <code>annotations</code> array to the <em>class</em>. Each item in the array is a new instance of a metadata decorator created with a similar metadata object literal.</p> <p>In <em>ES5</em>, you also provide an <code>annotations</code> array but you attach it to the <em>constructor function</em> rather than to a class.</p> <p>See these variations side-by-side:</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">import { Component } from '@angular/core';

@Component({
  selector: 'hero-view',
  template: '&lt;h1&gt;{{title}}: {{getName()}}&lt;/h1&gt;'
})
export class HeroComponent {
  title = 'Hero Detail';
  getName() {return 'Windstorm'; }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">import { Component } from '@angular/core';

@Component({
  selector: 'hero-view',
  template: '&lt;h1&gt;{{title}}: {{getName()}}&lt;/h1&gt;'
})
export class HeroComponent {
  title = 'Hero Detail';
  getName() {return 'Windstorm'; }
}
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">import { Component } from '@angular/core';

export class HeroComponent {
  constructor() {
    this.title = 'Hero Detail';
  }
  getName() {return 'Windstorm'; }
}

HeroComponent.annotations = [
  new Component({
    selector: 'hero-view',
    template: '&lt;h1&gt;{{title}}: {{getName()}}&lt;/h1&gt;'
  })
];
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">app.HeroComponent = HeroComponent; // "export"

HeroComponent.annotations = [
  new ng.core.Component({
    selector: 'hero-view',
    template: '&lt;h1&gt;{{title}}: {{getName()}}&lt;/h1&gt;'
  })
];

function HeroComponent() {
  this.title = "Hero Detail";
}

HeroComponent.prototype.getName = function() { return 'Windstorm'; };
</pre>
<p><strong><em>External Template file</em></strong></p> <p>A large component template is often kept in a separate template file.</p> <div class="code-example">
<h4 class="pre-title">src/app/hero-title.component.html</h4>
<pre data-language="html">&lt;h1&gt;{{titlePrefix}} {{title}}&lt;/h1&gt;
&lt;button (click)="ok()"&gt;OK&lt;/button&gt;
&lt;p&gt;{{ msg }}&lt;/p&gt;
</pre>
</div>
<p>The component (<code>HeroTitleComponent</code> in this case) then references the template file in its metadata <code>templateUrl</code> property:</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">@Component({
  selector: 'hero-title',
  templateUrl: './hero-title.component.html'
})
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">@Component({
  selector: 'hero-title',
  templateUrl: './hero-title.component.html'
})
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">HeroTitleComponent.annotations = [
  new Component({
    selector: 'hero-title',
    templateUrl: './hero-title.component.html'
  })
];
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">HeroTitleComponent.annotations = [
  new ng.core.Component({
    selector: 'hero-title',
    templateUrl: 'app/hero-title.component.html'
  })
];
</pre>
<p>Note that both the <em>TypeScript</em> and <em>ES6</em> <code>templateUrl</code> properties identify the location of the template file <em>relative to the component module</em>.</p> <h2 id="dsl">
<em>ES5</em> DSL</h2> <p>This <em>ES5</em> pattern of creating a constructor and annotating it with metadata is so common that Angular provides a convenience API to make it a little more compact and locates the metadata above the constructor, as you would if you wrote in <em>TypeScript</em> or <em>ES6-with-decorators</em>.</p> <p>This <em>API</em> (<em>Application Programming Interface</em>) is commonly known as the <em>ES5 DSL</em> (<em>Domain Specific Language</em>).</p> <p>Set an application namespace property (e.g., <code>app.HeroDslComponent</code>) to the result of an <code>ng.core.Component</code> function call. Pass the same metadata object to <code>ng.core.Component</code> as you did before. Then chain a call to the <code>Class</code> method which takes an object defining the class constructor and instance methods.</p> <p>Here is an example of the <code>HeroComponent</code>, re-written with the DSL, next to the original <em>ES5</em> version for comparison:</p> <div class="pre-title">ES5 JavaScript with DSL</div>
<pre name="ES5 JavaScript with DSL" data-language="js">app.HeroComponent = ng.core.Component({
  selector: 'hero-view-dsl',
  template: '&lt;h1&gt;{{title}}: {{getName()}}&lt;/h1&gt;',
})
.Class({
  constructor: function HeroComponent() {
    this.title = "Hero Detail";
  },

  getName: function() { return 'Windstorm'; }
});
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">app.HeroComponent = HeroComponent; // "export"

HeroComponent.annotations = [
  new ng.core.Component({
    selector: 'hero-view',
    template: '&lt;h1&gt;{{title}}: {{getName()}}&lt;/h1&gt;'
  })
];

function HeroComponent() {
  this.title = "Hero Detail";
}

HeroComponent.prototype.getName = function() { return 'Windstorm'; };
</pre>
<div class="callout is-helpful">
<header>Name the constructor</header><p>A <strong>named</strong> constructor displays clearly in the console log if the component throws a runtime error. An <strong>unnamed</strong> constructor displays as an anonymous function (e.g., <code>class0</code>) which is impossible to find in the source code.</p> </div>
<h3 id="properties-with-getters-and-setters">Properties with getters and setters</h3> <p><em>TypeScript</em> and <em>ES6</em> support with getters and setters. Here's an example of a read-only <em>TypeScript</em> property with a getter that prepares a toggle-button label for the next clicked state:</p> <div class="code-example">
<h4 class="pre-title">ts/src/app/hero-queries.component.ts</h4>
<pre data-language="typescript">get buttonLabel() {
  return this.active ? 'Deactivate' : 'Activate';
}
</pre>
</div>
<p>This <em>TypeScript</em> "getter" property is transpiled to an <em>ES5</em> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" title="Defined Properties">defined property</a>. The <em>ES5 DSL</em> does not support <em>defined properties</em> directly but you can still create them by extracting the "class" prototype and adding the <em>defined property</em> in raw JavaScript like this:</p> <div class="code-example">
<h4 class="pre-title">js/src/app/hero-queries.component.ts</h4>
<pre data-language="js">// add prototype property w/ getter outside the DSL
var proto = app.heroQueries.HeroQueriesComponent.prototype;
Object.defineProperty(proto, "buttonLabel", {
    get: function () {
        return this.active ? 'Deactivate' : 'Activate';
    },
    enumerable: true
});
</pre>
</div>
<h3 id="dsl-for-other-classes">DSL for other classes</h3> <p>There are similar DSLs for other decorated classes. You can define a directive with <code>ng.core.Directive</code>: </p> <pre>app.MyDirective = ng.core.Directive({
  selector: '[myDirective]'
}).Class({
  ...
});</pre>
<p>and a pipe with <code>ng.core.Pipe</code>:</p> <pre>app.MyPipe = ng.core.Pipe({
  name: 'myPipe'
}).Class({
  ...
});
</pre>
<h2 id="interfaces">Interfaces</h2> <p>A <em>TypeScript</em> interface helps ensure that a class implements the interface's members correctly. We strongly recommend Angular interfaces where appropriate. For example, the component class that implements the <code>ngOnInit</code> lifecycle hook method should implement the <code>OnInit</code> interface.</p> <p><em>TypeScript</em> interfaces exist for developer convenience and are not used by Angular at runtime. They have no physical manifestation in the generated JavaScript code. Just implement the methods and ignore interfaces when translating code samples from <em>TypeScript</em> to JavaScript.</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'hero-lifecycle',
  template: `&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;`
})
export class HeroComponent implements OnInit {
  name: string;
  ngOnInit() {
    // todo: fetch from server async
    setTimeout(() =&gt; this.name = 'Windstorm', 0);
  }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">import { Component } from '@angular/core';

@Component({
  selector: 'hero-lifecycle',
  template: `&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;`
})
export class HeroComponent {
  name = '';
  ngOnInit() {
    // todo: fetch from server async
    setTimeout(() =&gt; this.name = 'Windstorm', 0);
  }
}
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">import { Component } from '@angular/core';
export class HeroComponent {
  ngOnInit() {
    // todo: fetch from server async
    setTimeout(() =&gt; this.name = 'Windstorm', 0);
  }
}

HeroComponent.annotations = [
  new Component({
    selector: 'hero-lifecycle',
    template: `&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;`
  })
];
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">app.HeroComponent = HeroComponent;

HeroComponent.annotations = [
  new ng.core.Component({
    selector: 'hero-lifecycle',
    template: '&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;'
  })
];

function HeroComponent() { }

HeroComponent.prototype.ngOnInit = function() {
  // todo: fetch from server async
  setTimeout(() =&gt; this.name = 'Windstorm', 0);
};
</pre>
<div class="pre-title">ES5 JavaScript with DSL</div>
<pre name="ES5 JavaScript with DSL" data-language="js">app.HeroComponent = ng.core.Component({
  selector: 'hero-lifecycle-dsl',
  template: '&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;'
})
.Class({
  constructor: function HeroComponent() { },
  ngOnInit: function() {
    // todo: fetch from server async
    setTimeout(() =&gt; this.name = 'Windstorm', 0);
  }
});
</pre>
<h2 id="io-decorators">Input and Output Metadata</h2> <h3 id="input-and-output-decorators">Input and Output Decorators</h3> <p>In <em>TypeScript</em> and <em>ES6-with-decorators</em>, you often add metadata to class <em>properties</em> with <em>property decorators</em>. For example, you apply <a href="../../guide/template-syntax/#inputs-outputs"><code>@Input</code> and <code>@Output</code> property decorators</a> to public class properties that will be the target of data binding expressions in parent components.</p> <p>There is no equivalent of a property decorator in <em>ES5</em> or <em>plain ES6</em>. Fortunately, every property decorator has an equivalent representation in a class decorator metadata property. A <em>TypeScript</em> <code>@Input</code> property decorator can be represented by an item in the <code>Component</code> metadata's <code>inputs</code> array.</p> <p>You already know how to add <code>Component</code> or <code>Directive</code> class metadata in <em>any</em> JavaScript dialect so there's nothing fundamentally new about adding another property. But note that what would have been <em>separate</em> <code>@Input</code> and <code>@Output</code> property decorators for each class property are combined in the metadata <code>inputs</code> and <code>outputs</code> <em>arrays</em>.</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">@Component({
  selector: 'app-confirm',
  templateUrl: './confirm.component.html'
})
export class ConfirmComponent {
  @Input() okMsg = '';
  @Input('cancelMsg') notOkMsg = '';
  @Output() ok = new EventEmitter();
  @Output('cancel') notOk = new EventEmitter();

  onOkClick() {
    this.ok.emit(true);
  }
  onNotOkClick() {
    this.notOk.emit(true);
  }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">@Component({
  selector: 'app-confirm',
  templateUrl: './confirm.component.html'
})
export class ConfirmComponent {
  @Input() okMsg = '';
  @Input('cancelMsg') notOkMsg = '';
  @Output() ok = new EventEmitter();
  @Output('cancel') notOk = new EventEmitter();

  onOkClick() {
    this.ok.emit(true);
  }
  onNotOkClick() {
    this.notOk.emit(true);
  }
}
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">export class ConfirmComponent {
  constructor(){
    this.ok    = new EventEmitter();
    this.notOk = new EventEmitter();
  }
  onOkClick() {
    this.ok.emit(true);
  }
  onNotOkClick() {
    this.notOk.emit(true);
  }
}

ConfirmComponent.annotations = [
  new Component({
    selector: 'app-confirm',
    templateUrl: './confirm.component.html',
    inputs: [
      'okMsg',
      'notOkMsg: cancelMsg'
    ],
    outputs: [
      'ok',
      'notOk: cancel'
    ]
  })
];
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">app.ConfirmComponent = ConfirmComponent;

ConfirmComponent.annotations = [
  new ng.core.Component({
    selector: 'app-confirm',
    templateUrl: 'app/confirm.component.html',
    inputs: [
      'okMsg',
      'notOkMsg: cancelMsg'
    ],
    outputs: [
      'ok',
      'notOk: cancel'
    ]
  })
];

function ConfirmComponent() {
  this.ok    = new ng.core.EventEmitter();
  this.notOk = new ng.core.EventEmitter();
}

ConfirmComponent.prototype.onOkClick = function() {
  this.ok.emit(true);
}

ConfirmComponent.prototype.onNotOkClick = function() {
  this.notOk.emit(true);
}
</pre>
<div class="pre-title">ES5 JavaScript with DSL</div>
<pre name="ES5 JavaScript with DSL" data-language="js">app.ConfirmComponent = ng.core.Component({
  selector: 'app-confirm-dsl',
  templateUrl: 'app/confirm.component.html',
  inputs: [
    'okMsg',
    'notOkMsg: cancelMsg'
  ],
  outputs: [
    'ok',
    'notOk: cancel'
  ]
})
.Class({
  constructor: function ConfirmComponent() {
    this.ok    = new ng.core.EventEmitter();
    this.notOk = new ng.core.EventEmitter();
  },

  onOkClick: function() {
    this.ok.emit(true);
  },

  onNotOkClick: function() {
    this.notOk.emit(true);
  }
});
</pre>
<p>In the previous example, one of the public-facing binding names (<code>cancelMsg</code>) differs from the corresponding class property name (<code>notOkMsg</code>). That's OK but you must tell Angular about it so that it can map an external binding of <code>cancelMsg</code> to the component's <code>notOkMsg</code> property.</p> <p>In <em>TypeScript</em> and <em>ES6-with-decorators</em>, you specify the special binding name in the argument to the property decorator.</p> <p>In <em>ES5</em> and <em>plain ES6</em> code, convey this pairing with the <code>propertyName: bindingName</code> syntax in the class metadata.</p> <h2 id="dependency-injection">Dependency Injection</h2> <p>Angular relies heavily on <a href="../../guide/dependency-injection/">Dependency Injection</a> to provide services to the objects it creates. When Angular creates a new component, directive, pipe or another service, it sets the class constructor parameters to instances of services provided by an <em>Injector</em>.</p> <p>The developer must tell Angular what to inject into each parameter.</p> <h3 id="injection-by-class-type">Injection by Class Type</h3> <p>The easiest and most popular technique in <em>TypeScript</em> and <em>ES6-with-decorators</em> is to set the constructor parameter type to the class associated with the service to inject. </p> <p>The <em>TypeScript</em> transpiler writes parameter type information into the generated JavaScript. Angular reads that information at runtime and locates the corresponding service in the appropriate <em>Injector</em>.. The <em>ES6-with-decorators</em> transpiler does essentially the same thing using the same parameter-typing syntax.</p> <p><em>ES5</em> and <em>plain ES6</em> lack types so you must identify "injectables" by attaching a <strong><code>parameters</code></strong> array to the constructor function. Each item in the array specifies the service's injection token.</p> <p>As with <em>TypeScript</em> the most popular token is a class, or rather a <em>constructor function</em> that represents a class in <em>ES5</em> and <em>plain ES6</em>. The format of the <code>parameters</code> array varies:</p> <ul> <li>
<p><em>plain ES6</em> — nest each constructor function in a sub-array.</p> </li> <li>
<p><em>ES5</em> — simply list the constructor functions.</p> </li> </ul> <p>When writing with <em>ES5 DSL</em>, set the <code>Class.constructor</code> property to an array whose first parameters are the injectable constructor functions and whose last parameter is the class constructor itself. This format should be familiar to AngularJS developers.</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">import { Component }   from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'hero-di',
  template: `&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;`
})
export class HeroComponent {
  name = '';
  constructor(dataService: DataService) {
    this.name = dataService.getHeroName();
  }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">import { Component }   from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'hero-di',
  template: `&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;`
})
export class HeroComponent {
  name = '';
  constructor(dataService: DataService) {
    this.name = dataService.getHeroName();
  }
}
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">import { Component }   from '@angular/core';
import { DataService } from './data.service';

export class HeroComponent {
  constructor(dataService) {
    this.name = dataService.getHeroName();
  }
}

HeroComponent.annotations = [
  new Component({
    selector: 'hero-di',
    template: `&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;`
  })
];

HeroComponent.parameters = [
  [DataService]
];
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">app.HeroComponent = HeroComponent;

HeroComponent.annotations = [
  new ng.core.Component({
    selector: 'hero-di',
    template: '&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;'
  })
];

HeroComponent.parameters = [ app.DataService ];

function HeroComponent(dataService) {
  this.name = dataService.getHeroName();
}
</pre>
<div class="pre-title">ES5 JavaScript with DSL</div>
<pre name="ES5 JavaScript with DSL" data-language="js">app.HeroComponent = ng.core.Component({
  selector: 'hero-di-dsl',
  template: '&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;'
})
.Class({
  constructor: [
    app.DataService,
    function HeroComponent(service) {
      this.name = service.getHeroName();
    }
  ]
});
</pre>
<h3 id="injection-with-the-inject-decorator">Injection with the @Inject decorator</h3> <p>Sometimes the dependency injection token isn't a class or constructor function.</p> <p>In <em>TypeScript</em> and <em>ES6-with-decorators</em>, you precede the class constructor parameter by calling the <code>@Inject()</code> decorator with the injection token. In the following example, the token is the string <code>'heroName'</code>.</p> <p>The other JavaScript dialects add a <code>parameters</code> array to the class contructor function. Each item constains a new instance of <code>Inject</code>:</p> <ul> <li>
<p><em>plain ES6</em> — each item is a new instance of <code>Inject(token)</code> in a sub-array.</p> </li> <li>
<p><em>ES5</em> — simply list the string tokens.</p> </li> </ul> <p>When writing with <em>ES5 DSL</em>, set the <code>Class.constructor</code> property to a function definition array as before. Create a new instance of <code>ng.core.Inject(token)</code> for each parameter. </p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">@Component({
  selector: 'hero-di-inject',
  template: `&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;`
})
export class HeroComponent {
  constructor(@Inject('heroName') private name: string) { }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">@Component({
  selector: 'hero-di-inject',
  template: `&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;`
})
export class HeroComponent {
  constructor(@Inject('heroName') name) {
    this.name = name;
  }
}
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">export class HeroComponent {
  constructor(name) {
    this.name = name;
  }
}

HeroComponent.annotations = [
  new Component({
    selector: 'hero-di-inject',
    template: `&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;`
  })
];

HeroComponent.parameters = [
  [new Inject('heroName')]
];
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">app.HeroComponent = HeroComponent;

HeroComponent.annotations = [
  new ng.core.Component({
    selector: 'hero-di-inject',
    template: '&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;'
  })
];

HeroComponent.parameters = [ 'heroName' ];

function HeroComponent(name) {
  this.name = name;
}
</pre>
<div class="pre-title">ES5 JavaScript with DSL</div>
<pre name="ES5 JavaScript with DSL" data-language="js">app.HeroComponent = ng.core.Component({
  selector: 'hero-di-inject-dsl',
  template: '&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;'
})
.Class({
  constructor: [
    new ng.core.Inject('heroName'),
    function HeroComponent(name) {
      this.name = name;
    }
  ]
});
</pre>
<h3 id="additional-injection-decorators">Additional Injection Decorators</h3> <p>You can qualify injection behavior with injection decorators from <code>@angular/core</code>.</p> <p>In <em>TypeScript</em> and <em>ES6-with-decorators</em>, you precede the constructor parameters with injection qualifiers such as:</p> <ul> <li>
<a href="../../api/core/index/optional-decorator/"><code>@Optional</code></a> sets the parameter to <code>null</code> if the service is missing</li> <li>
<a href="../../api/core/index/attribute-interface/"><code>@Attribute</code></a> to inject a host element attribute value</li> <li>
<a href="../../api/core/index/contentchild-decorator/"><code>@ContentChild</code></a> to inject a content child</li> <li>
<a href="../../api/core/index/viewchild-decorator/"><code>@ViewChild</code></a> to inject a view child</li> <li>
<a href="../../api/core/index/host-decorator/"><code>@Host</code></a> to inject a service in this component or its host</li> <li>
<a href="../../api/core/index/skipself-decorator/"><code>@SkipSelf</code></a> to inject a service provided in an ancestor of this component</li> </ul> <p>In <em>plain ES6</em> and <em>ES5</em>, create an instance of the equivalent injection qualifier in a nested array within the <code>parameters</code> array. For example, you'd write <code>new Optional()</code> in <em>plain ES6</em> and <code>new ng.core.Optional()</code> in <em>ES5</em>.</p> <p>When writing with <em>ES5 DSL</em>, set the <code>Class.constructor</code> property to a function definition array as before. Use a nested array to define a parameter's complete injection specification.</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">@Component({
  selector: 'hero-title',
  templateUrl: './hero-title.component.html'
})
export class HeroTitleComponent {
  msg: string = '';
  constructor(
    @Inject('titlePrefix') @Optional() private titlePrefix: string,
    @Attribute('title') private title: string
  ) { }

  ok() {
    this.msg = 'OK!';
  }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">@Component({
  selector: 'hero-title',
  templateUrl: './hero-title.component.html'
})
export class HeroTitleComponent {
  msg = '';
  constructor(
    @Inject('titlePrefix') @Optional() titlePrefix,
    @Attribute('title') title
  ) {
    this.titlePrefix = titlePrefix;
    this.title = title;
  }

  ok() {
    this.msg = 'OK!';
  }
}
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">export class HeroTitleComponent {
  constructor(titlePrefix, title) {
    this.titlePrefix = titlePrefix;
    this.title  = title;
    this.msg = '';
  }

  ok() {
    this.msg = 'OK!';
  }
}

HeroTitleComponent.annotations = [
  new Component({
    selector: 'hero-title',
    templateUrl: './hero-title.component.html'
  })
];

HeroTitleComponent.parameters = [
  [new Optional(), new Inject('titlePrefix')],
  [new Attribute('title')]
];
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">  app.HeroTitleComponent = HeroTitleComponent;

  HeroTitleComponent.annotations = [
    new ng.core.Component({
      selector: 'hero-title',
      templateUrl: 'app/hero-title.component.html'
    })
  ];

  function HeroTitleComponent(titlePrefix, title) {
      this.titlePrefix = titlePrefix;
      this.title  = title;
      this.msg = '';
  }

  HeroTitleComponent.prototype.ok = function() {
    this.msg = 'OK!';
  }

  HeroTitleComponent.parameters = [
    [new ng.core.Optional(), new ng.core.Inject('titlePrefix')],
    [new ng.core.Attribute('title')]
  ];
</pre>
<div class="pre-title">ES5 JavaScript with DSL</div>
<pre name="ES5 JavaScript with DSL" data-language="js">app.HeroTitleComponent = ng.core.Component({
  selector: 'hero-title-dsl',
  templateUrl: 'app/hero-title.component.html'
})
.Class({
  constructor: [
    [ new ng.core.Optional(), new ng.core.Inject('titlePrefix') ],
    new ng.core.Attribute('title'),
    function HeroTitleComponent(titlePrefix, title) {
      this.titlePrefix = titlePrefix;
      this.title  = title;
      this.msg = '';
    }
  ],

  ok: function() {
    this.msg = 'OK!';
  }
});
</pre>
<blockquote class="l-sub-section">
<p>In the example above, there is no provider for the <code>'titlePrefix'</code> token. Without <code>Optional</code>, Angular would raise an error. With <code>Optional</code>, Angular sets the constructor parameter to <code>null</code> and the component displays the title without a prefix.</p> </blockquote>
<h2 id="host-binding">Host Binding</h2> <p>Angular supports bindings to properties and events of the <em>host element</em> which is the element whose tag matches the component selector.</p> <h3 id="host-decorators">Host Decorators</h3> <p>In <em>TypeScript</em> and <em>ES6-with-decorators</em>, you can use host property decorators to bind a host element to a component or directive. The <a href="../../api/core/index/hostbinding-interface/"><code>@HostBinding</code></a> decorator binds host element properties to component data properties. The <a href="../../api/core/index/hostlistener-interface/"><code>@HostListener</code></a> decorator binds host element events to component event handlers.</p> <p>In <em>plain ES6</em> or <em>ES5</em>, add a <code>host</code> attribute to the component metadata to achieve the same effect as <code>@HostBinding</code> and <code>@HostListener</code>. </p> <p>The <code>host</code> value is an object whose properties are host property and listener bindings:</p> <ul> <li>Each key follows regular Angular binding syntax: <code>[property]</code> for host bindings or <code>(event)</code> for host listeners.</li> <li>Each value identifies the corresponding component property or method.</li> </ul> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">@Component({
  selector: 'hero-host',
  template: `
    &lt;h1 [class.active]="active"&gt;Hero Host in Decorators&lt;/h1&gt;
    &lt;div&gt;Heading clicks: {{clicks}}&lt;/div&gt;
  `,
  // Styles within (but excluding) the &lt;hero-host&gt; element
  styles: ['.active {background-color: yellow;}']
})
export class HeroHostComponent {
  // HostBindings to the &lt;hero-host&gt; element
  @HostBinding() title = 'Hero Host in Decorators Tooltip';
  @HostBinding('class.heading') headingClass = true;

  active = false;
  clicks = 0;

  // HostListeners on the entire &lt;hero-host&gt; element
  @HostListener('click')
  clicked() {
    this.clicks += 1;
  }

  @HostListener('mouseenter', ['$event'])
  enter(event: Event) {
    this.active = true;
    this.headingClass = false;
  }

  @HostListener('mouseleave', ['$event'])
  leave(event: Event) {
    this.active = false;
    this.headingClass = true;
  }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">@Component({
  selector: 'hero-host',
  template: `
    &lt;h1 [class.active]="active"&gt;Hero Host in Decorators&lt;/h1&gt;
    &lt;div&gt;Heading clicks: {{clicks}}&lt;/div&gt;
  `,
  // Styles within (but excluding) the &lt;hero-host&gt; element
  styles: ['.active {background-color: yellow;}']
})
export class HeroHostComponent {
  // HostBindings to the &lt;hero-host&gt; element
  @HostBinding() title = 'Hero Host in Decorators Tooltip';
  @HostBinding('class.heading') headingClass = true;

  active = false;
  clicks = 0;

  // HostListeners on the entire &lt;hero-host&gt; element
  @HostListener('click')
  clicked() {
    this.clicks += 1;
  }

  @HostListener('mouseenter', ['$event'])
  enter(event: Event) {
    this.active = true;
    this.headingClass = false;
  }

  @HostListener('mouseleave', ['$event'])
  leave(event: Event) {
    this.active = false;
    this.headingClass = true;
  }
}
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">export class HeroHostComponent {
  constructor() {
    this.active = false;
    this.clicks = 0;
    this.headingClass = true;
    this.title = 'Hero Host Tooltip';
  }

  clicked() {
    this.clicks += 1;
  }

  enter(event) {
    this.active = true;
    this.headingClass = false;
  }

  leave(event) {
    this.active = false;
    this.headingClass = true;
  }
}

HeroHostComponent.annotations = [
  new Component({
    selector: 'hero-host',
    template: `
      &lt;h1 [class.active]="active"&gt;Hero Host&lt;/h1&gt;
      &lt;div&gt;Heading clicks: {{clicks}}&lt;/div&gt;
    `,
    host: {
      // HostBindings to the &lt;hero-host&gt; element
      '[title]': 'title',
      '[class.heading]': 'headingClass',
      '(click)': 'clicked()',

      // HostListeners on the entire &lt;hero-host&gt; element
      '(mouseenter)': 'enter($event)',
      '(mouseleave)': 'leave($event)'
    },
    // Styles within (but excluding) the &lt;hero-host&gt; element
    styles: ['.active {background-color: yellow;}']
  })
];
</pre>
<div class="pre-title">ES5 JavaScript</div>
<pre name="ES5 JavaScript" data-language="js">app.HeroComponent = HeroComponent;

HeroComponent.annotations = [
  new ng.core.Component({
    selector: 'hero-host',
    template:
      '&lt;h1 [class.active]="active"&gt;Hero Host&lt;/h1&gt;' +
      '&lt;div&gt;Heading clicks: {{clicks}}&lt;/div&gt;',
    host: {
      // HostBindings to the &lt;hero-host&gt; element
      '[title]': 'title',
      '[class.heading]': 'headingClass',
      '(click)': 'clicked()',

      // HostListeners on the entire &lt;hero-host&gt; element
      '(mouseenter)': 'enter($event)',
      '(mouseleave)': 'leave($event)'
    },
    // Styles within (but excluding) the &lt;hero-host&gt; element
    styles: ['.active {background-color: yellow;}']
  })
];

function HeroComponent() {
  this.clicks = 0;
  this.headingClass = true;
  this.title = 'Hero Host Tooltip content';
}

HeroComponent.prototype.clicked = function() {
  this.clicks += 1;
}

HeroComponent.prototype.enter = function(event) {
  this.active = true;
  this.headingClass = false;
}

HeroComponent.prototype.leave = function(event) {
  this.active = false;
  this.headingClass = true;
}
</pre>
<div class="pre-title">ES5 JavaScript with DSL</div>
<pre name="ES5 JavaScript with DSL" data-language="js">app.HeroComponent = ng.core.Component({
  selector: 'hero-host-dsl',
  template: `
    &lt;h1 [class.active]="active"&gt;Hero Host (DSL)&lt;/h1&gt;
    &lt;div&gt;Heading clicks: {{clicks}}&lt;/div&gt;
  `,
  host: {
    // HostBindings to the &lt;hero-host-dsl&gt; element
    '[title]': 'title',
    '[class.heading]': 'headingClass',
    '(click)': 'clicked()',

    // HostListeners on the entire &lt;hero-host-dsl&gt; element
    '(mouseenter)': 'enter($event)',
    '(mouseleave)': 'leave($event)'
  },
  // Styles within (but excluding) the &lt;hero-host-dsl&gt; element
  styles: ['.active {background-color: coral;}']
})
.Class({
  constructor: function HeroComponent() {
    this.clicks = 0;
    this.headingClass = true;
    this.title = 'Hero Host Tooltip DSL content';
  },

  clicked() {
    this.clicks += 1;
  },

  enter(event) {
    this.active = true;
    this.headingClass = false;
  },

  leave(event) {
    this.active = false;
    this.headingClass = true;
  }
});
</pre>
<h3 id="host-metadata">Host Metadata</h3> <p>Some developers prefer to specify host properties and listeners in the component metadata. They'd <em>rather</em> do it the way you <em>must</em> do it <em>ES5</em> and <em>plain ES6</em>.</p> <p>The following re-implementation of the <code>HeroComponent</code> reminds us that <em>any property metadata decorator</em> can be expressed as component or directive metadata in both <em>TypeScript</em> and <em>ES6-with-decorators</em>. These particular <em>TypeScript</em> and <em>ES6</em> code snippets happen to be identical.</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">@Component({
  selector: 'hero-host-meta',
  template: `
    &lt;h1 [class.active]="active"&gt;Hero Host in Metadata&lt;/h1&gt;
    &lt;div&gt;Heading clicks: {{clicks}}&lt;/div&gt;
  `,
  host: {
    // HostBindings to the &lt;hero-host-meta&gt; element
    '[title]': 'title',
    '[class.heading]': 'headingClass',

    // HostListeners on the entire &lt;hero-host-meta&gt; element
    '(click)': 'clicked()',
    '(mouseenter)': 'enter($event)',
    '(mouseleave)': 'leave($event)'
  },
  // Styles within (but excluding) the &lt;hero-host-meta&gt; element
  styles: ['.active {background-color: coral;}']
})
export class HeroHostMetaComponent {
  title = 'Hero Host in Metadata Tooltip';
  headingClass = true;

  active = false;
  clicks = 0;

  clicked() {
    this.clicks += 1;
  }

  enter(event: Event) {
    this.active = true;
    this.headingClass = false;
  }

  leave(event: Event) {
    this.active = false;
    this.headingClass = true;
  }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">@Component({
  selector: 'hero-host-meta',
  template: `
    &lt;h1 [class.active]="active"&gt;Hero Host in Metadata&lt;/h1&gt;
    &lt;div&gt;Heading clicks: {{clicks}}&lt;/div&gt;
  `,
  host: {
    // HostBindings to the &lt;hero-host-meta&gt; element
    '[title]': 'title',
    '[class.heading]': 'headingClass',

    // HostListeners on the entire &lt;hero-host-meta&gt; element
    '(click)': 'clicked()',
    '(mouseenter)': 'enter($event)',
    '(mouseleave)': 'leave($event)'
  },
  // Styles within (but excluding) the &lt;hero-host-meta&gt; element
  styles: ['.active {background-color: coral;}']
})
export class HeroHostMetaComponent {
  title = 'Hero Host in Metadata Tooltip';
  headingClass = true;

  active = false;
  clicks = 0;

  clicked() {
    this.clicks += 1;
  }

  enter(event: Event) {
    this.active = true;
    this.headingClass = false;
  }

  leave(event: Event) {
    this.active = false;
    this.headingClass = true;
  }
}
</pre>
<h3 id="view-child-decorators">View and Child Decorators</h3> <p>Several <em>property</em> decorators query a component's nested view and content components.</p> <blockquote class="l-sub-section">
<p><em>View</em> children are associated with element tags that appear <em>within</em> the component's template.</p> <p><em>Content</em> children are associated with elements that appear <em>between</em> the component's element tags; they are projected into an <code>&lt;ng-content&gt;</code> slot in the component's template. </p> </blockquote>
<p>The <a href="../../api/core/index/viewchild-decorator/"><code>@ViewChild</code></a> and <a href="../../api/core/index/viewchildren-decorator/"><code>@ViewChildren</code></a> property decorators allow a component to query instances of other components that are used in its view. </p> <p>In <em>ES5</em> and <em>ES6</em>, you access a component's view children by adding a <code>queries</code> property to the component metadata. The <code>queries</code> property value is a hash map.</p> <ul> <li>each <em>key</em> is the name of a component property that will hold the view child or children.</li> <li>each <em>value</em> is a new instance of either <code>ViewChild</code> or <code>ViewChildren</code>.</li> </ul> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">@Component({
  selector: 'hero-queries',
  template: `
    &lt;view-child *ngFor="let hero of heroData" [hero]="hero"&gt;
      &lt;content-child&gt;&lt;/content-child&gt;
    &lt;/view-child&gt;
    &lt;button (click)="activate()"&gt;{{buttonLabel}} All&lt;/button&gt;
  `
})
export class HeroQueriesComponent {
  active = false;
  heroData = [
    {id: 1, name: 'Windstorm'},
    {id: 2, name: 'LaughingGas'}
  ];

  @ViewChildren(ViewChildComponent) views: QueryList&lt;ViewChildComponent&gt;;

  activate() {
    this.active = !this.active;
    this.views.forEach(
      view =&gt; view.activate()
    );
  }

  get buttonLabel() {
    return this.active ? 'Deactivate' : 'Activate';
  }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">@Component({
  selector: 'hero-queries',
  template: `
    &lt;view-child *ngFor="let hero of heroData" [hero]="hero"&gt;
      &lt;content-child&gt;&lt;/content-child&gt;
    &lt;/view-child&gt;
    &lt;button (click)="activate()"&gt;{{buttonLabel}} All&lt;/button&gt;
  `
})
export class HeroQueriesComponent {
  active = false;
  heroData = [
    {id: 1, name: 'Windstorm'},
    {id: 2, name: 'LaughingGas'}
  ];

  @ViewChildren(ViewChildComponent) views;

  activate() {
    this.active = !this.active;
    this.views.forEach(
      view =&gt; view.activate()
    );
  }

  get buttonLabel() {
    return this.active ? 'Deactivate' : 'Activate';
  }
}
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">export class HeroQueriesComponent {
  constructor(){
    this.active = false;
    this.heroData = [
      {id: 1, name: 'Windstorm'},
      {id: 2, name: 'LaughingGas'}
    ];
  }

  activate() {
    this.active = !this.active;
    this.views.forEach(
      view =&gt; view.activate()
    );
  }

  get buttonLabel() {
    return this.active ? 'Deactivate' : 'Activate';
  }
}

HeroQueriesComponent.annotations = [
  new Component({
    selector: 'hero-queries',
    template: `
      &lt;view-child *ngFor="let hero of heroData" [hero]="hero"&gt;
        &lt;content-child&gt;&lt;/content-child&gt;
      &lt;/view-child&gt;
      &lt;button (click)="activate()"&gt;{{buttonLabel}} All&lt;/button&gt;
    `,
    queries: {
      views: new ViewChildren(ViewChildComponent)
    }
  })
];
</pre>
<div class="pre-title">ES5 JavaScript with DSL</div>
<pre name="ES5 JavaScript with DSL" data-language="js">  app.heroQueries.HeroQueriesComponent = ng.core.Component({
    selector: 'hero-queries',
    template:
      '&lt;view-child *ngFor="let hero of heroData" [hero]="hero"&gt;' +
        '&lt;content-child&gt;&lt;/content-child&gt;' +
      '&lt;/view-child&gt;' +
      '&lt;button (click)="activate()"&gt;{{buttonLabel}} All&lt;/button&gt;',
    queries: {
      views: new ng.core.ViewChildren(app.heroQueries.ViewChildComponent)
    }
  })
  .Class({
    constructor: function HeroQueriesComponent() {
      this.active = false;
      this.heroData = [
        {id: 1, name: 'Windstorm'},
        {id: 2, name: 'LaughingGas'}
      ];
    },

    activate: function() {
      this.active = !this.active;
      this.views.forEach(function(view) {
        view.activate();
      });
    },
  });

  // add prototype property w/ getter outside the DSL
  var proto = app.heroQueries.HeroQueriesComponent.prototype;
  Object.defineProperty(proto, "buttonLabel", {
      get: function () {
          return this.active ? 'Deactivate' : 'Activate';
      },
      enumerable: true
  });
</pre>
<p>The <a href="../../api/core/index/contentchild-decorator/"><code>@ContentChild</code></a> and <a href="../../api/core/index/contentchildren-decorator/"><code>@ContentChildren</code></a> property decorators allow a component to query instances of other components that have been projected into its view from elsewhere.</p> <p>They can be added in the same way as <a href="../../api/core/index/viewchild-decorator/"><code>@ViewChild</code></a> and <a href="../../api/core/index/viewchildren-decorator/"><code>@ViewChildren</code></a>.</p> <div class="pre-title">TypeScript</div>
<pre name="TypeScript" data-language="typescript">@Component({
  selector: 'view-child',
  template: `
  &lt;h2 [class.active]=active&gt;
    {{hero.name}}
    &lt;ng-content&gt;&lt;/ng-content&gt;
  &lt;/h2&gt;`,
  styles: ['.active {font-weight: bold; background-color: skyblue;}']
})
export class ViewChildComponent {
  @Input() hero: any;
  active = false;

  @ContentChild(ContentChildComponent) content: ContentChildComponent;

  activate() {
    this.active = !this.active;
    this.content.activate();
  }
}
</pre>
<div class="pre-title">ES6 JavaScript with decorators</div>
<pre name="ES6 JavaScript with decorators" data-language="es6">@Component({
  selector: 'view-child',
  template: `
  &lt;h2 [class.active]=active&gt;
    {{hero.name}}
    &lt;ng-content&gt;&lt;/ng-content&gt;
  &lt;/h2&gt;`,
  styles: ['.active {font-weight: bold; background-color: skyblue;}']
})
export class ViewChildComponent {
  @Input() hero;
  active = false;

  @ContentChild(ContentChildComponent) content;

  activate() {
    this.active = !this.active;
    this.content.activate();
  }
}
</pre>
<div class="pre-title">ES6 JavaScript</div>
<pre name="ES6 JavaScript" data-language="es6">export class ViewChildComponent {
  constructor() {
    this.active = false;
  }

  activate() {
    this.active = !this.active;
    this.content.activate();
  }
}

ViewChildComponent.annotations = [
  new Component({
    selector: 'view-child',
    template: `&lt;h2 [class.active]=active&gt;
      {{hero.name}}
      &lt;ng-content&gt;&lt;/ng-content&gt;
    &lt;/h2&gt;`,
    styles: ['.active {font-weight: bold; background-color: skyblue;}'],
    inputs: ['hero'],
    queries: {
      content: new ContentChild(ContentChildComponent)
    }
  })
];
</pre>
<div class="pre-title">ES5 JavaScript with DSL</div>
<pre name="ES5 JavaScript with DSL" data-language="js">app.heroQueries.ViewChildComponent = ng.core.Component({
  selector: 'view-child',
  template:
    '&lt;h2 [class.active]=active&gt;' +
      '{{hero.name}} ' +
      '&lt;ng-content&gt;&lt;/ng-content&gt;' +
    '&lt;/h2&gt;',
  styles: ['.active {font-weight: bold; background-color: skyblue;}'],
  inputs: ['hero'],
  queries: {
    content: new ng.core.ContentChild(app.heroQueries.ContentChildComponent)
  }
})
.Class({
  constructor: function HeroQueriesHeroComponent() {
    this.active = false;
  },

  activate: function() {
    this.active = !this.active;
    this.content.activate();
  }
});
</pre>
<blockquote class="alert is-helpful">
<p>In <em>TypeScript</em> and <em>ES6-with-decorators</em> you can also use the <code>queries</code> metadata instead of the <code>@ViewChild</code> and <code>@ContentChild</code> property decorators. </p> </blockquote>
<h2 id="aot">AOT Compilation in <em>TypeScript</em> only</h2> <p>Angular offers two modes of template compilation, JIT (<em>Just-in-Time</em>) and <a href="../aot-compiler/">AOT (<em>Ahead-of-Time</em>)</a>. Currently the AOT compiler only works with <em>TypeScript</em> applications because, in part, it generates <em>TypeScript</em> files as an intermediate result. <strong>AOT is not an option for pure JavaScript applications</strong> at this time.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://v2.angular.io/docs/ts/latest/cookbook/ts-to-js.html" class="_attribution-link" target="_blank">https://v2.angular.io/docs/ts/latest/cookbook/ts-to-js.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
