
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>NgModules - Angular 4 - W3cubDocs</title>
  
  <meta name="description" content=" NgModules help organize an application into cohesive blocks of functionality. ">
  <meta name="keywords" content="ngmodules, -, angular, angular~4">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/angular~4/guide/ngmodule/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6ca5be81b81eb73e654078d9aaa623884afe18900617ed9a60729a4905026f77.css">
  <script type="text/javascript" src="/assets/application-2fa35d54abf92f248ac868261a14d3f99b325c34fcc70df314719245e248d73c.js"></script>
  <script src="/json/angular~4.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angular~4/" class="_nav-link" title="" style="margin-left:0;">Angular 4</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _angular">
				
				
<h1 id="ngmodules">NgModules</h1> <p><strong>NgModules</strong> help organize an application into cohesive blocks of functionality.</p>  <p>An NgModule is a class adorned with the <em>@NgModule</em> decorator function. <code>@<a href="../../api/core/ngmodule/" class="code-anchor">NgModule</a></code> takes a metadata object that tells Angular how to compile and run module code. It identifies the module's own components, directives, and pipes, making some of them public so external components can use them. <code>@<a href="../../api/core/ngmodule/" class="code-anchor">NgModule</a></code> may add service providers to the application dependency injectors. And there are many more options covered here.</p> <p>Before reading this page, read the <a href="../bootstrapping/">The Root Module</a> page, which introduces NgModules and the essentials of creating and maintaining a single root <code>AppModule</code> for the entire application.</p> <p>This page covers NgModules in greater depth.</p>  <h4 id="live-examples">Live examples</h4> <p>This page explains NgModules through a progression of improvements to a sample with a "Tour of Heroes" theme. Here's an index to live examples at key moments in the evolution of the sample:</p> <ul> <li><span plnkr="minimal.0">A minimal NgModule app</span></li> <li><span plnkr="contact.1b">The first contact module</span></li> <li><span plnkr="contact.2">The revised contact module</span></li> <li><span plnkr="pre-shared.3">Just before adding SharedModule</span></li> <li><span>The final version</span></li> </ul> <h4 id="frequently-asked-questions-faqs">Frequently asked questions (FAQs)</h4> <p>This page covers NgModule concepts in a tutorial fashion.</p> <p>The companion <a href="../ngmodule-faq/" title="NgModule FAQs">NgModule FAQs</a> guide offers answers to specific design and implementation questions. Read this page before reading those FAQs.</p>   <h2 id="angular-modularity">Angular modularity</h2> <p>Modules are a great way to organize an application and extend it with capabilities from external libraries.</p> <p>Many Angular libraries are modules (such as <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code>, <code><a href="../../api/http/httpmodule/" class="code-anchor">HttpModule</a></code>, and <code><a href="../../api/router/routermodule/" class="code-anchor">RouterModule</a></code>). Many third-party libraries are available as NgModules (such as <a href="https://material.angular.io/" target="_blank">Material Design</a>, <a href="http://ionicframework.com/" target="_blank">Ionic</a>, <a href="https://github.com/angular/angularfire2" target="_blank">AngularFire2</a>).</p> <p>NgModules consolidate components, directives, and pipes into cohesive blocks of functionality, each focused on a feature area, application business domain, workflow, or common collection of utilities.</p> <p>Modules can also add services to the application. Such services might be internally developed, such as the application logger. Services can come from outside sources, such as the Angular router and Http client.</p> <p>Modules can be loaded eagerly when the application starts. They can also be <em>lazy loaded</em> asynchronously by the router.</p> <p>An NgModule is a class decorated with <code>@<a href="../../api/core/ngmodule/" class="code-anchor">NgModule</a></code> metadata. The metadata do the following:</p> <ul> <li>Declare which components, directives, and pipes belong to the module.</li> <li>Make some of those classes public so that other component templates can use them.</li> <li>Import other modules with the components, directives, and pipes needed by the components in <em>this</em> module.</li> <li>Provide services at the application level that any application component can use.</li> </ul> <p>Every Angular app has at least one module class, the <em>root module</em>. You bootstrap that module to launch the application.</p> <p>The root module is all you need in a simple application with a few components. As the app grows, you refactor the root module into <em>feature modules</em> that represent collections of related functionality. You then import these modules into the root module.</p> <p>Later in this page, you'll read about this process. For now, you'll start with the root module.</p>  <h2 id="the-root-appmodule">The root <code>AppModule</code>
</h2> <p>Every Angular app has a <em>root module</em> class. By convention, the <em>root module</em> class is called <code>AppModule</code> and it exists in a file named <code>app.module.ts</code>.</p> <p>The <code>AppModule</code> from the QuickStart seed on the <a href="../setup/">Setup</a> page is as minimal as possible:</p> <div class="pre-title">src/app/app.module.ts (minimal)</div>
<pre data-language="typescript">import { NgModule }      from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent }  from './app.component';

@NgModule({
  imports:      [ BrowserModule ],
  declarations: [ AppComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }</pre> <p>The <code>@<a href="../../api/core/ngmodule/" class="code-anchor">NgModule</a></code> decorator defines the metadata for the module. This page takes an intuitive approach to understanding the metadata and fills in details as it progresses.</p> <p>The metadata imports a single helper module, <code><a href="../../api/platform-browser/browsermodule/" class="code-anchor">BrowserModule</a></code>, which every browser app must import.</p> <p><code><a href="../../api/platform-browser/browsermodule/" class="code-anchor">BrowserModule</a></code> registers critical application service providers. It also includes common directives like <code><a href="../../api/common/ngif/" class="code-anchor">NgIf</a></code> and <code><a href="../../api/common/ngfor/" class="code-anchor">NgFor</a></code>, which become immediately visible and usable in any of this module's component templates.</p> <p>The <code>declarations</code> list identifies the application's only component, the <em>root component</em>, the top of the app's rather bare component tree.</p> <p>The example <code>AppComponent</code> simply displays a data-bound title:</p> <div class="pre-title">src/app/app.component.ts (minimal)</div>
<pre data-language="typescript">import { Component } from '@angular/core';

@Component({
  selector: 'my-app',
  template: '&lt;h1&gt;{{title}}&lt;/h1&gt;',
})
export class AppComponent {
  title = 'Minimal NgModule';
}</pre> <p>Lastly, the <code>@<a href="../../api/core/ngmodule/" class="code-anchor">NgModule</a>.bootstrap</code> property identifies this <code>AppComponent</code> as the <em>bootstrap component</em>. When Angular launches the app, it places the HTML rendering of <code>AppComponent</code> in the DOM, inside the <code>&lt;my-app&gt;</code> element tags of the <code>index.html</code>.</p>  <h2 id="bootstrapping-in-maints">Bootstrapping in <code>main.ts</code>
</h2> <p>You launch the application by bootstrapping the <code>AppModule</code> in the <code>main.ts</code> file.</p> <p>Angular offers a variety of bootstrapping options targeting multiple platforms. This page describes two options, both targeting the browser.</p> <h3 id="compile-just-in-time-jit">Compile just-in-time (JIT)</h3> <p>In the first, <em>dynamic</em> option, the <a href="../ngmodule-faq/#q-angular-compiler" title="About the Angular Compiler">Angular compiler</a> compiles the application in the browser and then launches the app.</p> <div class="pre-title">src/main.ts (dynamic)</div>
<pre data-language="typescript">// The browser platform with a compiler
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

// The app module
import { AppModule } from './app/app.module';

// Compile and launch the module
platformBrowserDynamic().bootstrapModule(AppModule);</pre> <p>The samples in this page demonstrate the dynamic bootstrapping approach.</p> <p><span embedded="" plnkr="minimal.0" img="guide/ngmodule/minimal-plunker.png">Try the live example.</span></p> <h3 id="compile-ahead-of-time-aot">Compile ahead-of-time (AOT)</h3> <p>Consider the static alternative which can produce a much smaller application that launches faster, especially on mobile devices and high latency networks.</p> <p>In the <em>static</em> option, the Angular compiler runs ahead of time as part of the build process, producing a collection of class factories in their own files. Among them is the <code>AppModuleNgFactory</code>.</p> <p>The syntax for bootstrapping the pre-compiled <code>AppModuleNgFactory</code> is similar to the dynamic version that bootstraps the <code>AppModule</code> class.</p> <div class="pre-title">src/main.ts (static)</div>
<pre data-language="typescript">// The browser platform without a compiler
import { platformBrowser } from '@angular/platform-browser';

// The app module factory produced by the static offline compiler
import { AppModuleNgFactory } from './app/app.module.ngfactory';

// Launch with the app module factory.
platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);</pre> <p>Because the entire application was pre-compiled, Angular doesn't ship the Angular compiler to the browser and doesn't compile in the browser.</p> <p>The application code downloaded to the browser is much smaller than the dynamic equivalent and it's ready to execute immediately. The performance boost can be significant.</p> <p>Both the JIT and AOT compilers generate an <code>AppModuleNgFactory</code> class from the same <code>AppModule</code> source code. The JIT compiler creates that factory class on the fly, in memory, in the browser. The AOT compiler outputs the factory to a physical file that is imported here in the static version of <code>main.ts</code>.</p> <p>In general, the <code>AppModule</code> should neither know nor care how it is bootstrapped.</p> <p>Although the <code>AppModule</code> evolves as the app grows, the bootstrap code in <code>main.ts</code> doesn't change. This is the last time you'll look at <code>main.ts</code>.</p>   <h2 id="declare-directives-and-components">Declare directives and components</h2> <p>As the app evolves, the first addition is a <code>HighlightDirective</code>, an <a href="../attribute-directives/">attribute directive</a> that sets the background color of the attached element.</p> <div class="pre-title">src/app/highlight.directive.ts</div>
<pre data-language="typescript">import { Directive, ElementRef } from '@angular/core';

@Directive({ selector: '[highlight]' })
/** Highlight the attached element in gold */
export class HighlightDirective {
  constructor(el: ElementRef) {
    el.nativeElement.style.backgroundColor = 'gold';
    console.log(
      `* AppRoot highlight called for ${el.nativeElement.tagName}`);
  }
}</pre> <p>Update the <code>AppComponent</code> template to attach the directive to the title:</p> <div class="pre-title">src/app/app.component.ts</div>
<pre data-language="typescript">template: '&lt;h1 highlight&gt;{{title}}&lt;/h1&gt;'</pre> <p>If you ran the app now, Angular wouldn't recognize the <code>highlight</code> attribute and would ignore it. You must declare the directive in <code>AppModule</code>.</p> <p>Import the <code>HighlightDirective</code> class and add it to the module's <code>declarations</code> like this:</p> <div class="pre-title">src/app/app.module.ts</div>
<pre data-language="typescript">declarations: [
  AppComponent,
  HighlightDirective,
],</pre> <p>Refactor the title into its own <code>TitleComponent</code>. The component's template binds to the component's <code>title</code> and <code>subtitle</code> properties like this:</p> <div class="pre-title">src/app/title.component.html</div>
<pre data-language="html">&lt;h1 highlight&gt;{{title}} {{subtitle}}&lt;/h1&gt;</pre> <div class="pre-title">src/app/title.component.ts</div>
<pre data-language="typescript">import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-title',
  templateUrl: './title.component.html',
})
export class TitleComponent {
  @Input() subtitle = '';
  title = 'NgModules';
}</pre> <p>Rewrite the <code>AppComponent</code> to display the new <code>TitleComponent</code> in the <code>&lt;app-title&gt;</code> element, using an input binding to set the <code>subtitle</code>.</p> <div class="pre-title">src/app/app.component.ts (v1)</div>
<pre data-language="typescript">import { Component } from '@angular/core';

@Component({
  selector: 'my-app',
  template: '&lt;app-title [subtitle]="subtitle"&gt;&lt;/app-title&gt;'
})
export class AppComponent {
  subtitle = '(v1)';
}</pre> <p>Angular won't recognize the <code>&lt;app-title&gt;</code> tag until you declare it in <code>AppModule</code>. Import the <code>TitleComponent</code> class and add it to the module's <code>declarations</code>:</p> <div class="pre-title">src/app/app.module.ts</div>
<pre data-language="typescript">declarations: [
  AppComponent,
  HighlightDirective,
  TitleComponent,
],</pre>  <h2 id="service-providers">Service providers</h2> <p>Modules are a great way to provide services for all of the module's components.</p> <p>The <a href="../dependency-injection/">Dependency Injection</a> page describes the Angular hierarchical dependency-injection system and how to configure that system with <a href="../dependency-injection/#providers">providers</a> at different levels of the application's component tree.</p> <p>A module can add providers to the application's root dependency injector, making those services available everywhere in the application.</p> <p>Many applications capture information about the currently logged-in user and make that information accessible through a user service. This sample application has a dummy implementation of such a <code>UserService</code>.</p> <div class="pre-title">src/app/user.service.ts</div>
<pre data-language="typescript">import { Injectable } from '@angular/core';

@Injectable()
/** Dummy version of an authenticated user service */
export class UserService {
  userName = 'Sherlock Holmes';
}</pre> <p>The sample application should display a welcome message to the logged-in user just below the application title. Update the <code>TitleComponent</code> template to show the welcome message below the application title.</p> <div class="pre-title">src/app/title.component.html</div>
<pre data-language="html">&lt;h1 highlight&gt;{{title}} {{subtitle}}&lt;/h1&gt;
&lt;p *ngIf="user"&gt;
  &lt;i&gt;Welcome, {{user}}&lt;/i&gt;
&lt;p&gt;</pre> <p>Update the <code>TitleComponent</code> class with a constructor that injects the <code>UserService</code> and sets the component's <code>user</code> property from the service.</p> <div class="pre-title">src/app/title.component.ts</div>
<pre data-language="typescript">import { Component, Input } from '@angular/core';
import { UserService } from './user.service';

@Component({
  selector: 'app-title',
  templateUrl: './title.component.html',
})
export class TitleComponent {
  @Input() subtitle = '';
  title = 'NgModules';
  user = '';

  constructor(userService: UserService) {
    this.user = userService.userName;
  }
}</pre> <p>You've defined and used the service. Now to <em>provide</em> it for all components to use, add it to a <code>providers</code> property in the <code>AppModule</code> metadata:</p> <div class="pre-title">src/app/app.module.ts (providers)</div>
<pre data-language="typescript">providers: [ UserService ],</pre>  <h2 id="import-supporting-modules">Import supporting modules</h2> <p>In the revised <code>TitleComponent</code>, an <code>*<a href="../../api/common/ngif/" class="code-anchor">ngIf</a></code> directive guards the message. There is no message if there is no user.</p> <div class="pre-title">src/app/title.component.html (ngIf)</div>
<pre data-language="html">&lt;p *ngIf="user"&gt;
  &lt;i&gt;Welcome, {{user}}&lt;/i&gt;
&lt;p&gt;</pre> <p>Although <code>AppModule</code> doesn't declare <code><a href="../../api/common/ngif/" class="code-anchor">NgIf</a></code>, the application still compiles and runs. How can that be? The Angular compiler should either ignore or complain about unrecognized HTML.</p> <p>Angular does recognize <code><a href="../../api/common/ngif/" class="code-anchor">NgIf</a></code> because you imported it earlier. The initial version of <code>AppModule</code> imports <code><a href="../../api/platform-browser/browsermodule/" class="code-anchor">BrowserModule</a></code>.</p> <div class="pre-title">src/app/app.module.ts (imports)</div>
<pre data-language="typescript">imports: [ BrowserModule ],</pre> <p>Importing <code><a href="../../api/platform-browser/browsermodule/" class="code-anchor">BrowserModule</a></code> made all of its public components, directives, and pipes visible to the component templates in <code>AppModule</code>.</p> <blockquote class="l-sub-section"> <p>More accurately, <code><a href="../../api/common/ngif/" class="code-anchor">NgIf</a></code> is declared in <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code> from <code>@angular/common</code>.</p> <p><code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code> contributes many of the common directives that applications need, including <code><a href="../../api/common/ngif/" class="code-anchor">ngIf</a></code> and <code>ngFor</code>.</p> <p><code><a href="../../api/platform-browser/browsermodule/" class="code-anchor">BrowserModule</a></code> imports <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code> and <a href="../ngmodule-faq/#q-re-export">re-exports</a> it. The net effect is that an importer of <code><a href="../../api/platform-browser/browsermodule/" class="code-anchor">BrowserModule</a></code> gets <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code> directives automatically.</p> </blockquote> <p>Many familiar Angular directives don't belong to <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code>. For example, <code><a href="../../api/forms/ngmodel/" class="code-anchor">NgModel</a></code> and <code><a href="../../api/router/routerlink/" class="code-anchor">RouterLink</a></code> belong to Angular's <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code> and <code><a href="../../api/router/routermodule/" class="code-anchor">RouterModule</a></code> respectively. You must import those modules before you can use their directives.</p> <p>To illustrate this point, you'll extend the sample app with <code>ContactComponent</code>, a form component that imports form support from the Angular <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code>.</p> <h3 class="no-toc" id="add-the-_contactcomponent_">Add the _ContactComponent_</h3> <p><a href="../forms/">Angular forms</a> are a great way to manage user data entry.</p> <p>The <code>ContactComponent</code> presents a "contact editor," implemented with Angular forms in the <a href="../forms/#template-driven">template-driven form</a> style.</p> <blockquote class="l-sub-section"> <h4 class="no-toc" id="angular-form-styles">Angular form styles</h4> <p>You can write Angular form components in template-driven or <a href="../dynamic-form/">reactive</a> style.</p>  <p>The following sample imports the <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code> from <code>@angular/forms</code> because the <code>ContactComponent</code> is written in <em>template-driven</em> style. Modules with components written in the <em>reactive</em> style import the <code><a href="../../api/forms/reactiveformsmodule/" class="code-anchor">ReactiveFormsModule</a></code>.</p> </blockquote> <p>The <code>ContactComponent</code> selector matches an element named <code>&lt;app-contact&gt;</code>. Add an element with that name to the <code>AppComponent</code> template, just below the <code>&lt;app-title&gt;</code>:</p> <div class="pre-title">src/app/app.component.ts (template)</div>
<pre data-language="typescript">template: `
  &lt;app-title [subtitle]="subtitle"&gt;&lt;/app-title&gt;
  &lt;app-contact&gt;&lt;/app-contact&gt;
`</pre> <p>Form components are often complex. The <code>ContactComponent</code> has its own <code>ContactService</code> and <a href="../pipes/#custom-pipes">custom pipe</a> (called <code>Awesome</code>), and an alternative version of the <code>HighlightDirective</code>.</p> <p>To make it manageable, place all contact-related material in an <code>src/app/contact</code> folder and break the component into three constituent HTML, TypeScript, and css files:</p> <code-tabs> <div class="pre-title">src/app/contact/contact.component.html</div>
<pre data-language="html">&lt;h2&gt;Contact of {{userName}}&lt;/h2&gt;
&lt;div *ngIf="msg" class="msg"&gt;{{msg}}&lt;/div&gt;

&lt;form *ngIf="contacts" (ngSubmit)="onSubmit()" #contactForm="ngForm"&gt;
  &lt;h3 highlight&gt;{{ contact.name | awesome }}&lt;/h3&gt;
  &lt;div class="form-group"&gt;
    &lt;label for="name"&gt;Name&lt;/label&gt;
    &lt;input type="text" class="form-control" required
      [(ngModel)]="contact.name"
        name="name"  #name="ngModel" &gt;
    &lt;div [hidden]="name.valid" class="alert alert-danger"&gt;
      Name is required
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;br&gt;
  &lt;button type="submit" class="btn btn-default" [disabled]="!contactForm.form.valid"&gt;Save&lt;/button&gt;
  &lt;button type="button" class="btn" (click)="next()" [disabled]="!contactForm.form.valid"&gt;Next Contact&lt;/button&gt;
  &lt;button type="button" class="btn" (click)="newContact()"&gt;New Contact&lt;/button&gt;
&lt;/form&gt;</pre> <div class="pre-title">src/app/contact/contact.component.ts</div>
<pre data-language="typescript">import { Component, OnInit }      from '@angular/core';

import { Contact, ContactService } from './contact.service';
import { UserService }    from '../user.service';

@Component({
  selector: 'app-contact',
  templateUrl: './contact.component.html',
  styleUrls: [ './contact.component.css' ]
})
export class ContactComponent implements OnInit {
  contact:  Contact;
  contacts: Contact[];

  msg = 'Loading contacts ...';
  userName = '';

  constructor(private contactService: ContactService, userService: UserService) {
    this.userName = userService.userName;
  }

  ngOnInit() {
    this.contactService.getContacts().then(contacts =&gt; {
      this.msg = '';
      this.contacts = contacts;
      this.contact = contacts[0];
    });
  }

  next() {
    let ix = 1 + this.contacts.indexOf(this.contact);
    if (ix &gt;= this.contacts.length) { ix = 0; }
    this.contact = this.contacts[ix];
  }

  onSubmit() {
    // POST-DEMO TODO: do something like save it
    this.displayMessage('Saved ' + this.contact.name);
  }

  newContact() {
    this.displayMessage('New contact');
    this.contact = {id: 42, name: ''};
    this.contacts.push(this.contact);
  }

  /** Display a message briefly, then remove it. */
  displayMessage(msg: string) {
    this.msg = msg;
    setTimeout(() =&gt; this.msg = '', 1500);
  }
}</pre> <div class="pre-title">src/app/contact/contact.component.css</div>
<pre data-language="css">.ng-valid[required] {
  border-left: 5px solid #42A948; /* green */
}

.ng-invalid {
  border-left: 5px solid #a94442; /* red */
}

.alert {
  padding: 15px;
  margin: 8px 0;
  border: 1px solid transparent;
  border-radius: 4px;
}
.alert-danger {
  color: #a94442;
  background-color: #f2dede;
  border-color: #ebccd1;
}

.msg {
  color: blue;
  background-color: whitesmoke;
  border: 1px solid transparent;
  border-radius: 4px;
  margin-bottom: 20px;
}</pre> <div class="pre-title">src/app/contact/contact.service.ts</div>
<pre data-language="typescript">import { Injectable } from '@angular/core';

export class Contact {
  constructor(public id: number, public name: string) { }
}

const CONTACTS: Contact[] = [
  new Contact(21, 'Sam Spade'),
  new Contact(22, 'Nick Danger'),
  new Contact(23, 'Nancy Drew')
];

const FETCH_LATENCY = 500;

@Injectable()
export class ContactService {

  getContacts() {
    return new Promise&lt;Contact[]&gt;(resolve =&gt; {
      setTimeout(() =&gt; { resolve(CONTACTS); }, FETCH_LATENCY);
    });
  }

  getContact(id: number | string) {
    return this.getContacts()
      .then(heroes =&gt; heroes.find(hero =&gt; hero.id === +id));
  }
}</pre> <div class="pre-title">src/app/contact/awesome.pipe.ts</div>
<pre data-language="typescript">import { Pipe, PipeTransform } from '@angular/core';

@Pipe({ name: 'awesome' })
/** Precede the input string with the word "Awesome " */
export class AwesomePipe implements PipeTransform {
  transform(phrase: string) {
    return phrase ? 'Awesome ' + phrase : '';
  }
}</pre> <div class="pre-title">src/app/contact/highlight.directive.ts</div>
<pre data-language="typescript">import { Directive, ElementRef } from '@angular/core';

@Directive({ selector: '[highlight], input' })
/** Highlight the attached element or an InputElement in blue */
export class HighlightDirective {
  constructor(el: ElementRef) {
    el.nativeElement.style.backgroundColor = 'powderblue';
    console.log(
      `* Contact highlight called for ${el.nativeElement.tagName}`);
  }
}</pre> </code-tabs> <p>In the middle of the component template, notice the two-way data binding <code>[(<a href="../../api/forms/ngcontrolstatus/" class="code-anchor">ngModel</a>)]</code>. <code><a href="../../api/forms/ngcontrolstatus/" class="code-anchor">ngModel</a></code> is the selector for the <code><a href="../../api/forms/ngmodel/" class="code-anchor">NgModel</a></code> directive.</p> <p>Although <code><a href="../../api/forms/ngmodel/" class="code-anchor">NgModel</a></code> is an Angular directive, the <em>Angular compiler</em> won't recognize it for the following reasons:</p> <ul> <li>
<code>AppModule</code> doesn't declare <code><a href="../../api/forms/ngmodel/" class="code-anchor">NgModel</a></code>.</li> <li>
<code><a href="../../api/forms/ngmodel/" class="code-anchor">NgModel</a></code> wasn't imported via <code><a href="../../api/platform-browser/browsermodule/" class="code-anchor">BrowserModule</a></code>.</li> </ul> <p>Even if Angular somehow recognized <code><a href="../../api/forms/ngcontrolstatus/" class="code-anchor">ngModel</a></code>, <code>ContactComponent</code> wouldn't behave like an Angular form because form features such as validation aren't yet available.</p> <h3 class="no-toc" id="import-the-formsmodule">Import the FormsModule</h3> <p>Add the <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code> to the <code>AppModule</code> metadata's <code>imports</code> list.</p> <div class="pre-title">src/app/app.module.ts</div>
<pre data-language="typescript">imports: [ BrowserModule, FormsModule ],</pre> <p>Now <code>[(<a href="../../api/forms/ngcontrolstatus/" class="code-anchor">ngModel</a>)]</code> binding will work and the user input will be validated by Angular forms, once you declare the new component, pipe, and directive.</p> <blockquote class="alert is-critical"> <p><em>Do not</em> add <code><a href="../../api/forms/ngmodel/" class="code-anchor">NgModel</a></code>—or the <code>FORMS_DIRECTIVES</code>—to the <code>AppModule</code> metadata's declarations. These directives belong to the <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code>.</p> <p>Components, directives, and pipes belong to <em>one module only</em>.</p> <p><em>Never re-declare classes that belong to another module.</em></p> </blockquote>  <h3 class="no-toc" id="declare-the-contact-component-directive-and-pipe">Declare the contact component, directive, and pipe</h3> <p>The application won't compile until you declare the contact component, directive, and pipe. Update the <code>declarations</code> in the <code>AppModule</code> accordingly:</p> <div class="pre-title">src/app/app.module.ts (declarations)</div>
<pre data-language="typescript">declarations: [
  AppComponent,
  HighlightDirective,
  TitleComponent,

  AwesomePipe,
  ContactComponent,
  ContactHighlightDirective
],</pre>  <blockquote class="l-sub-section"> <p>There are two directives with the same name, both called <code>HighlightDirective</code>.</p> <p>To work around this, create an alias for the contact version using the <code>as</code> JavaScript import keyword.</p> <div class="pre-title">src/app/app.module.1b.ts</div>
<pre data-language="typescript">import {
  HighlightDirective as ContactHighlightDirective
} from './contact/highlight.directive';</pre> <p>This solves the immediate issue of referencing both directive <em>types</em> in the same file but leaves another issue unresolved. You'll learn more about that issue later in this page, in <a href="../ngmodule/#resolve-conflicts">Resolve directive conflicts</a>.</p> </blockquote> <h3 class="no-toc" id="provide-the-_contactservice_">Provide the _ContactService_</h3> The `ContactComponent` displays contacts retrieved by the `ContactService`, which Angular injects into its constructor. <p>You have to provide that service somewhere. The <code>ContactComponent</code> could provide it, but then the service would be scoped to this component only. You want to share this service with other contact-related components that you'll surely add later.</p> <p>In this app, add <code>ContactService</code> to the <code>AppModule</code> metadata's <code>providers</code> list:</p> <div class="pre-title">src/app/app.module.ts (providers)</div>
<pre data-language="typescript">providers: [ ContactService, UserService ],</pre> <p>Now you can inject <code>ContactService</code> (like <code>UserService</code>) into any component in the application.</p>  <blockquote class="l-sub-section"> <h4 class="no-toc" id="application-scoped-providers">Application-scoped providers</h4> The `ContactService` provider is _application_-scoped because Angular registers a module's `providers` with the application's *root injector*. <p> Architecturally, the <code>ContactService</code> belongs to the Contact business domain. Classes in other domains don't need the <code>ContactService</code> and shouldn't inject it.</p> <p> You might expect Angular to offer a <em>module</em>-scoping mechanism to enforce this design. It doesn't. NgModule instances, unlike components, don't have their own injectors so they can't have their own provider scopes.</p> <p> This omission is intentional. NgModules are designed primarily to extend an application, to enrich the entire app with the module's capabilities.</p> <p> In practice, service scoping is rarely an issue. Non-contact components can't accidentally inject the <code>ContactService</code>. To inject <code>ContactService</code>, you must first import its <em>type</em>. Only Contact components should import the <code>ContactService</code> type.</p> <p> Read more in the <a href="../ngmodule-faq/#q-component-scoped-providers">How do I restrict service scope to a module?</a> section of the <a href="../ngmodule-faq/">NgModule FAQs</a> page.</p> </blockquote> <h3 class="no-toc" id="run-the-app">Run the app</h3> Everything is in place to run the application with its contact editor. <p>The app file structure looks like this:</p> <pre>app
  app.component.ts
  app.module.ts
  highlight.directive.ts
  title.component.(html|ts)
  user.service.ts
  contact
    awesome.pipe.ts
    contact.component.(css|html|ts)
    contact.service.ts
    highlight.directive.ts</pre> <p>Try the example:</p>   <h2 id="resolve-directive-conflicts">Resolve directive conflicts</h2>  <p>An issue arose <a href="../ngmodule/#import-name-conflict">earlier</a> when you declared the contact's <code>HighlightDirective</code> because you already had a <code>HighlightDirective</code> class at the application level.</p> <p>The selectors of the two directives both highlight the attached element with a different color.</p> <code-tabs> <div class="pre-title">src/app/highlight.directive.ts</div>
<pre data-language="typescript">import { Directive, ElementRef } from '@angular/core';

@Directive({ selector: '[highlight]' })
/** Highlight the attached element in gold */
export class HighlightDirective {
  constructor(el: ElementRef) {
    el.nativeElement.style.backgroundColor = 'gold';
    console.log(
      `* AppRoot highlight called for ${el.nativeElement.tagName}`);
  }
}</pre> <div class="pre-title">src/app/contact/highlight.directive.ts</div>
<pre data-language="typescript">import { Directive, ElementRef } from '@angular/core';

@Directive({ selector: '[highlight], input' })
/** Highlight the attached element or an InputElement in blue */
export class HighlightDirective {
  constructor(el: ElementRef) {
    el.nativeElement.style.backgroundColor = 'powderblue';
    console.log(
      `* Contact highlight called for ${el.nativeElement.tagName}`);
  }
}</pre> </code-tabs> <p>Both directives are declared in this module so both directives are active.</p> <p>When the two directives compete to color the same element, the directive that's declared later wins because its DOM changes overwrite the first. In this case, the contact's <code>HighlightDirective</code> makes the application title text blue when it should stay gold.</p> <blockquote class="l-sub-section"> <p>The issue is that two different classes are trying to do the same thing.</p> <p>It's OK to import the same directive class multiple times. Angular removes duplicate classes and only registers one of them.</p> <p>But from Angular's perspective, two different classes, defined in different files, that have the same name are not duplicates. Angular keeps both directives and they take turns modifying the same HTML element.</p> </blockquote> <p>At least the app still compiles. If you define two different component classes with the same selector specifying the same element tag, the compiler reports an error. It can't insert two components in the same DOM location.</p> <p>To eliminate component and directive conflicts, create feature modules that insulate the declarations in one module from the declarations in another.</p>  <h2 id="feature-modules">Feature modules</h2> <p>This application isn't big yet, but it's already experiencing structural issues.</p> <ul> <li>The root <code>AppModule</code> grows larger with each new application class.</li> <li>There are conflicting directives. The <code>HighlightDirective</code> in the contact re-colors the work done by the <code>HighlightDirective</code> declared in <code>AppModule</code>. Also, it colors the application title text when it should color only the <code>ContactComponent</code>.</li> <li>The app lacks clear boundaries between contact functionality and other application features. That lack of clarity makes it harder to assign development responsibilities to different teams.</li> </ul> <p>You can resolve these issues with <em>feature modules</em>.</p> <p>A feature module is a class adorned by the <code>@<a href="../../api/core/ngmodule/" class="code-anchor">NgModule</a></code> decorator and its metadata, just like a root module. Feature module metadata have the same properties as the metadata for a root module.</p> <p>The root module and the feature module share the same execution context. They share the same dependency injector, which means the services in one module are available to all.</p> <p>The modules have the following significant technical differences:</p> <ul> <li>You <em>boot</em> the root module to <em>launch</em> the app; you <em>import</em> a feature module to <em>extend</em> the app.</li> <li>A feature module can expose or hide its implementation from other modules.</li> </ul> <p>Otherwise, a feature module is distinguished primarily by its intent.</p> <p>A feature module delivers a cohesive set of functionality focused on an application business domain, user workflow, facility (forms, http, routing), or collection of related utilities.</p> <p>While you can do everything within the root module, feature modules help you partition the app into areas of specific interest and purpose.</p>  <p>A feature module collaborates with the root module and with other modules through the services it provides and the components, directives, and pipes that it shares.</p> <p>In the next section, you'll carve the contact functionality out of the root module and into a dedicated feature module.</p>  <h3 id="make-contact-a-feature-module">Make <code>Contact</code> a feature module</h3>  <p>It's easy to refactor the contact material into a contact feature module.</p> <ol> <li>Create the <code>ContactModule</code> in the <code>src/app/contact</code> folder.</li> <li>Move the contact material from <code>AppModule</code> to <code>ContactModule</code>.</li> <li>Replace the imported <code><a href="../../api/platform-browser/browsermodule/" class="code-anchor">BrowserModule</a></code> with <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code>.</li> <li>Import the <code>ContactModule</code> into the <code>AppModule</code>.</li> </ol> <p><code>AppModule</code> is the only existing class that changes. But you do add one new file.</p> <h3 id="add-the-contactmodule">Add the <code>ContactModule</code>
</h3> <p>Here's the new <code>ContactModule</code>:</p> <div class="pre-title">src/app/contact/contact.module.ts</div>
<pre data-language="typescript">import { NgModule }           from '@angular/core';
import { CommonModule }       from '@angular/common';
import { FormsModule }        from '@angular/forms';

import { AwesomePipe }        from './awesome.pipe';

import
       { ContactComponent }   from './contact.component';
import { ContactService }     from './contact.service';
import { HighlightDirective } from './highlight.directive';

@NgModule({
  imports:      [ CommonModule, FormsModule ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  exports:      [ ContactComponent ],
  providers:    [ ContactService ]
})
export class ContactModule { }</pre> <p>You copy from <code>AppModule</code> the contact-related import statements and <code>@<a href="../../api/core/ngmodule/" class="code-anchor">NgModule</a></code> properties that concern the contact, and paste them into <code>ContactModule</code>.</p> <p>You <em>import</em> the <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code> because the contact component needs it.</p> <blockquote class="alert is-important"> <p>Modules don't inherit access to the components, directives, or pipes that are declared in other modules. What <code>AppModule</code> imports is irrelevant to <code>ContactModule</code> and vice versa. Before <code>ContactComponent</code> can bind with <code>[(<a href="../../api/forms/ngcontrolstatus/" class="code-anchor">ngModel</a>)]</code>, its <code>ContactModule</code> must import <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code>.</p> </blockquote> <p>You also replaced <code><a href="../../api/platform-browser/browsermodule/" class="code-anchor">BrowserModule</a></code> by <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code>, for reasons explained in the <a href="../ngmodule-faq/#q-browser-vs-common-module">Should I import BrowserModule or CommonModule?</a> section of the <a href="../ngmodule-faq/">NgModule FAQs</a> page.</p> <p>You <em>declare</em> the contact component, directive, and pipe in the module <code>declarations</code>.</p> <p>You <em>export</em> the <code>ContactComponent</code> so other modules that import the <code>ContactModule</code> can include it in their component templates.</p> <p>All other declared contact classes are private by default. The <code>AwesomePipe</code> and <code>HighlightDirective</code> are hidden from the rest of the application. The <code>HighlightDirective</code> can no longer color the <code>AppComponent</code> title text.</p> <h3 id="refactor-the-appmodule">Refactor the <code>AppModule</code>
</h3> <p>Return to the <code>AppModule</code> and remove everything specific to the contact feature set.</p> <ul> <li>Delete the contact import statements.</li> <li>Delete the contact declarations and contact providers.</li> <li>Delete the <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code> from the <code>imports</code> list (<code>AppComponent</code> doesn't need it).</li> </ul> <p>Leave only the classes required at the application root level.</p> <p>Then import the <code>ContactModule</code> so the app can continue to display the exported <code>ContactComponent</code>.</p> <p>Here's the refactored version of the <code>AppModule</code> along with the previous version.</p> <code-tabs> <div class="pre-title">src/app/app.module.ts (v2)</div>
<pre data-language="typescript">import { NgModule }           from '@angular/core';
import { BrowserModule }      from '@angular/platform-browser';

/* App Root */
import
       { AppComponent }       from './app.component';
import { HighlightDirective } from './highlight.directive';
import { TitleComponent }     from './title.component';
import { UserService }        from './user.service';

/* Contact Imports */
import
       { ContactModule }      from './contact/contact.module';

@NgModule({
  imports:      [ BrowserModule, ContactModule ],
  declarations: [ AppComponent, HighlightDirective, TitleComponent ],
  providers:    [ UserService ],
  bootstrap:    [ AppComponent ],
})
export class AppModule { }</pre> <div class="pre-title">src/app/app.module.ts (v1)</div>
<pre data-language="typescript">import { NgModule }           from '@angular/core';
import { BrowserModule }      from '@angular/platform-browser';

/* App Root */
import
       { AppComponent }       from './app.component';
import { HighlightDirective } from './highlight.directive';
import { TitleComponent }     from './title.component';
import { UserService }        from './user.service';

/* Contact Imports */
import
       { ContactComponent }   from './contact/contact.component';
import { ContactService }     from './contact/contact.service';
import { AwesomePipe }        from './contact/awesome.pipe';

import {
  HighlightDirective as ContactHighlightDirective
} from './contact/highlight.directive';

import { FormsModule }        from '@angular/forms';

@NgModule({
  imports: [ BrowserModule,  FormsModule ],
  declarations: [
    AppComponent, HighlightDirective, TitleComponent,
    AwesomePipe, ContactComponent, ContactHighlightDirective
  ],
  providers: [ ContactService, UserService ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }</pre> </code-tabs> <h3 id="improvements">Improvements</h3> <p>There's a lot to like in the revised <code>AppModule</code>.</p> <ul> <li> <p>It does not change as the <em>Contact</em> domain grows.</p> </li> <li> <p>It only changes when you add new modules.</p> </li> <li> <p>It's simpler:</p> <ul> <li>Fewer import statements.</li> <li>No <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code> import.</li> <li>No contact-specific declarations.</li> <li>No <code>ContactService</code> provider.</li> <li>No <code>HighlightDirective</code> conflict.</li> </ul> </li> </ul> <p>Try this <code>ContactModule</code> version of the sample.</p> <p><span embedded="" plnkr="contact.2" img="guide/ngmodule/contact-2-plunker.png">Try the live example.</span></p>  <h2 id="lazy-loading-modules-with-the-router">Lazy-loading modules with the router</h2> <p>The Heroic Staffing Agency sample app has evolved. It has two more modules, one for managing the heroes on staff and another for matching crises to the heroes. Both modules are in the early stages of development. Their specifics aren't important to the story and this page doesn't discuss every line of code.</p> <blockquote class="l-sub-section"> <p>Examine and download the complete source for this version from the <span plnkr="pre-shared.3" img="guide/ngmodule/v3-plunker.png">live example.</span></p> </blockquote> <p>Some facets of the current application merit discussion are as follows:</p> <ul> <li>The app has three feature modules: Contact, Hero, and Crisis.</li> <li>The Angular router helps users navigate among these modules.</li> <li>The <code>ContactComponent</code> is the default destination when the app starts.</li> <li>The <code>ContactModule</code> continues to be "eagerly" loaded when the application starts.</li> <li>
<code>HeroModule</code> and the <code>CrisisModule</code> are lazy loaded.</li> </ul>  <p>The new <code>AppComponent</code> template has a title, three links, and a <code>&lt;router-outlet&gt;</code>.</p> <div class="pre-title">src/app/app.component.ts (v3 - Template)</div>
<pre data-language="typescript">template: `
  &lt;app-title [subtitle]="subtitle"&gt;&lt;/app-title&gt;
  &lt;nav&gt;
    &lt;a routerLink="contact" routerLinkActive="active"&gt;Contact&lt;/a&gt;
    &lt;a routerLink="crisis"  routerLinkActive="active"&gt;Crisis Center&lt;/a&gt;
    &lt;a routerLink="heroes"  routerLinkActive="active"&gt;Heroes&lt;/a&gt;
  &lt;/nav&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
`</pre> <p>The <code>&lt;app-contact&gt;</code> element is gone; you're routing to the <em>Contact</em> page now.</p> <p>The <code>AppModule</code> has changed modestly:</p> <div class="pre-title">src/app/app.module.ts (v3)</div>
<pre data-language="typescript">import { NgModule }           from '@angular/core';
import { BrowserModule }      from '@angular/platform-browser';

/* App Root */
import { AppComponent }       from './app.component.3';
import { HighlightDirective } from './highlight.directive';
import { TitleComponent }     from './title.component';
import { UserService }        from './user.service';

/* Feature Modules */
import { ContactModule }      from './contact/contact.module.3';

/* Routing Module */
import { AppRoutingModule }   from './app-routing.module.3';

@NgModule({
  imports:      [
    BrowserModule,
    ContactModule,
    AppRoutingModule
  ],
  providers:    [ UserService ],
  declarations: [ AppComponent, HighlightDirective, TitleComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }</pre> <blockquote class="l-sub-section"> <p>Some file names bear a <code>.3</code> extension that indicates a difference with prior or future versions. The significant differences will be explained in due course.</p>  </blockquote> <p>The module still imports <code>ContactModule</code> so that its routes and components are mounted when the app starts.</p> <p>The module does <em>not</em> import <code>HeroModule</code> or <code>CrisisModule</code>. They'll be fetched and mounted asynchronously when the user navigates to one of their routes.</p> <p>The significant change from version 2 is the addition of the <em>AppRoutingModule</em> to the module <code>imports</code>. The <code>AppRoutingModule</code> is a <a href="../router/#routing-module">routing module</a> that handles the app's routing concerns.</p> <h3 id="app-routing">App routing</h3> <div class="pre-title">src/app/app-routing.module.ts</div>
<pre data-language="typescript">import { NgModule }             from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

export const routes: Routes = [
  { path: '', redirectTo: 'contact', pathMatch: 'full'},
  { path: 'crisis', loadChildren: 'app/crisis/crisis.module#CrisisModule' },
  { path: 'heroes', loadChildren: 'app/hero/hero.module#HeroModule' }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}</pre> <p>The router is the subject of the <a href="../router/">Routing &amp; Navigation</a> page, so this section skips many of the details and concentrates on the intersection of NgModules and routing.</p> <p>The <code>app-routing.module.ts</code> file defines three routes.</p> <p>The first route redirects the empty URL (such as <code>http://host.com/</code>) to another route whose path is <code>contact</code> (such as <code>http://host.com/contact</code>).</p> <p>The <code>contact</code> route isn't defined here. It's defined in the <em>Contact</em> feature's <em>own</em> routing module, <code>contact-routing.module.ts</code>. It's standard practice for feature modules with routing components to define their own routes. You'll get to that file in a moment.</p> <p>The remaining two routes use lazy loading syntax to tell the router where to find the modules:</p> <div class="pre-title">src/app/app-routing.module.ts</div>
<pre data-language="typescript">{ path: 'crisis', loadChildren: 'app/crisis/crisis.module#CrisisModule' },
{ path: 'heroes', loadChildren: 'app/hero/hero.module#HeroModule' }</pre> <blockquote class="l-sub-section"> <p>A lazy-loaded module location is a <em>string</em>, not a <em>type</em>. In this app, the string identifies both the module <em>file</em> and the module <em>class</em>, the latter separated from the former by a <code>#</code>.</p> </blockquote> <h3 id="routermoduleforroot">RouterModule.forRoot</h3> <p>The <code>forRoot</code> static class method of the <code><a href="../../api/router/routermodule/" class="code-anchor">RouterModule</a></code> with the provided configuration and added to the <code>imports</code> array provides the routing concerns for the module.</p> <div class="pre-title">src/app/app-routing.module.ts</div>
<pre data-language="typescript">@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}</pre> <p>The returned <code>AppRoutingModule</code> class is a <code>Routing Module</code> containing both the <code><a href="../../api/router/routermodule/" class="code-anchor">RouterModule</a></code> directives and the dependency-injection providers that produce a configured <code><a href="../../api/router/router/" class="code-anchor">Router</a></code>.</p> <p>This <code>AppRoutingModule</code> is intended for the app <em>root</em> module only.</p> <blockquote class="alert is-critical"> <p>Never call <code><a href="../../api/router/routermodule/" class="code-anchor">RouterModule</a>.forRoot</code> in a feature-routing module.</p> </blockquote> <p>Back in the root <code>AppModule</code>, add the <code>AppRoutingModule</code> to its <code>imports</code> list, and the app is ready to navigate.</p> <div class="pre-title">src/app/app.module.ts (imports)</div>
<pre data-language="typescript">imports:      [
  BrowserModule,
  ContactModule,
  AppRoutingModule
],</pre> <h3 id="routing-to-a-feature-module">Routing to a feature module</h3> <p>The <code>src/app/contact</code> folder holds a new file, <code>contact-routing.module.ts</code>. It defines the <code>contact</code> route mentioned earlier and provides a <code>ContactRoutingModule</code> as follows:</p> <div class="pre-title">src/app/contact/contact-routing.module.ts (routing)</div>
<pre data-language="typescript">@NgModule({
  imports: [RouterModule.forChild([
    { path: 'contact', component: ContactComponent }
  ])],
  exports: [RouterModule]
})
export class ContactRoutingModule {}</pre> <p>This time you pass the route list to the <code>forChild</code> method of the <code><a href="../../api/router/routermodule/" class="code-anchor">RouterModule</a></code>. The route list is only responsible for providing additional routes and is intended for feature modules.</p> <blockquote class="alert is-important"> <p>Always call <code><a href="../../api/router/routermodule/" class="code-anchor">RouterModule</a>.forChild</code> in a feature-routing module.</p> </blockquote> <blockquote class="alert is-helpful"> <p><em>forRoot</em> and <em>forChild</em> are conventional names for methods that deliver different <code>import</code> values to root and feature modules. Angular doesn't recognize them but Angular developers do.</p> <p><a href="../ngmodule-faq/#q-for-root">Follow this convention</a> if you write a similar module that has both shared <a href="../ngmodule-faq/#q-declarable">declarables</a> and services.</p> </blockquote> <p><code>ContactModule</code> has changed in two small but important ways.</p> <code-tabs> <div class="pre-title">src/app/contact/contact.module.3.ts</div>
<pre data-language="typescript">@NgModule({
  imports:      [ CommonModule, FormsModule, ContactRoutingModule ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  providers:    [ ContactService ]
})
export class ContactModule { }</pre> <div class="pre-title">src/app/contact/contact.module.2.ts</div>
<pre data-language="typescript">@NgModule({
  imports:      [ CommonModule, FormsModule ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  exports:      [ ContactComponent ],
  providers:    [ ContactService ]
})
export class ContactModule { }</pre> </code-tabs> <ul> <li>It imports the <code>ContactRoutingModule</code> object from <code>contact-routing.module.ts</code>.</li> <li>It no longer exports <code>ContactComponent</code>.</li> </ul> <p>Now that you navigate to <code>ContactComponent</code> with the router, there's no reason to make it public. Also, <code>ContactComponent</code> doesn't need a selector. No template will ever again reference this <code>ContactComponent</code>. It's gone from the <a href="../ngmodule/#app-component-template">AppComponent template</a>.</p>  <h3 id="lazy-loaded-routing-to-a-module">Lazy-loaded routing to a module</h3> <p>The lazy-loaded <code>HeroModule</code> and <code>CrisisModule</code> follow the same principles as any feature module. They don't look different from the eagerly loaded <code>ContactModule</code>.</p> <p>The <code>HeroModule</code> is a bit more complex than the <code>CrisisModule</code>, which makes it a more interesting and useful example. Its file structure is as follows:</p> <pre>hero
  hero-detail.component.ts
  hero-list.component.ts
  hero.component.ts
  hero.module.ts
  hero-routing.module.ts
  hero.service.ts
  highlight.directive.ts</pre> <p>This is the child routing scenario familiar to readers of the <a href="../router/#child-routing-component">Child routing component</a> section of the <a href="../router/#child-routing-component">Routing &amp; Navigation</a> page. The <code>HeroComponent</code> is the feature's top component and routing host. Its template has a <code>&lt;router-outlet&gt;</code> that displays either a list of heroes (<code>HeroList</code>) or an editor of a selected hero (<code>HeroDetail</code>). Both components delegate to the <code>HeroService</code> to fetch and save data.</p> <p>Yet another <code>HighlightDirective</code> colors elements in yet a different shade. In the next section, <a href="../ngmodule/#shared-module" title="Shared modules">Shared modules</a>, you'll resolve the repetition and inconsistencies.</p> <p>The <code>HeroModule</code> is a feature module like any other.</p> <div class="pre-title">src/app/hero/hero.module.ts (class)</div>
<pre data-language="typescript">@NgModule({
  imports: [ CommonModule, FormsModule, HeroRoutingModule ],
  declarations: [
    HeroComponent, HeroDetailComponent, HeroListComponent,
    HighlightDirective
  ]
})
export class HeroModule { }</pre> <p>It imports the <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code> because the <code>HeroDetailComponent</code> template binds with <code>[(<a href="../../api/forms/ngcontrolstatus/" class="code-anchor">ngModel</a>)]</code>. It imports the <code>HeroRoutingModule</code> from <code>hero-routing.module.ts</code> just as <code>ContactModule</code> and <code>CrisisModule</code> do.</p> <p>The <code>CrisisModule</code> is much the same.</p> <p><span embedded="" plnkr="pre-shared.3" img="guide/ngmodule/v3-plunker.png">Try the live example.</span></p>  <h2 id="shared-modules">Shared modules</h2> <p>The app is shaping up. But it carries three different versions of the <code>HighlightDirective</code>. And the many files cluttering the app folder level could be better organized.</p> <p>Add a <code>SharedModule</code> to hold the common components, directives, and pipes and share them with the modules that need them.</p> <ol> <li>Create an <code>src/app/shared</code> folder.</li> <li>Move the <code>AwesomePipe</code> and <code>HighlightDirective</code> from <code>src/app/contact</code> to <code>src/app/shared</code>.</li> <li>Delete the <code>HighlightDirective</code> classes from <code>src/app/</code> and <code>src/app/hero</code>.</li> <li>Create a <code>SharedModule</code> class to own the shared material.</li> <li>Update other feature modules to import <code>SharedModule</code>.</li> </ol> <p>Here is the <code>SharedModule</code>:</p> <div class="pre-title">src/app/src/app/shared/shared.module.ts</div>
<pre data-language="typescript">import { NgModule }            from '@angular/core';
import { CommonModule }        from '@angular/common';
import { FormsModule }         from '@angular/forms';

import { AwesomePipe }         from './awesome.pipe';
import { HighlightDirective }  from './highlight.directive';

@NgModule({
  imports:      [ CommonModule ],
  declarations: [ AwesomePipe, HighlightDirective ],
  exports:      [ AwesomePipe, HighlightDirective,
                  CommonModule, FormsModule ]
})
export class SharedModule { }</pre> <p>Note the following:</p> <ul> <li>It imports the <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code> because its component needs common directives.</li> <li>It declares and exports the utility pipe, directive, and component classes as expected.</li> <li>It re-exports the <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code> and <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code>
</li> </ul> <h3 id="re-exporting-other-modules">Re-exporting other modules</h3> <p>If you review the application, you may notice that many components requiring <code>SharedModule</code> directives also use <code><a href="../../api/common/ngif/" class="code-anchor">NgIf</a></code> and <code><a href="../../api/common/ngfor/" class="code-anchor">NgFor</a></code> from <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code> and bind to component properties with <code>[(<a href="../../api/forms/ngcontrolstatus/" class="code-anchor">ngModel</a>)]</code>, a directive in the <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code>. Modules that declare these components would have to import <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code>, <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code>, and <code>SharedModule</code>.</p> <p>You can reduce the repetition by having <code>SharedModule</code> re-export <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code> and <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code> so that importers of <code>SharedModule</code> get <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code> and <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code> for free.</p> <p>As it happens, the components declared by <code>SharedModule</code> itself don't bind with <code>[(<a href="../../api/forms/ngcontrolstatus/" class="code-anchor">ngModel</a>)]</code>. Technically, there is no need for <code>SharedModule</code> to import <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code>.</p> <p><code>SharedModule</code> can still export <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code> without listing it among its <code>imports</code>.</p> <h3 id="why-titlecomponent-isnt-shared">Why <code>TitleComponent</code> isn't shared</h3> <p><code>SharedModule</code> exists to make commonly used components, directives, and pipes available for use in the templates of components in many other modules.</p> <p>The <code>TitleComponent</code> is used only once by the <code>AppComponent</code>. There's no point in sharing it.</p>  <h3 id="why-userservice-isnt-shared">Why <code>UserService</code> isn't shared</h3> <p>While many components share the same service instances, they rely on Angular dependency injection to do this kind of sharing, not the module system.</p> <p>Several components of the sample inject the <code>UserService</code>. There should be only one instance of the <code>UserService</code> in the entire application and only one provider of it.</p> <p><code>UserService</code> is an application-wide singleton. You don't want each module to have its own separate instance. Yet there is <a href="../ngmodule-faq/#q-why-bad">a real danger</a> of that happening</p>  <p>if the <code>SharedModule</code> provides the <code>UserService</code>.</p> <blockquote class="alert is-critical"> <p>Do <em>not</em> specify app-wide singleton <code>providers</code> in a shared module. A lazy-loaded module that imports that shared module makes its own copy of the service.</p> </blockquote>  <h2 id="the-core-module">The Core module</h2> <p>At the moment, the root folder is cluttered with the <code>UserService</code> and <code>TitleComponent</code> that only appear in the root <code>AppComponent</code>. You didn't include them in the <code>SharedModule</code> for reasons just explained.</p> <p>Instead, gather them in a single <code>CoreModule</code> that you import once when the app starts and never import anywhere else.</p> <p>Perform the following steps:</p> <ol> <li>Create an <code>src/app/core</code> folder.</li> </ol> <ul> <li>Move the <code>UserService</code> and <code>TitleComponent</code> from <code>src/app/</code> to <code>src/app/core</code>.</li> <li>Create a <code>CoreModule</code> class to own the core material.</li> <li>Update the <code>AppRoot</code> module to import <code>CoreModule</code>.</li> </ul> <p>Most of this work is familiar. The interesting part is the <code>CoreModule</code>.</p> <div class="pre-title">src/app/src/app/core/core.module.ts</div>
<pre data-language="typescript">import {
  ModuleWithProviders, NgModule,
  Optional, SkipSelf }       from '@angular/core';

import { CommonModule }      from '@angular/common';

import { TitleComponent }    from './title.component';
import { UserService }       from './user.service';
@NgModule({
  imports:      [ CommonModule ],
  declarations: [ TitleComponent ],
  exports:      [ TitleComponent ],
  providers:    [ UserService ]
})
export class CoreModule {
}</pre> <blockquote class="l-sub-section"> <p>You're importing some extra symbols from the Angular core library that you're not using yet. They'll become relevant later in this page.</p> </blockquote> <p>The <code>@<a href="../../api/core/ngmodule/" class="code-anchor">NgModule</a></code> metadata should be familiar. You declare the <code>TitleComponent</code> because this module owns it and you export it because <code>AppComponent</code> (which is in <code>AppModule</code>) displays the title in its template. <code>TitleComponent</code> needs the Angular <code><a href="../../api/common/ngif/" class="code-anchor">NgIf</a></code> directive that you import from <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code>.</p> <p><code>CoreModule</code> provides the <code>UserService</code>. Angular registers that provider with the app root injector, making a singleton instance of the <code>UserService</code> available to any component that needs it, whether that component is eagerly or lazily loaded.</p> <blockquote class="l-sub-section"> <h4 class="no-toc" id="why-bother">Why bother?</h4> This scenario is clearly contrived. The app is too small to worry about a single service file and a tiny, one-time component. <p>A <code>TitleComponent</code> sitting in the root folder isn't bothering anyone. The root <code>AppModule</code> can register the <code>UserService</code> itself, as it does currently, even if you decide to relocate the <code>UserService</code> file to the <code>src/app/core</code> folder.</p> <p>Real-world apps have more to worry about. They can have several single-use components (such as spinners, message toasts, and modal dialogs) that appear only in the <code>AppComponent</code> template. You don't import them elsewhere so they're not shared in that sense. Yet they're too big and messy to leave loose in the root folder.</p> <p>Apps often have many singleton services like this sample's <code>UserService</code>. Each must be registered exactly once, in the app root injector, when the application starts.</p> <p>While many components inject such services in their constructors—and therefore require JavaScript <code>import</code> statements to import their symbols—no other component or module should define or re-create the services themselves. Their <em>providers</em> aren't shared.</p> <p>We recommend collecting such single-use classes and hiding their details inside a <code>CoreModule</code>. A simplified root <code>AppModule</code> imports <code>CoreModule</code> in its capacity as orchestrator of the application as a whole.</p> </blockquote> <h2 id="cleanup">Cleanup</h2> <p>Having refactored to a <code>CoreModule</code> and a <code>SharedModule</code>, it's time to clean up the other modules.</p> <h3 id="a-trimmer-appmodule">A trimmer <code>AppModule</code>
</h3> <p>Here is the updated <code>AppModule</code> paired with version 3 for comparison:</p> <code-tabs> <div class="pre-title">src/app/app.module.ts (v4)</div>
<pre data-language="typescript">import { NgModule }       from '@angular/core';
import { BrowserModule }  from '@angular/platform-browser';

/* App Root */
import { AppComponent }   from './app.component';

/* Feature Modules */
import { ContactModule }    from './contact/contact.module';
import { CoreModule }       from './core/core.module';

/* Routing Module */
import { AppRoutingModule } from './app-routing.module';

@NgModule({
  imports: [
    BrowserModule,
    ContactModule,
    CoreModule,
    AppRoutingModule
  ],
  declarations: [ AppComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }</pre> <div class="pre-title">src/app/app.module.ts (v3)</div>
<pre data-language="typescript">import { NgModule }           from '@angular/core';
import { BrowserModule }      from '@angular/platform-browser';

/* App Root */
import { AppComponent }       from './app.component.3';
import { HighlightDirective } from './highlight.directive';
import { TitleComponent }     from './title.component';
import { UserService }        from './user.service';

/* Feature Modules */
import { ContactModule }      from './contact/contact.module.3';

/* Routing Module */
import { AppRoutingModule }   from './app-routing.module.3';

@NgModule({
  imports:      [
    BrowserModule,
    ContactModule,
    AppRoutingModule
  ],
  providers:    [ UserService ],
  declarations: [ AppComponent, HighlightDirective, TitleComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }</pre> </code-tabs> <p><code>AppModule</code> now has the following qualities:</p> <ul> <li>A little smaller because many <code>src/app/root</code> classes have moved to other modules.</li> <li>Stable because you'll add future components and providers to other modules, not this one.</li> <li>Delegated to imported modules rather than doing work.</li> <li>Focused on its main task, orchestrating the app as a whole.</li> </ul> <h3 id="a-trimmer-contactmodule">A trimmer <code>ContactModule</code>
</h3> <p>Here is the new <code>ContactModule</code> paired with the prior version:</p> <code-tabs> <div class="pre-title">src/app/contact/contact.module.ts (v4)</div>
<pre data-language="typescript">import { NgModule }           from '@angular/core';
import { SharedModule }       from '../shared/shared.module';

import { ContactComponent }     from './contact.component';
import { ContactService }       from './contact.service';
import { ContactRoutingModule } from './contact-routing.module';

@NgModule({
  imports:      [ SharedModule, ContactRoutingModule ],
  declarations: [ ContactComponent ],
  providers:    [ ContactService ]
})
export class ContactModule { }</pre> <div class="pre-title">src/app/contact/contact.module.ts (v3)</div>
<pre data-language="typescript">import { NgModule }           from '@angular/core';
import { CommonModule }       from '@angular/common';
import { FormsModule }        from '@angular/forms';

import { AwesomePipe }        from './awesome.pipe';

import { ContactComponent }   from './contact.component.3';
import { ContactService }     from './contact.service';
import { HighlightDirective } from './highlight.directive';

import { ContactRoutingModule }   from './contact-routing.module.3';

@NgModule({
  imports:      [ CommonModule, FormsModule, ContactRoutingModule ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  providers:    [ ContactService ]
})
export class ContactModule { }</pre> </code-tabs> <p>Notice the following:</p> <ul> <li>The <code>AwesomePipe</code> and <code>HighlightDirective</code> are gone.</li> <li>The imports include <code>SharedModule</code> instead of <code><a href="../../api/common/commonmodule/" class="code-anchor">CommonModule</a></code> and <code><a href="../../api/forms/formsmodule/" class="code-anchor">FormsModule</a></code>.</li> <li>The new version is leaner and cleaner.</li> </ul>   <h2 id="configure-core-services-with-coremoduleforroot">Configure core services with <code>CoreModule.forRoot</code>
</h2> <p>A module that adds providers to the application can offer a facility for configuring those providers as well.</p> <p>By convention, the <code>forRoot</code> static method both provides and configures services at the same time. It takes a service configuration object and returns a <a href="../../api/core/modulewithproviders/">ModuleWithProviders</a>, which is a simple object with the following properties:</p> <ul> <li>
<code>ngModule</code>: the <code>CoreModule</code> class</li> <li>
<code>providers</code>: the configured providers</li> </ul> <p>The root <code>AppModule</code> imports the <code>CoreModule</code> and adds the <code>providers</code> to the <code>AppModule</code> providers.</p> <blockquote class="l-sub-section"> <p>More precisely, Angular accumulates all imported providers before appending the items listed in <code>@<a href="../../api/core/ngmodule/" class="code-anchor">NgModule</a>.providers</code>. This sequence ensures that whatever you add explicitly to the <code>AppModule</code> providers takes precedence over the providers of imported modules.</p> </blockquote> <p>Add a <code>CoreModule.forRoot</code> method that configures the core <code>UserService</code>.</p> <p>You've extended the core <code>UserService</code> with an optional, injected <code>UserServiceConfig</code>. If a <code>UserServiceConfig</code> exists, the <code>UserService</code> sets the user name from that config.</p> <div class="pre-title">src/app/core/user.service.ts (constructor)</div>
<pre data-language="typescript">constructor(@Optional() config: UserServiceConfig) {
  if (config) { this._userName = config.userName; }
}</pre> <p>Here's <code>CoreModule.forRoot</code> that takes a <code>UserServiceConfig</code> object:</p> <div class="pre-title">src/app/core/core.module.ts (forRoot)</div>
<pre data-language="typescript">static forRoot(config: UserServiceConfig): ModuleWithProviders {
  return {
    ngModule: CoreModule,
    providers: [
      {provide: UserServiceConfig, useValue: config }
    ]
  };
}</pre> <p>Lastly, call it within the <code>imports</code> list of the <code>AppModule</code>.</p> <div class="pre-title">src/app//app.module.ts (imports)</div>
<pre data-language="typescript">imports: [
  BrowserModule,
  ContactModule,
  CoreModule.forRoot({userName: 'Miss Marple'}),
  AppRoutingModule
],</pre> <p>The app displays "Miss Marple" as the user instead of the default "Sherlock Holmes".</p> <blockquote class="alert is-important"> <p>Call <code>forRoot</code> only in the root application module, <code>AppModule</code>. Calling it in any other module, particularly in a lazy-loaded module, is contrary to the intent and can produce a runtime error.</p> <p>Remember to <em>import</em> the result; don't add it to any other <code>@<a href="../../api/core/ngmodule/" class="code-anchor">NgModule</a></code> list.</p> </blockquote>   <h2 id="prevent-reimport-of-the-coremodule">Prevent reimport of the <code>CoreModule</code>
</h2> <p>Only the root <code>AppModule</code> should import the <code>CoreModule</code>. <a href="../ngmodule-faq/#q-why-bad">Bad things happen</a> if a lazy-loaded module imports it.</p>  <p>You could hope that no developer makes that mistake. Or you can guard against it and fail fast by adding the following <code>CoreModule</code> constructor.</p> <div class="pre-title">src/app/core/core.module.ts</div>
<pre data-language="typescript">constructor (@Optional() @SkipSelf() parentModule: CoreModule) {
  if (parentModule) {
    throw new Error(
      'CoreModule is already loaded. Import it in the AppModule only');
  }
}</pre> <p>The constructor tells Angular to inject the <code>CoreModule</code> into itself. That seems dangerously circular.</p> <p>The injection would be circular if Angular looked for <code>CoreModule</code> in the <em>current</em> injector. The <code>@<a href="../../api/core/skipself/" class="code-anchor">SkipSelf</a></code> decorator means "look for <code>CoreModule</code> in an ancestor injector, above me in the injector hierarchy."</p> <p>If the constructor executes as intended in the <code>AppModule</code>, there is no ancestor injector that could provide an instance of <code>CoreModule</code>. The injector should give up.</p> <p>By default, the injector throws an error when it can't find a requested provider. The <code>@<a href="../../api/core/optional/" class="code-anchor">Optional</a></code> decorator means not finding the service is OK. The injector returns <code>null</code>, the <code>parentModule</code> parameter is null, and the constructor concludes uneventfully.</p> <p>It's a different story if you improperly import <code>CoreModule</code> into a lazy-loaded module such as <code>HeroModule</code> (try it).</p> <p>Angular creates a lazy-loaded module with its own injector, a <em>child</em> of the root injector. <code>@<a href="../../api/core/skipself/" class="code-anchor">SkipSelf</a></code> causes Angular to look for a <code>CoreModule</code> in the parent injector, which this time is the root injector. Of course it finds the instance imported by the root <code>AppModule</code>. Now <code>parentModule</code> exists and the constructor throws the error.</p> <h2 id="conclusion">Conclusion</h2> <p>You made it! You can examine and download the complete source for this final version from the live example. </p> <h2 id="frequently-asked-questions">Frequently asked questions</h2> <p>Now that you understand NgModules, you may be interested in the companion <a href="../ngmodule-faq/" title="NgModule FAQs">NgModule FAQs</a> page with its ready answers to specific design and implementation questions.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://v4.angular.io/guide/ngmodule" class="_attribution-link" target="_blank">https://v4.angular.io/guide/ngmodule</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
