
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Canvas3D (QML Type) - Qt 5.11 - W3cubDocs</title>
  
  <meta name="description" content=" Canvas that provides a 3D rendering context. More... ">
  <meta name="keywords" content="canvas, d, qml, type, -, qt, qt~5.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/qt~5.11/qml-qtcanvas3d-canvas3d/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/qt~5.11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt~5.11/" class="_nav-link" title="" style="margin-left:0;">Qt 5.11</a></span>
  
  <nav class="_nav">
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _qt">
				
				
<h1 class="title">Canvas3D QML Type</h1>   <p>Canvas that provides a 3D rendering context. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Import Statement:</td>
<td class="memItemRight bottomAlign"> import QtCanvas3D 1.1</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> QtCanvas3D 1.0</td>
</tr>
</table>
<ul> <li><a href="https://doc.qt.io/qt-5/qml-qtcanvas3d-canvas3d-members.html" target="_blank">List of all members, including inherited members</a></li> </ul>  <h2 id="properties">Properties
</h2> <ul> <li class="fn">
<b><b><a href="../qml-qtcanvas3d-canvas3d/#context-prop">context</a></b></b> : Context3D</li> <li class="fn">
<b><b><a href="../qml-qtcanvas3d-canvas3d/#devicePixelRatio-prop">devicePixelRatio</a></b></b> : float</li> <li class="fn">
<b><b><a href="../qml-qtcanvas3d-canvas3d/#fps-prop">fps</a></b></b> : int</li> <li class="fn">
<b><b><a href="../qml-qtcanvas3d-canvas3d/#pixelSize-prop">pixelSize</a></b></b> : size</li> <li class="fn">
<b><b><a href="../qml-qtcanvas3d-canvas3d/#renderOnDemand-prop">renderOnDemand</a></b></b> : bool</li> <li class="fn">
<b><b><a href="../qml-qtcanvas3d-canvas3d/#renderTarget-prop">renderTarget</a></b></b> : RenderTarget</li> </ul>  <h2 id="signals">Signals
</h2> <ul> <li class="fn">void <b><b><a href="../qml-qtcanvas3d-canvas3d/#contextLost-signal">contextLost</a></b></b>()</li> <li class="fn">void <b><b><a href="../qml-qtcanvas3d-canvas3d/#contextRestored-signal">contextRestored</a></b></b>()</li> <li class="fn">void <b><b><a href="../qml-qtcanvas3d-canvas3d/#initializeGL-signal">initializeGL</a></b></b>()</li> <li class="fn">void <b><b><a href="../qml-qtcanvas3d-canvas3d/#paintGL-signal">paintGL</a></b></b>()</li> </ul>  <h2 id="methods">Methods
</h2> <ul> <li class="fn">int <b><b><a href="../qml-qtcanvas3d-canvas3d/#frameSetupTimeMs-method">frameSetupTimeMs</a></b></b>()</li> <li class="fn">int <b><b><a href="../qml-qtcanvas3d-canvas3d/#frameTimeMs-method">frameTimeMs</a></b></b>()</li> <li class="fn">Context3D <b><b><a href="../qml-qtcanvas3d-canvas3d/#getContext-method-1">getContext</a></b></b>(string <i>type</i>, Canvas3DContextAttributes <i>options</i>)</li> <li class="fn">Context3D <b><b><a href="../qml-qtcanvas3d-canvas3d/#getContext-method">getContext</a></b></b>(string <i>type</i>)</li> <li class="fn">void <b><b><a href="../qml-qtcanvas3d-canvas3d/#requestRender-method">requestRender</a></b></b>()</li> </ul>   <h2 id="details">Detailed Description
</h2> <p>The <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> is a QML element that, when placed in your Qt Quick 2 scene, allows you to get a 3D rendering context and call 3D rendering API calls through that context object. Use of the rendering API requires knowledge of OpenGL-like rendering APIs.</p> <p>There are two functions that are called by the <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> implementation:</p> <ul> <li>
<a href="../qml-qtcanvas3d-canvas3d/#initializeGL-signal">initializeGL</a> is emitted before the first frame is rendered, and usually during that you get the 3D context and initialize resources to be used later on during the rendering cycle.</li> <li>
<a href="../qml-qtcanvas3d-canvas3d/#paintGL-signal">paintGL</a> is emitted for each frame to be rendered, and usually during that you submit 3D rendering calls to draw whatever 3D content you want to be displayed.</li> </ul> <p><b>See also </b><a href="../qml-qtcanvas3d-context3d/">Context3D</a>.</p>  <h2>Property Documentation</h2>  <h3 class="qmlproto" id="context-prop"></h3>
<p> <span class="name">context</span> : <span class="type"><a href="../qml-qtcanvas3d-context3d/">Context3D</a></span></p>
<p>This property can be used to access the context created with <a href="../qml-qtcanvas3d-canvas3d/#getContext-method">getContext()</a> method.</p> <p><b>See also </b><a href="../qml-qtcanvas3d-canvas3d/#getContext-method">getContext()</a>.</p>    <h3 class="qmlproto" id="devicePixelRatio-prop"></h3>
<p> <span class="name">devicePixelRatio</span> : <span class="type">float</span></p>
<p>Specifies the ratio between logical pixels (used by the Qt Quick) and actual physical on-screen pixels (used by the 3D rendering).</p>    <h3 class="qmlproto" id="fps-prop"></h3>
<p> <span class="name">fps</span> : <span class="type"><a href="../qml-int/">int</a></span></p>
<p>This property specifies the current number of frames rendered per second. The value is recalculated every 500 ms, as long as any rendering is done.</p> <p><b>Note: </b>This property only gets updated after a <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> frame is rendered, so if no frames are being drawn, this property value won't change. It is also based on the number of <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> frames actually rendered since the value was last updated, so it may not accurately reflect the actual rendering performance when If <a href="../qml-qtcanvas3d-canvas3d/#renderOnDemand-prop">Canvas3D.renderOnDemand</a> property is <code>true</code>.</p>
<p><b>See also </b><a href="../qml-qtcanvas3d-canvas3d/#frameTimeMs-method">frameTimeMs</a>.</p>    <h3 class="qmlproto" id="pixelSize-prop"></h3>
<p> <span class="name">pixelSize</span> : <span class="type"><a href="../qml-size/">size</a></span></p>
<p>Specifies the size of the render target surface in physical on-screen pixels used by the 3D rendering.</p>    <h3 class="qmlproto" id="renderOnDemand-prop"></h3>
<p> <span class="name">renderOnDemand</span> : <span class="type"><a href="../qml-bool/">bool</a></span></p>
<p>If the value is <code>false</code>, the render loop runs constantly and <a href="../qml-qtcanvas3d-canvas3d/#paintGL-signal">Canvas3D.paintGL()</a> signal is emitted once per frame. If the value is <code>true</code>, <a href="../qml-qtcanvas3d-canvas3d/#paintGL-signal">Canvas3D.paintGL()</a> is only emitted when <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> content needs to be re-rendered because a geometry change or some other event affecting the <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> content occurred. The application can also request a render using <a href="../qml-qtcanvas3d-canvas3d/#requestRender-method">Canvas3D.requestRender()</a> method.</p>    <h3 class="qmlproto" id="renderTarget-prop"></h3>
<p> <span class="name">renderTarget</span> : <span class="type">RenderTarget</span></p>
<p>Specifies how the rendering should be done.</p> <ul> <li>
<code>Canvas3D.RenderTargetOffscreenBuffer</code> indicates rendering is done into an offscreen buffer and the finished texture is used for the <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> item. This is the default target.</li> <li>
<code>Canvas3D.RenderTargetBackground</code> indicates the rendering is done to the background of the Qt Quick scene, in response to <a href="../qquickwindow/#beforeRendering">QQuickWindow::beforeRendering()</a> signal.</li> <li>
<code>Canvas3D.RenderTargetForeground</code> indicates the rendering is done to the foreground of the Qt Quick scene, in response to <a href="../qquickwindow/#afterRendering">QQuickWindow::afterRendering()</a> signal.</li> </ul> <p><code>Canvas3D.RenderTargetBackground</code> and <code>Canvas3D.RenderTargetForeground</code> targets render directly to the same framebuffer the rest of the Qt Quick scene uses. This will improve performance on platforms that are fill-rate limited, but using these targets imposes several limitations on the usage of <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a>:</p> <ul> <li>Synchronous <a href="../qml-qtcanvas3d-context3d/">Context3D</a> commands are not supported outside <a href="../qml-qtcanvas3d-canvas3d/#initializeGL-signal">Canvas3D.initializeGL()</a> signal handler when rendering directly to Qt Quick scene framebuffer, as they cause portions of the command queue to be executed outside the normal frame render sequence, which interferes with the frame clearing logic. Using them will usually result in <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> content not rendering properly. A synchronous command is any <a href="../qml-qtcanvas3d-context3d/">Context3D</a> command that requires waiting for <a href="../qml-qtcanvas3d-context3d/">Context3D</a> command queue to finish executing before it returns, such as <a href="../qml-qtcanvas3d-context3d/#getError-method">Context3D.getError()</a>, <a href="../qml-qtcanvas3d-context3d/#finish-method">Context3D.finish()</a>, or <a href="../qml-qtcanvas3d-context3d/#readPixels-method">Context3D.readPixels()</a>. When in doubt, see the individual command documentation to see if that command is synchronous. If your application requires synchronous commands outside <a href="../qml-qtcanvas3d-canvas3d/#initializeGL-signal">Canvas3D.initializeGL()</a> signal handler, you should use <code>Canvas3D.RenderTargetOffscreenBuffer</code> render target.</li> <li>Only <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> items that fill the entire window are supported. Note that you can still control the actual rendering area by using an appropriate viewport.</li> <li>The default framebuffer is automatically cleared by <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> every time before the Qt Quick scene renders a frame, even if there are no <a href="../qml-qtcanvas3d-context3d/">Context3D</a> commands queued for that frame. This requires <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> to store the commands used to draw the previous frame in case the window is updated by some other component than <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> and use those commands to render the <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> content for frames that do not have fresh content. Only commands issued inside <a href="../qml-qtcanvas3d-canvas3d/#paintGL-signal">Canvas3D.paintGL()</a> signal handler are stored this way. You need to make sure that the content of your <a href="../qml-qtcanvas3d-canvas3d/#paintGL-signal">Canvas3D.paintGL()</a> signal handler is implemented so that it is safe to execute its commands repeatedly. Mainly this means making sure you don't use any synchronous commands or commands that create new persistent OpenGL resources there.</li> <li>Issuing <a href="../qml-qtcanvas3d-context3d/">Context3D</a> commands outside <a href="../qml-qtcanvas3d-canvas3d/#paintGL-signal">Canvas3D.paintGL()</a> and <a href="../qml-qtcanvas3d-canvas3d/#initializeGL-signal">Canvas3D.initializeGL()</a> signal handlers can in some cases cause unwanted flickering of <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> content, particularly if on-demand rendering is used. It is recommended to avoid issuing any <a href="../qml-qtcanvas3d-context3d/">Context3D</a> commands outside these two signal handlers.</li> <li>When drawing to the foreground, you should never issue a <a href="../qml-qtcanvas3d-context3d/#clear-method">Context3D.clear(Context3D.GL_COLOR_BUFFER_BIT)</a> command targeting the default framebuffer, as that will clear all other Qt Quick items from the scene. Clearing depth and stencil buffers is allowed.</li> <li>Antialiasing is only supported if the surface format of the window supports multisampling. You may need to specify the surface format of the window explicitly in your <code>main.cpp</code>.</li> <li>You lose the ability to control the z-order of the <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> item itself, as it is always drawn either behind or in front of all other Qt Quick items.</li> <li>The context attributes given as <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a>.<a href="../qml-qtcanvas3d-canvas3d/#getContext-method">getContext()</a> parameters are ignored and the corresponding values of the Qt Quick context are used.</li> <li>Drawing to the background or the foreground doesn't work when Qt Quick is using OpenGL core profile, as <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> requires either OpenGL 2.x compatibility or OpenGL ES2.</li> </ul> <p>This property can only be modified before the <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> item has been rendered for the first time.</p>   <h2>Signal Documentation</h2>  <h3 class="qmlproto" id="contextLost-signal"></h3>
<p> <span class="type">void</span> <span class="name">contextLost</span>()</p>
<p>Emitted when OpenGL context is lost. This happens whenever the parent window of the <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> is destroyed (or otherwise loses its context), or <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> is moved to a different window. Removing <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> from a window and adding it back to the same window doesn't cause context loss, as long as the window itself stays alive.</p> <p>When context is lost, all objects created by <a href="../qml-qtcanvas3d-context3d/">Context3D</a> are invalidated.</p> <p><b>See also </b><a href="../qml-qtcanvas3d-canvas3d/#contextRestored-signal">contextRestored</a>.</p>    <h3 class="qmlproto" id="contextRestored-signal"></h3>
<p> <span class="type">void</span> <span class="name">contextRestored</span>()</p>
<p>Emitted when OpenGL context is restored after a loss of context occurred. The <a href="../qml-qtcanvas3d-context3d/">Context3D</a> attached to the canvas needs to be reinitialized, so <a href="../qml-qtcanvas3d-canvas3d/#initializeGL-signal">initializeGL</a> is also emitted after this signal.</p> <p><b>See also </b><a href="../qml-qtcanvas3d-canvas3d/#contextLost-signal">contextLost</a>.</p>    <h3 class="qmlproto" id="initializeGL-signal"></h3>
<p> <span class="type">void</span> <span class="name">initializeGL</span>()</p>
<p>Emitted once when <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> is ready and OpenGL state initialization can be done by the client.</p>    <h3 class="qmlproto" id="paintGL-signal"></h3>
<p> <span class="type">void</span> <span class="name">paintGL</span>()</p>
<p>Emitted each time a new frame should be drawn to <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a>. Driven by the Qt Quick scenegraph loop.</p>   <h2>Method Documentation</h2>  <h3 class="qmlproto" id="frameSetupTimeMs-method"></h3>
<p> <span class="type"><a href="../qml-int/">int</a></span> <span class="name">frameSetupTimeMs</span>()</p>
<p>This method returns the number of milliseconds <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a> took to process the PaintGL signal for the previous frame. Before any frames have been rendered this method returns 0. This time doesn't include time spent on actual OpenGL rendering of the frame, nor the time the scene graph takes to present the frame to the screen. This value is updated after PaintGL signal handler returns.</p> <p>This QML method was introduced in QtCanvas3D 1.1.</p> <p><b>See also </b><a href="../qml-qtcanvas3d-canvas3d/#fps-prop">fps</a> and <a href="../qml-qtcanvas3d-canvas3d/#frameTimeMs-method">frameTimeMs</a>.</p>    <h3 class="qmlproto" id="frameTimeMs-method"></h3>
<p> <span class="type"><a href="../qml-int/">int</a></span> <span class="name">frameTimeMs</span>()</p>
<p>This method returns the number of milliseconds the renderer took to process the OpenGL portion of the rendering for the previous frame. Before any frames have been rendered this method returns 0. This time is measured from the point OpenGL commands are transferred to render thread to the time glFinish() returns, so it doesn't include the time spent parsing JavaScript, nor the time the scene graph takes to present the frame to the screen. This value is updated for the previous frame when the next frame OpenGL command transfer is done.</p> <p><b>See also </b><a href="../qml-qtcanvas3d-canvas3d/#fps-prop">fps</a> and <a href="../qml-qtcanvas3d-canvas3d/#frameSetupTimeMs-method">frameSetupTimeMs</a>.</p>    <h3 class="qmlproto" id="getContext-method-1"></h3>
<p> <span class="type"><a href="../qml-qtcanvas3d-context3d/">Context3D</a></span> <span class="name">getContext</span>(<span class="type"><a href="../qml-string/">string</a></span> <i>type</i>, <span class="type"><a href="../qml-qtcanvas3d-canvas3dcontextattributes/">Canvas3DContextAttributes</a></span> <i>options</i>)</p>
<p>Returns the 3D rendering context that allows 3D rendering calls to be made. The <i>type</i> parameter is ignored for now, but a string is expected to be given. If <a href="../qml-qtcanvas3d-canvas3d/">Canvas3D</a>.<a href="../qml-qtcanvas3d-canvas3d/#renderTarget-prop">renderTarget</a> property value is either <code>Canvas3D.RenderTargetBackground</code> or <code>Canvas3D.RenderTargetForeground</code>, the <i>options</i> parameter is also ignored, the context attributes of the Qt Quick context are used, and the <a href="../qml-qtcanvas3d-canvas3dcontextattributes/#preserveDrawingBuffer-prop">Canvas3DContextAttributes.preserveDrawingBuffer</a> property is forced to <code>false</code>. The <i>options</i> parameter is only parsed when the first call to <a href="../qml-qtcanvas3d-canvas3d/#getContext-method">getContext()</a> is made and is ignored in subsequent calls if given. If the first call is made without giving the <i>options</i> parameter, then the context and render target is initialized with default configuration.</p> <p><b>See also </b><a href="../qml-qtcanvas3d-canvas3dcontextattributes/">Canvas3DContextAttributes</a>, <a href="../qml-qtcanvas3d-context3d/">Context3D</a>, and <a href="../qml-qtcanvas3d-canvas3d/#renderTarget-prop">renderTarget</a>.</p>    <h3 class="qmlproto" id="getContext-method"></h3>
<p> <span class="type"><a href="../qml-qtcanvas3d-context3d/">Context3D</a></span> <span class="name">getContext</span>(<span class="type"><a href="../qml-string/">string</a></span> <i>type</i>)</p>
<p>Returns the 3D rendering context that allows 3D rendering calls to be made. The <i>type</i> parameter is ignored for now, but a string is expected to be given.</p>    <h3 class="qmlproto" id="requestRender-method"></h3>
<p> <span class="type">void</span> <span class="name">requestRender</span>()</p>
<p>Queues a new frame for rendering when <a href="../qml-qtcanvas3d-canvas3d/#renderOnDemand-prop">Canvas3D.renderOnDemand</a> property is <code>true</code>. Does nothing when <a href="../qml-qtcanvas3d-canvas3d/#renderOnDemand-prop">Canvas3D.renderOnDemand</a> property is <code>false</code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-5/qml-qtcanvas3d-canvas3d.html" class="_attribution-link" target="_blank">https://doc.qt.io/qt-5/qml-qtcanvas3d-canvas3d.html</a>
  </p>
</div>

				<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
