
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Qt Remote Objects Replica - Qt 5.11 - W3cubDocs</title>
  
  <meta name="description" content="A remote object replica is a proxy object that has (approximately) the same API as the Source QObject it is replicating. There are a few additional &hellip;">
  <meta name="keywords" content="qt, remote, objects, replica, -, qt~5.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/qt~5.11/qtremoteobjects-replica/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/qt~5.11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt~5.11/" class="_nav-link" title="" style="margin-left:0;">Qt 5.11</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _qt">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1 class="title">Qt Remote Objects Replica</h1>      <h2 id="replica-objects">Replica Objects
</h2> <p>A remote object replica is a proxy object that has (approximately) the same API as the <a href="../qtremoteobjects-source/#source">Source</a> <a href="../qobject/">QObject</a> it is replicating. There are a few additional properties and signals to make it possible to detect when the Replica is initialized or if it loses the connectivity to the <a href="../qtremoteobjects-source/#source">Source</a> object. There are a few other differences: a constant property on the source cannot be constant on the replica. The value will not be known at the time the replica is instantiated, it will only be known once the replica is initialized (see <a href="https://doc.qt.io/qt-5/qtremoteobjects-interaction.html#remote-object-interaction" target="_blank">Remote Object Interaction</a>).</p> <p>A compiled replica is a <a href="../qremoteobjectreplica/">QRemoteObjectReplica</a> based type, where the derived class definition is automatically generated by the <a href="../qtremoteobjects-repc/">repc</a> compiler. Only a header file is generated (and using the <a href="../qtremoteobjects-repc/#repc-replica">REPC_REPLICA</a> macro in your .pro file can make generation part of the build process), but it is a complete type. There is no public constructor, you need to use the <a href="../qremoteobjectnode/#acquire">QRemoteObjectNode::acquire</a> template function to create the Replica instance.</p> <p>A <a href="../qremoteobjectdynamicreplica/">QRemoteObjectDynamicReplica</a> can be generated at runtime. To do so, you call the non-templated version of <a href="../qremoteobjectnode/#acquire">QRemoteObjectNode::acquire</a>(), passing in as an argument the <a href="../qtremoteobjects-source/#source">Source</a> name (a <a href="../qstring/">QString</a>). Dynamic replicas are a bit more verbose to use from C++, but do not require compilation and can be used easily in QML or (potentially) exposed to scripting languages such as Python. Dynamic replicas do not support initial property values, and do not support introspection until they have been initialized.</p> <p>An important difference between these two ways of creating replicas is the behavior before the replica is initialized. Since a Dynamic replica only gets a metaObject after initialization, it basically has no API before initialization. No properties, and no Signals to connect slots to. Due to the compile-time creation of the metaObject for compiled replicas, their API is available when the replica is instantiated. You can even provide default values for Properties in the template file, which will be used until the replica is initialized with current values from the Source.</p> <p>See <a href="../qremoteobjectreplica/">QRemoteObjectReplica</a> and <a href="../qremoteobjectdynamicreplica/">QRemoteObjectDynamicReplica</a></p>  <h2 id="replica-initialization">Replica Initialization
</h2> <p>A host node will share the list of sources it hosts and every other node that connects to it. It will send updates when sources are added or removed from the list. In this way, a connected node will always know what sources it can attach to. Changes to a specific <a href="../qtremoteobjects-source/#source">Source</a> are only propagated to nodes that have a replica of that source. This avoids unnecessary network traffic.</p> <p>When a node acquires a replica for a known source, the replica node sends a request for that source to the host node. Upon receipt of this request, the host will create a reply packet with the current values of all properties of the source. If the requested replica is dynamic, it will include the API definition for the source. The replica node will be included in the list of connections that receive changes to that source from then on.</p> <p>If a replica is instantiated but the node is not connected to the node that hosts the requested source (or that object lives in a host node process, but sharing/remoting has not been enabled for the <a href="../qobject/">QObject</a>), the Replica will still be created, it will just remain uninitialized.</p> <p>If, at a later time, the replica node gets notified that the requested source is available from a connected node, it will at that point request the source and start the initialization process.</p> <p>If the connection to a host node is lost, the replica will transition to the invalid state. It will attempt to reconnect and will re-initialize if the connection is restored (this making sure all Properties are current).</p>  <h2 id="replica-ownership">Replica Ownership
</h2> <p>The acquire methods return a pointer to the replica <a href="../qobject/">QObject</a> instantiated by the node. The node has no way of knowing the intended lifetime of the replica, so it is the responsibility of the calling program to delete the replica when it is no longer needed.</p> <p>You can instantiate multiple copies of the same replica (this may be necessary in QML for instance). All replicas of the same source from a single node will share a private data member which handles the network communication. This means multiple instances of a <a href="../qtremoteobjects-replica/#replica">Replica</a> do not introduce additional network traffic, although there will be some additional processing overhead. Failing to delete replicas will prevent the reference count on this private object to be invalid, and cause unnecessary network communication until the calling process exits. For this reason, it is recommended that <a href="../qscopedpointer/">QScopedPointer</a> or <a href="../qsharedpointer/">QSharedPointer</a> be used to help track a replica lifetime.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-5/qtremoteobjects-replica.html" class="_attribution-link" target="_blank">https://doc.qt.io/qt-5/qtremoteobjects-replica.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
